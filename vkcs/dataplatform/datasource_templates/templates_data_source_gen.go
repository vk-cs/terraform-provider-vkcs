// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_templates

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func TemplatesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"cluster_templates": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"availability_zone": schema.StringAttribute{
							Computed: true,
						},
						"configs": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"common": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"maintenance": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"backup": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"differential": schema.SingleNestedAttribute{
															Attributes: map[string]schema.Attribute{
																"backup_name_prefix": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup name prefix.",
																	MarkdownDescription: "Backup name prefix.",
																},
																"backup_s3_bucket_name": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup S3 bucket name.",
																	MarkdownDescription: "Backup S3 bucket name.",
																},
																"creation_timeout": schema.Int64Attribute{
																	Computed:            true,
																	Description:         "Backup creation timeout.",
																	MarkdownDescription: "Backup creation timeout.",
																},
																"enabled": schema.BoolAttribute{
																	Computed:            true,
																	Description:         "Whether differential backup is enabled.",
																	MarkdownDescription: "Whether differential backup is enabled.",
																},
																"keep_count": schema.Int64Attribute{
																	Computed: true,
																},
																"keep_time": schema.Int64Attribute{
																	Computed: true,
																},
																"start": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup schedule.",
																	MarkdownDescription: "Backup schedule.",
																},
															},
															CustomType: ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType{
																ObjectType: types.ObjectType{
																	AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
																},
															},
															Computed:            true,
															Description:         "Differential backup settings.",
															MarkdownDescription: "Differential backup settings.",
														},
														"full": schema.SingleNestedAttribute{
															Attributes: map[string]schema.Attribute{
																"backup_name_prefix": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup name prefix.",
																	MarkdownDescription: "Backup name prefix.",
																},
																"backup_s3_bucket_name": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup S3 bucket name.",
																	MarkdownDescription: "Backup S3 bucket name.",
																},
																"creation_timeout": schema.Int64Attribute{
																	Computed:            true,
																	Description:         "Backup creation timeout.",
																	MarkdownDescription: "Backup creation timeout.",
																},
																"enabled": schema.BoolAttribute{
																	Computed:            true,
																	Description:         "Whether full backup is enabled.",
																	MarkdownDescription: "Whether full backup is enabled.",
																},
																"keep_count": schema.Int64Attribute{
																	Computed: true,
																},
																"keep_time": schema.Int64Attribute{
																	Computed: true,
																},
																"start": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup schedule.",
																	MarkdownDescription: "Backup schedule.",
																},
															},
															CustomType: ClusterTemplatesConfigsCommonMaintenanceBackupFullType{
																ObjectType: types.ObjectType{
																	AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
																},
															},
															Computed:            true,
															Description:         "Full backup settings.",
															MarkdownDescription: "Full backup settings.",
														},
														"incremental": schema.SingleNestedAttribute{
															Attributes: map[string]schema.Attribute{
																"backup_name_prefix": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup name prefix.",
																	MarkdownDescription: "Backup name prefix.",
																},
																"backup_s3_bucket_name": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup S3 bucket name.",
																	MarkdownDescription: "Backup S3 bucket name.",
																},
																"creation_timeout": schema.Int64Attribute{
																	Computed:            true,
																	Description:         "Backup creation timeout.",
																	MarkdownDescription: "Backup creation timeout.",
																},
																"enabled": schema.BoolAttribute{
																	Computed:            true,
																	Description:         "Whether incremental backup is enabled.",
																	MarkdownDescription: "Whether incremental backup is enabled.",
																},
																"keep_count": schema.Int64Attribute{
																	Computed: true,
																},
																"keep_time": schema.Int64Attribute{
																	Computed: true,
																},
																"start": schema.StringAttribute{
																	Computed:            true,
																	Description:         "Backup schedule.",
																	MarkdownDescription: "Backup schedule.",
																},
															},
															CustomType: ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType{
																ObjectType: types.ObjectType{
																	AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
																},
															},
															Computed:            true,
															Description:         "Incremental backup settings.",
															MarkdownDescription: "Incremental backup settings.",
														},
													},
													CustomType: ClusterTemplatesConfigsCommonMaintenanceBackupType{
														ObjectType: types.ObjectType{
															AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
														},
													},
													Computed:            true,
													Description:         "Backup settings.",
													MarkdownDescription: "Backup settings.",
												},
												"duration": schema.Int64Attribute{
													Computed:            true,
													Description:         "Maintenance duration.",
													MarkdownDescription: "Maintenance duration.",
												},
												"start": schema.StringAttribute{
													Computed:            true,
													Description:         "Maintenance cron schedule.",
													MarkdownDescription: "Maintenance cron schedule.",
												},
											},
											CustomType: ClusterTemplatesConfigsCommonMaintenanceType{
												ObjectType: types.ObjectType{
													AttrTypes: ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Maintenance settings.",
											MarkdownDescription: "Maintenance settings.",
										},
									},
									CustomType: ClusterTemplatesConfigsCommonType{
										ObjectType: types.ObjectType{
											AttrTypes: ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Common configs.",
									MarkdownDescription: "Common configs.",
								},
							},
							CustomType: ClusterTemplatesConfigsType{
								ObjectType: types.ObjectType{
									AttrTypes: ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Cluster template configs.",
							MarkdownDescription: "Cluster template configs.",
						},
						"created_at": schema.StringAttribute{
							Computed:            true,
							Description:         "Cluster template creation timestamp.",
							MarkdownDescription: "Cluster template creation timestamp.",
						},
						"description": schema.StringAttribute{
							Computed:            true,
							Description:         "Cluster template description.",
							MarkdownDescription: "Cluster template description.",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Cluster template id.",
							MarkdownDescription: "Cluster template id.",
						},
						"is_hidden": schema.BoolAttribute{
							Computed: true,
						},
						"multiaz": schema.BoolAttribute{
							Computed:            true,
							Description:         "Is multiple available zones mode enabled.",
							MarkdownDescription: "Is multiple available zones mode enabled.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Cluster template name.",
							MarkdownDescription: "Cluster template name.",
						},
						"pod_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"alias": schema.StringAttribute{
										Computed:            true,
										Description:         "Alias.",
										MarkdownDescription: "Alias.",
									},
									"backref": schema.StringAttribute{
										Computed:            true,
										Description:         "Backref.",
										MarkdownDescription: "Backref.",
									},
									"cluster_template_id": schema.StringAttribute{
										Computed:            true,
										Description:         "Cluster template id.",
										MarkdownDescription: "Cluster template id.",
									},
									"count": schema.Int64Attribute{
										Computed:            true,
										Description:         "Pod count.",
										MarkdownDescription: "Pod count.",
									},
									"created_at": schema.StringAttribute{
										Computed:            true,
										Description:         "Pod group creation timestamp.",
										MarkdownDescription: "Pod group creation timestamp.",
									},
									"description": schema.StringAttribute{
										Computed:            true,
										Description:         "Pod group name.",
										MarkdownDescription: "Pod group name.",
									},
									"id": schema.StringAttribute{
										Computed:            true,
										Description:         "Pod group id.",
										MarkdownDescription: "Pod group id.",
									},
									"name": schema.StringAttribute{
										Computed:            true,
										Description:         "Pod group name.",
										MarkdownDescription: "Pod group name.",
									},
									"node_processes": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "Node processes.",
										MarkdownDescription: "Node processes.",
									},
									"resource": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"cpu_margin": schema.NumberAttribute{
												Computed:            true,
												Description:         "CPU margin settings.",
												MarkdownDescription: "CPU margin settings.",
											},
											"cpu_request": schema.StringAttribute{
												Computed:            true,
												Description:         "CPU request settings.",
												MarkdownDescription: "CPU request settings.",
											},
											"ram_margin": schema.NumberAttribute{
												Computed:            true,
												Description:         "RAM margin settings.",
												MarkdownDescription: "RAM margin settings.",
											},
											"ram_request": schema.StringAttribute{
												Computed:            true,
												Description:         "RAM request settings.",
												MarkdownDescription: "RAM request settings.",
											},
										},
										CustomType: ClusterTemplatesPodGroupsResourceType{
											ObjectType: types.ObjectType{
												AttrTypes: ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Resource settings.",
										MarkdownDescription: "Resource settings.",
									},
									"template_type": schema.StringAttribute{
										Computed:            true,
										Description:         "Template type.",
										MarkdownDescription: "Template type.",
									},
									"volumes": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"count": schema.Int64Attribute{
													Computed:            true,
													Description:         "Volume count.",
													MarkdownDescription: "Volume count.",
												},
												"storage": schema.StringAttribute{
													Computed:            true,
													Description:         "Storage size.",
													MarkdownDescription: "Storage size.",
												},
												"storage_class_name": schema.StringAttribute{
													Computed:            true,
													Description:         "Storage class name.",
													MarkdownDescription: "Storage class name.",
												},
											},
											CustomType: ClusterTemplatesPodGroupsVolumesType{
												ObjectType: types.ObjectType{
													AttrTypes: ClusterTemplatesPodGroupsVolumesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "Volumes settings.",
										MarkdownDescription: "Volumes settings.",
									},
								},
								CustomType: ClusterTemplatesPodGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: ClusterTemplatesPodGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Cluster pod groups.",
							MarkdownDescription: "Cluster pod groups.",
						},
						"presets": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Computed:            true,
										Description:         "Preset name.",
										MarkdownDescription: "Preset name.",
									},
									"pod_groups": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"count": schema.Int64Attribute{
													Computed:            true,
													Description:         "Pod count.",
													MarkdownDescription: "Pod count.",
												},
												"meta": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"create": schema.SingleNestedAttribute{
															Attributes: map[string]schema.Attribute{
																"property": schema.SingleNestedAttribute{
																	Attributes: map[string]schema.Attribute{
																		"multiplicator": schema.SingleNestedAttribute{
																			Attributes: map[string]schema.Attribute{
																				"allow": schema.BoolAttribute{
																					Computed: true,
																				},
																				"allow_add": schema.BoolAttribute{
																					Computed: true,
																				},
																				"count": schema.Int64Attribute{
																					Computed: true,
																				},
																				"is_read_only": schema.BoolAttribute{
																					Computed: true,
																				},
																				"max": schema.Int64Attribute{
																					Computed: true,
																				},
																				"min": schema.Int64Attribute{
																					Computed: true,
																				},
																			},
																			CustomType: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType{
																				ObjectType: types.ObjectType{
																					AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
																				},
																			},
																			Computed: true,
																		},
																	},
																	CustomType: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType{
																		ObjectType: types.ObjectType{
																			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
																		},
																	},
																	Computed: true,
																},
															},
															CustomType: ClusterTemplatesPresetsPodGroupsMetaCreateType{
																ObjectType: types.ObjectType{
																	AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
																},
															},
															Computed: true,
														},
													},
													CustomType: ClusterTemplatesPresetsPodGroupsMetaType{
														ObjectType: types.ObjectType{
															AttrTypes: ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
														},
													},
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed:            true,
													Description:         "Pod group name.",
													MarkdownDescription: "Pod group name.",
												},
												"resource": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"cpu_request": schema.StringAttribute{
															Computed:            true,
															Description:         "CPU request settings.",
															MarkdownDescription: "CPU request settings.",
														},
														"ram_request": schema.StringAttribute{
															Computed:            true,
															Description:         "RAM request settings.",
															MarkdownDescription: "RAM request settings.",
														},
													},
													CustomType: ClusterTemplatesPresetsPodGroupsResourceType{
														ObjectType: types.ObjectType{
															AttrTypes: ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
														},
													},
													Computed:            true,
													Description:         "Resource settings.",
													MarkdownDescription: "Resource settings.",
												},
												"volumes": schema.MapNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"count": schema.Int64Attribute{
																Computed:            true,
																Description:         "Volume count.",
																MarkdownDescription: "Volume count.",
															},
															"storage": schema.StringAttribute{
																Computed:            true,
																Description:         "Storage size.",
																MarkdownDescription: "Storage size.",
															},
															"storage_class_name": schema.StringAttribute{
																Computed:            true,
																Description:         "Storage class name.",
																MarkdownDescription: "Storage class name.",
															},
														},
														CustomType: ClusterTemplatesPresetsPodGroupsVolumesType{
															ObjectType: types.ObjectType{
																AttrTypes: ClusterTemplatesPresetsPodGroupsVolumesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Computed:            true,
													Description:         "Volumes settings.",
													MarkdownDescription: "Volumes settings.",
												},
											},
											CustomType: ClusterTemplatesPresetsPodGroupsType{
												ObjectType: types.ObjectType{
													AttrTypes: ClusterTemplatesPresetsPodGroupsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "Preset pod groups.",
										MarkdownDescription: "Preset pod groups.",
									},
								},
								CustomType: ClusterTemplatesPresetsType{
									ObjectType: types.ObjectType{
										AttrTypes: ClusterTemplatesPresetsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Presets info.",
							MarkdownDescription: "Presets info.",
						},
						"product_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Product name.",
							MarkdownDescription: "Product name.",
						},
						"product_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Product type.",
							MarkdownDescription: "Product type.",
						},
						"product_version": schema.StringAttribute{
							Computed:            true,
							Description:         "Product version.",
							MarkdownDescription: "Product version.",
						},
						"template_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Template type.",
							MarkdownDescription: "Template type.",
						},
					},
					CustomType: ClusterTemplatesType{
						ObjectType: types.ObjectType{
							AttrTypes: ClusterTemplatesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "Cluster templates info.",
				MarkdownDescription: "Cluster templates info.",
			},
		},
	}
}

type TemplatesModel struct {
	ClusterTemplates types.List `tfsdk:"cluster_templates"`
}

var _ basetypes.ObjectTypable = ClusterTemplatesType{}

type ClusterTemplatesType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesType) String() string {
	return "ClusterTemplatesType"
}

func (t ClusterTemplatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return nil, diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	configsAttribute, ok := attributes["configs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configs is missing from object`)

		return nil, diags
	}

	configsVal, ok := configsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configs expected to be basetypes.ObjectValue, was: %T`, configsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	isHiddenAttribute, ok := attributes["is_hidden"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_hidden is missing from object`)

		return nil, diags
	}

	isHiddenVal, ok := isHiddenAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_hidden expected to be basetypes.BoolValue, was: %T`, isHiddenAttribute))
	}

	multiazAttribute, ok := attributes["multiaz"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multiaz is missing from object`)

		return nil, diags
	}

	multiazVal, ok := multiazAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multiaz expected to be basetypes.BoolValue, was: %T`, multiazAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podGroupsAttribute, ok := attributes["pod_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_groups is missing from object`)

		return nil, diags
	}

	podGroupsVal, ok := podGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_groups expected to be basetypes.ListValue, was: %T`, podGroupsAttribute))
	}

	presetsAttribute, ok := attributes["presets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`presets is missing from object`)

		return nil, diags
	}

	presetsVal, ok := presetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`presets expected to be basetypes.ListValue, was: %T`, presetsAttribute))
	}

	productNameAttribute, ok := attributes["product_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_name is missing from object`)

		return nil, diags
	}

	productNameVal, ok := productNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_name expected to be basetypes.StringValue, was: %T`, productNameAttribute))
	}

	productTypeAttribute, ok := attributes["product_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_type is missing from object`)

		return nil, diags
	}

	productTypeVal, ok := productTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_type expected to be basetypes.StringValue, was: %T`, productTypeAttribute))
	}

	productVersionAttribute, ok := attributes["product_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_version is missing from object`)

		return nil, diags
	}

	productVersionVal, ok := productVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_version expected to be basetypes.StringValue, was: %T`, productVersionAttribute))
	}

	templateTypeAttribute, ok := attributes["template_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_type is missing from object`)

		return nil, diags
	}

	templateTypeVal, ok := templateTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_type expected to be basetypes.StringValue, was: %T`, templateTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesValue{
		AvailabilityZone: availabilityZoneVal,
		Configs:          configsVal,
		CreatedAt:        createdAtVal,
		Description:      descriptionVal,
		Id:               idVal,
		IsHidden:         isHiddenVal,
		Multiaz:          multiazVal,
		Name:             nameVal,
		PodGroups:        podGroupsVal,
		Presets:          presetsVal,
		ProductName:      productNameVal,
		ProductType:      productTypeVal,
		ProductVersion:   productVersionVal,
		TemplateType:     templateTypeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesValueNull() ClusterTemplatesValue {
	return ClusterTemplatesValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesValueUnknown() ClusterTemplatesValue {
	return ClusterTemplatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesValue Attribute Value",
				"While creating a ClusterTemplatesValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesValue Attribute Type",
				"While creating a ClusterTemplatesValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesValue Attribute Value",
				"While creating a ClusterTemplatesValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesValueUnknown(), diags
	}

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	configsAttribute, ok := attributes["configs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configs is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	configsVal, ok := configsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configs expected to be basetypes.ObjectValue, was: %T`, configsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	isHiddenAttribute, ok := attributes["is_hidden"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_hidden is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	isHiddenVal, ok := isHiddenAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_hidden expected to be basetypes.BoolValue, was: %T`, isHiddenAttribute))
	}

	multiazAttribute, ok := attributes["multiaz"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multiaz is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	multiazVal, ok := multiazAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multiaz expected to be basetypes.BoolValue, was: %T`, multiazAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podGroupsAttribute, ok := attributes["pod_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_groups is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	podGroupsVal, ok := podGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_groups expected to be basetypes.ListValue, was: %T`, podGroupsAttribute))
	}

	presetsAttribute, ok := attributes["presets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`presets is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	presetsVal, ok := presetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`presets expected to be basetypes.ListValue, was: %T`, presetsAttribute))
	}

	productNameAttribute, ok := attributes["product_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_name is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	productNameVal, ok := productNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_name expected to be basetypes.StringValue, was: %T`, productNameAttribute))
	}

	productTypeAttribute, ok := attributes["product_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_type is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	productTypeVal, ok := productTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_type expected to be basetypes.StringValue, was: %T`, productTypeAttribute))
	}

	productVersionAttribute, ok := attributes["product_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`product_version is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	productVersionVal, ok := productVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`product_version expected to be basetypes.StringValue, was: %T`, productVersionAttribute))
	}

	templateTypeAttribute, ok := attributes["template_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_type is missing from object`)

		return NewClusterTemplatesValueUnknown(), diags
	}

	templateTypeVal, ok := templateTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_type expected to be basetypes.StringValue, was: %T`, templateTypeAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesValueUnknown(), diags
	}

	return ClusterTemplatesValue{
		AvailabilityZone: availabilityZoneVal,
		Configs:          configsVal,
		CreatedAt:        createdAtVal,
		Description:      descriptionVal,
		Id:               idVal,
		IsHidden:         isHiddenVal,
		Multiaz:          multiazVal,
		Name:             nameVal,
		PodGroups:        podGroupsVal,
		Presets:          presetsVal,
		ProductName:      productNameVal,
		ProductType:      productTypeVal,
		ProductVersion:   productVersionVal,
		TemplateType:     templateTypeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesValue {
	object, diags := NewClusterTemplatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesValueMust(ClusterTemplatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesValue{}

type ClusterTemplatesValue struct {
	AvailabilityZone basetypes.StringValue `tfsdk:"availability_zone"`
	Configs          basetypes.ObjectValue `tfsdk:"configs"`
	CreatedAt        basetypes.StringValue `tfsdk:"created_at"`
	Description      basetypes.StringValue `tfsdk:"description"`
	Id               basetypes.StringValue `tfsdk:"id"`
	IsHidden         basetypes.BoolValue   `tfsdk:"is_hidden"`
	Multiaz          basetypes.BoolValue   `tfsdk:"multiaz"`
	Name             basetypes.StringValue `tfsdk:"name"`
	PodGroups        basetypes.ListValue   `tfsdk:"pod_groups"`
	Presets          basetypes.ListValue   `tfsdk:"presets"`
	ProductName      basetypes.StringValue `tfsdk:"product_name"`
	ProductType      basetypes.StringValue `tfsdk:"product_type"`
	ProductVersion   basetypes.StringValue `tfsdk:"product_version"`
	TemplateType     basetypes.StringValue `tfsdk:"template_type"`
	state            attr.ValueState
}

func (v ClusterTemplatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["availability_zone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["configs"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_hidden"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multiaz"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_groups"] = basetypes.ListType{
		ElemType: ClusterTemplatesPodGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["presets"] = basetypes.ListType{
		ElemType: ClusterTemplatesPresetsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["product_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["product_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["product_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AvailabilityZone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zone"] = val

		val, err = v.Configs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configs"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IsHidden.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_hidden"] = val

		val, err = v.Multiaz.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multiaz"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PodGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_groups"] = val

		val, err = v.Presets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["presets"] = val

		val, err = v.ProductName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_name"] = val

		val, err = v.ProductType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_type"] = val

		val, err = v.ProductVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["product_version"] = val

		val, err = v.TemplateType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesValue) String() string {
	return "ClusterTemplatesValue"
}

func (v ClusterTemplatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var configs basetypes.ObjectValue

	if v.Configs.IsNull() {
		configs = types.ObjectNull(
			ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Configs.IsUnknown() {
		configs = types.ObjectUnknown(
			ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Configs.IsNull() && !v.Configs.IsUnknown() {
		configs = types.ObjectValueMust(
			ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
			v.Configs.Attributes(),
		)
	}

	podGroups := types.ListValueMust(
		ClusterTemplatesPodGroupsType{
			basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPodGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.PodGroups.Elements(),
	)

	if v.PodGroups.IsNull() {
		podGroups = types.ListNull(
			ClusterTemplatesPodGroupsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPodGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PodGroups.IsUnknown() {
		podGroups = types.ListUnknown(
			ClusterTemplatesPodGroupsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPodGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	presets := types.ListValueMust(
		ClusterTemplatesPresetsType{
			basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPresetsValue{}.AttributeTypes(ctx),
			},
		},
		v.Presets.Elements(),
	)

	if v.Presets.IsNull() {
		presets = types.ListNull(
			ClusterTemplatesPresetsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Presets.IsUnknown() {
		presets = types.ListUnknown(
			ClusterTemplatesPresetsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"availability_zone": basetypes.StringType{},
		"configs": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
		},
		"created_at":  basetypes.StringType{},
		"description": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"is_hidden":   basetypes.BoolType{},
		"multiaz":     basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"pod_groups": basetypes.ListType{
			ElemType: ClusterTemplatesPodGroupsValue{}.Type(ctx),
		},
		"presets": basetypes.ListType{
			ElemType: ClusterTemplatesPresetsValue{}.Type(ctx),
		},
		"product_name":    basetypes.StringType{},
		"product_type":    basetypes.StringType{},
		"product_version": basetypes.StringType{},
		"template_type":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"availability_zone": v.AvailabilityZone,
			"configs":           configs,
			"created_at":        v.CreatedAt,
			"description":       v.Description,
			"id":                v.Id,
			"is_hidden":         v.IsHidden,
			"multiaz":           v.Multiaz,
			"name":              v.Name,
			"pod_groups":        podGroups,
			"presets":           presets,
			"product_name":      v.ProductName,
			"product_type":      v.ProductType,
			"product_version":   v.ProductVersion,
			"template_type":     v.TemplateType,
		})

	return objVal, diags
}

func (v ClusterTemplatesValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AvailabilityZone.Equal(other.AvailabilityZone) {
		return false
	}

	if !v.Configs.Equal(other.Configs) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IsHidden.Equal(other.IsHidden) {
		return false
	}

	if !v.Multiaz.Equal(other.Multiaz) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PodGroups.Equal(other.PodGroups) {
		return false
	}

	if !v.Presets.Equal(other.Presets) {
		return false
	}

	if !v.ProductName.Equal(other.ProductName) {
		return false
	}

	if !v.ProductType.Equal(other.ProductType) {
		return false
	}

	if !v.ProductVersion.Equal(other.ProductVersion) {
		return false
	}

	if !v.TemplateType.Equal(other.TemplateType) {
		return false
	}

	return true
}

func (v ClusterTemplatesValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"availability_zone": basetypes.StringType{},
		"configs": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsValue{}.AttributeTypes(ctx),
		},
		"created_at":  basetypes.StringType{},
		"description": basetypes.StringType{},
		"id":          basetypes.StringType{},
		"is_hidden":   basetypes.BoolType{},
		"multiaz":     basetypes.BoolType{},
		"name":        basetypes.StringType{},
		"pod_groups": basetypes.ListType{
			ElemType: ClusterTemplatesPodGroupsValue{}.Type(ctx),
		},
		"presets": basetypes.ListType{
			ElemType: ClusterTemplatesPresetsValue{}.Type(ctx),
		},
		"product_name":    basetypes.StringType{},
		"product_type":    basetypes.StringType{},
		"product_version": basetypes.StringType{},
		"template_type":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsType{}

type ClusterTemplatesConfigsType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsType) String() string {
	return "ClusterTemplatesConfigsType"
}

func (t ClusterTemplatesConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commonAttribute, ok := attributes["common"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common is missing from object`)

		return nil, diags
	}

	commonVal, ok := commonAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common expected to be basetypes.ObjectValue, was: %T`, commonAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsValue{
		Common: commonVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsValueNull() ClusterTemplatesConfigsValue {
	return ClusterTemplatesConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsValueUnknown() ClusterTemplatesConfigsValue {
	return ClusterTemplatesConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsValue Attribute Value",
				"While creating a ClusterTemplatesConfigsValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsValue Attribute Type",
				"While creating a ClusterTemplatesConfigsValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsValue Attribute Value",
				"While creating a ClusterTemplatesConfigsValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsValueUnknown(), diags
	}

	commonAttribute, ok := attributes["common"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common is missing from object`)

		return NewClusterTemplatesConfigsValueUnknown(), diags
	}

	commonVal, ok := commonAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common expected to be basetypes.ObjectValue, was: %T`, commonAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsValueUnknown(), diags
	}

	return ClusterTemplatesConfigsValue{
		Common: commonVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsValue {
	object, diags := NewClusterTemplatesConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsValueMust(ClusterTemplatesConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsValue{}

type ClusterTemplatesConfigsValue struct {
	Common basetypes.ObjectValue `tfsdk:"common"`
	state  attr.ValueState
}

func (v ClusterTemplatesConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["common"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Common.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["common"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsValue) String() string {
	return "ClusterTemplatesConfigsValue"
}

func (v ClusterTemplatesConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var common basetypes.ObjectValue

	if v.Common.IsNull() {
		common = types.ObjectNull(
			ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
		)
	}

	if v.Common.IsUnknown() {
		common = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Common.IsNull() && !v.Common.IsUnknown() {
		common = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
			v.Common.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"common": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"common": common,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Common.Equal(other.Common) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"common": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonType{}

type ClusterTemplatesConfigsCommonType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonType) String() string {
	return "ClusterTemplatesConfigsCommonType"
}

func (t ClusterTemplatesConfigsCommonType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return nil, diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonValue{
		Maintenance: maintenanceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonValueNull() ClusterTemplatesConfigsCommonValue {
	return ClusterTemplatesConfigsCommonValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonValueUnknown() ClusterTemplatesConfigsCommonValue {
	return ClusterTemplatesConfigsCommonValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonValueUnknown(), diags
	}

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return NewClusterTemplatesConfigsCommonValueUnknown(), diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonValue{
		Maintenance: maintenanceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonValue {
	object, diags := NewClusterTemplatesConfigsCommonValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonValueMust(ClusterTemplatesConfigsCommonValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonValue{}

type ClusterTemplatesConfigsCommonValue struct {
	Maintenance basetypes.ObjectValue `tfsdk:"maintenance"`
	state       attr.ValueState
}

func (v ClusterTemplatesConfigsCommonValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["maintenance"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Maintenance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonValue) String() string {
	return "ClusterTemplatesConfigsCommonValue"
}

func (v ClusterTemplatesConfigsCommonValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var maintenance basetypes.ObjectValue

	if v.Maintenance.IsNull() {
		maintenance = types.ObjectNull(
			ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Maintenance.IsUnknown() {
		maintenance = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Maintenance.IsNull() && !v.Maintenance.IsUnknown() {
		maintenance = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
			v.Maintenance.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"maintenance": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"maintenance": maintenance,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Maintenance.Equal(other.Maintenance) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"maintenance": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonMaintenanceType{}

type ClusterTemplatesConfigsCommonMaintenanceType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonMaintenanceType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonMaintenanceType) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceType"
}

func (t ClusterTemplatesConfigsCommonMaintenanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return nil, diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceValue{
		Backup:   backupVal,
		Duration: durationVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceValueNull() ClusterTemplatesConfigsCommonMaintenanceValue {
	return ClusterTemplatesConfigsCommonMaintenanceValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceValueUnknown() ClusterTemplatesConfigsCommonMaintenanceValue {
	return ClusterTemplatesConfigsCommonMaintenanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonMaintenanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonMaintenanceValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonMaintenanceValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonMaintenanceValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonMaintenanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), diags
	}

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceValue{
		Backup:   backupVal,
		Duration: durationVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonMaintenanceValue {
	object, diags := NewClusterTemplatesConfigsCommonMaintenanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonMaintenanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonMaintenanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonMaintenanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonMaintenanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonMaintenanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonMaintenanceValueMust(ClusterTemplatesConfigsCommonMaintenanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonMaintenanceType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonMaintenanceValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonMaintenanceValue{}

type ClusterTemplatesConfigsCommonMaintenanceValue struct {
	Backup   basetypes.ObjectValue `tfsdk:"backup"`
	Duration basetypes.Int64Value  `tfsdk:"duration"`
	Start    basetypes.StringValue `tfsdk:"start"`
	state    attr.ValueState
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["backup"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Backup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceValue"
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var backup basetypes.ObjectValue

	if v.Backup.IsNull() {
		backup = types.ObjectNull(
			ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if v.Backup.IsUnknown() {
		backup = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Backup.IsNull() && !v.Backup.IsUnknown() {
		backup = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
			v.Backup.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"duration": basetypes.Int64Type{},
		"start":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup":   backup,
			"duration": v.Duration,
			"start":    v.Start,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Backup.Equal(other.Backup) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonMaintenanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"duration": basetypes.Int64Type{},
		"start":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonMaintenanceBackupType{}

type ClusterTemplatesConfigsCommonMaintenanceBackupType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupType) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupType"
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return nil, diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return nil, diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return nil, diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupValueNull() ClusterTemplatesConfigsCommonMaintenanceBackupValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown() ClusterTemplatesConfigsCommonMaintenanceBackupValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonMaintenanceBackupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonMaintenanceBackupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), diags
	}

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonMaintenanceBackupValue {
	object, diags := NewClusterTemplatesConfigsCommonMaintenanceBackupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonMaintenanceBackupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonMaintenanceBackupValueMust(ClusterTemplatesConfigsCommonMaintenanceBackupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonMaintenanceBackupValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonMaintenanceBackupValue{}

type ClusterTemplatesConfigsCommonMaintenanceBackupValue struct {
	Differential basetypes.ObjectValue `tfsdk:"differential"`
	Full         basetypes.ObjectValue `tfsdk:"full"`
	Incremental  basetypes.ObjectValue `tfsdk:"incremental"`
	state        attr.ValueState
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["differential"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["full"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["incremental"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Differential.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["differential"] = val

		val, err = v.Full.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full"] = val

		val, err = v.Incremental.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incremental"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupValue"
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var differential basetypes.ObjectValue

	if v.Differential.IsNull() {
		differential = types.ObjectNull(
			ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if v.Differential.IsUnknown() {
		differential = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Differential.IsNull() && !v.Differential.IsUnknown() {
		differential = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
			v.Differential.Attributes(),
		)
	}

	var full basetypes.ObjectValue

	if v.Full.IsNull() {
		full = types.ObjectNull(
			ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if v.Full.IsUnknown() {
		full = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Full.IsNull() && !v.Full.IsUnknown() {
		full = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
			v.Full.Attributes(),
		)
	}

	var incremental basetypes.ObjectValue

	if v.Incremental.IsNull() {
		incremental = types.ObjectNull(
			ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Incremental.IsUnknown() {
		incremental = types.ObjectUnknown(
			ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Incremental.IsNull() && !v.Incremental.IsUnknown() {
		incremental = types.ObjectValueMust(
			ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
			v.Incremental.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"differential": differential,
			"full":         full,
			"incremental":  incremental,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Differential.Equal(other.Differential) {
		return false
	}

	if !v.Full.Equal(other.Full) {
		return false
	}

	if !v.Incremental.Equal(other.Incremental) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonMaintenanceBackupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType{}

type ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType"
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return nil, diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return nil, diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return nil, diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueNull() ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown() ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue {
	object, diags := NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValueMust(ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue{}

type ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue struct {
	BackupNamePrefix   basetypes.StringValue `tfsdk:"backup_name_prefix"`
	BackupS3BucketName basetypes.StringValue `tfsdk:"backup_s3_bucket_name"`
	CreationTimeout    basetypes.Int64Value  `tfsdk:"creation_timeout"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount          basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime           basetypes.Int64Value  `tfsdk:"keep_time"`
	Start              basetypes.StringValue `tfsdk:"start"`
	state              attr.ValueState
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["backup_name_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backup_s3_bucket_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["creation_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BackupNamePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_name_prefix"] = val

		val, err = v.BackupS3BucketName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_s3_bucket_name"] = val

		val, err = v.CreationTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["creation_timeout"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue"
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_name_prefix":    v.BackupNamePrefix,
			"backup_s3_bucket_name": v.BackupS3BucketName,
			"creation_timeout":      v.CreationTimeout,
			"enabled":               v.Enabled,
			"keep_count":            v.KeepCount,
			"keep_time":             v.KeepTime,
			"start":                 v.Start,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupNamePrefix.Equal(other.BackupNamePrefix) {
		return false
	}

	if !v.BackupS3BucketName.Equal(other.BackupS3BucketName) {
		return false
	}

	if !v.CreationTimeout.Equal(other.CreationTimeout) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupDifferentialValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonMaintenanceBackupFullType{}

type ClusterTemplatesConfigsCommonMaintenanceBackupFullType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupFullType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupFullType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupFullType) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupFullType"
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupFullType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return nil, diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return nil, diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return nil, diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueNull() ClusterTemplatesConfigsCommonMaintenanceBackupFullValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown() ClusterTemplatesConfigsCommonMaintenanceBackupFullValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupFullValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonMaintenanceBackupFullValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupFullValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupFullValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupFullValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupFullValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupFullValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupFullValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonMaintenanceBackupFullValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonMaintenanceBackupFullValue {
	object, diags := NewClusterTemplatesConfigsCommonMaintenanceBackupFullValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupFullType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonMaintenanceBackupFullValueMust(ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupFullType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonMaintenanceBackupFullValue{}

type ClusterTemplatesConfigsCommonMaintenanceBackupFullValue struct {
	BackupNamePrefix   basetypes.StringValue `tfsdk:"backup_name_prefix"`
	BackupS3BucketName basetypes.StringValue `tfsdk:"backup_s3_bucket_name"`
	CreationTimeout    basetypes.Int64Value  `tfsdk:"creation_timeout"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount          basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime           basetypes.Int64Value  `tfsdk:"keep_time"`
	Start              basetypes.StringValue `tfsdk:"start"`
	state              attr.ValueState
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["backup_name_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backup_s3_bucket_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["creation_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BackupNamePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_name_prefix"] = val

		val, err = v.BackupS3BucketName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_s3_bucket_name"] = val

		val, err = v.CreationTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["creation_timeout"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupFullValue"
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_name_prefix":    v.BackupNamePrefix,
			"backup_s3_bucket_name": v.BackupS3BucketName,
			"creation_timeout":      v.CreationTimeout,
			"enabled":               v.Enabled,
			"keep_count":            v.KeepCount,
			"keep_time":             v.KeepTime,
			"start":                 v.Start,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupFullValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupNamePrefix.Equal(other.BackupNamePrefix) {
		return false
	}

	if !v.BackupS3BucketName.Equal(other.BackupS3BucketName) {
		return false
	}

	if !v.CreationTimeout.Equal(other.CreationTimeout) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonMaintenanceBackupFullType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupFullValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType{}

type ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType"
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return nil, diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return nil, diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return nil, diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueNull() ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown() ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue {
	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Type",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	backupNamePrefixAttribute, ok := attributes["backup_name_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_name_prefix is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	backupNamePrefixVal, ok := backupNamePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_name_prefix expected to be basetypes.StringValue, was: %T`, backupNamePrefixAttribute))
	}

	backupS3BucketNameAttribute, ok := attributes["backup_s3_bucket_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_s3_bucket_name is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	backupS3BucketNameVal, ok := backupS3BucketNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_s3_bucket_name expected to be basetypes.StringValue, was: %T`, backupS3BucketNameAttribute))
	}

	creationTimeoutAttribute, ok := attributes["creation_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`creation_timeout is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	creationTimeoutVal, ok := creationTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`creation_timeout expected to be basetypes.Int64Value, was: %T`, creationTimeoutAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), diags
	}

	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{
		BackupNamePrefix:   backupNamePrefixVal,
		BackupS3BucketName: backupS3BucketNameVal,
		CreationTimeout:    creationTimeoutVal,
		Enabled:            enabledVal,
		KeepCount:          keepCountVal,
		KeepTime:           keepTimeVal,
		Start:              startVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue {
	object, diags := NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValueMust(ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue{}

type ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue struct {
	BackupNamePrefix   basetypes.StringValue `tfsdk:"backup_name_prefix"`
	BackupS3BucketName basetypes.StringValue `tfsdk:"backup_s3_bucket_name"`
	CreationTimeout    basetypes.Int64Value  `tfsdk:"creation_timeout"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount          basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime           basetypes.Int64Value  `tfsdk:"keep_time"`
	Start              basetypes.StringValue `tfsdk:"start"`
	state              attr.ValueState
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["backup_name_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backup_s3_bucket_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["creation_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BackupNamePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_name_prefix"] = val

		val, err = v.BackupS3BucketName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_s3_bucket_name"] = val

		val, err = v.CreationTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["creation_timeout"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) String() string {
	return "ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue"
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_name_prefix":    v.BackupNamePrefix,
			"backup_s3_bucket_name": v.BackupS3BucketName,
			"creation_timeout":      v.CreationTimeout,
			"enabled":               v.Enabled,
			"keep_count":            v.KeepCount,
			"keep_time":             v.KeepTime,
			"start":                 v.Start,
		})

	return objVal, diags
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupNamePrefix.Equal(other.BackupNamePrefix) {
		return false
	}

	if !v.BackupS3BucketName.Equal(other.BackupS3BucketName) {
		return false
	}

	if !v.CreationTimeout.Equal(other.CreationTimeout) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesConfigsCommonMaintenanceBackupIncrementalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_name_prefix":    basetypes.StringType{},
		"backup_s3_bucket_name": basetypes.StringType{},
		"creation_timeout":      basetypes.Int64Type{},
		"enabled":               basetypes.BoolType{},
		"keep_count":            basetypes.Int64Type{},
		"keep_time":             basetypes.Int64Type{},
		"start":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPodGroupsType{}

type ClusterTemplatesPodGroupsType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPodGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPodGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPodGroupsType) String() string {
	return "ClusterTemplatesPodGroupsType"
}

func (t ClusterTemplatesPodGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	backrefAttribute, ok := attributes["backref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backref is missing from object`)

		return nil, diags
	}

	backrefVal, ok := backrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backref expected to be basetypes.StringValue, was: %T`, backrefAttribute))
	}

	clusterTemplateIdAttribute, ok := attributes["cluster_template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_template_id is missing from object`)

		return nil, diags
	}

	clusterTemplateIdVal, ok := clusterTemplateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_template_id expected to be basetypes.StringValue, was: %T`, clusterTemplateIdAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProcessesAttribute, ok := attributes["node_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_processes is missing from object`)

		return nil, diags
	}

	nodeProcessesVal, ok := nodeProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_processes expected to be basetypes.ListValue, was: %T`, nodeProcessesAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	templateTypeAttribute, ok := attributes["template_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_type is missing from object`)

		return nil, diags
	}

	templateTypeVal, ok := templateTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_type expected to be basetypes.StringValue, was: %T`, templateTypeAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPodGroupsValue{
		Alias:             aliasVal,
		Backref:           backrefVal,
		ClusterTemplateId: clusterTemplateIdVal,
		Count:             countVal,
		CreatedAt:         createdAtVal,
		Description:       descriptionVal,
		Id:                idVal,
		Name:              nameVal,
		NodeProcesses:     nodeProcessesVal,
		Resource:          resourceVal,
		TemplateType:      templateTypeVal,
		Volumes:           volumesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsValueNull() ClusterTemplatesPodGroupsValue {
	return ClusterTemplatesPodGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPodGroupsValueUnknown() ClusterTemplatesPodGroupsValue {
	return ClusterTemplatesPodGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPodGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPodGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPodGroupsValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPodGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPodGroupsValue Attribute Type",
				"While creating a ClusterTemplatesPodGroupsValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPodGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPodGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPodGroupsValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPodGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPodGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	backrefAttribute, ok := attributes["backref"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backref is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	backrefVal, ok := backrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backref expected to be basetypes.StringValue, was: %T`, backrefAttribute))
	}

	clusterTemplateIdAttribute, ok := attributes["cluster_template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_template_id is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	clusterTemplateIdVal, ok := clusterTemplateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_template_id expected to be basetypes.StringValue, was: %T`, clusterTemplateIdAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProcessesAttribute, ok := attributes["node_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_processes is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	nodeProcessesVal, ok := nodeProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_processes expected to be basetypes.ListValue, was: %T`, nodeProcessesAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	templateTypeAttribute, ok := attributes["template_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_type is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	templateTypeVal, ok := templateTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_type expected to be basetypes.StringValue, was: %T`, templateTypeAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsValueUnknown(), diags
	}

	return ClusterTemplatesPodGroupsValue{
		Alias:             aliasVal,
		Backref:           backrefVal,
		ClusterTemplateId: clusterTemplateIdVal,
		Count:             countVal,
		CreatedAt:         createdAtVal,
		Description:       descriptionVal,
		Id:                idVal,
		Name:              nameVal,
		NodeProcesses:     nodeProcessesVal,
		Resource:          resourceVal,
		TemplateType:      templateTypeVal,
		Volumes:           volumesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPodGroupsValue {
	object, diags := NewClusterTemplatesPodGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPodGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPodGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPodGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPodGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPodGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPodGroupsValueMust(ClusterTemplatesPodGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPodGroupsType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPodGroupsValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPodGroupsValue{}

type ClusterTemplatesPodGroupsValue struct {
	Alias             basetypes.StringValue `tfsdk:"alias"`
	Backref           basetypes.StringValue `tfsdk:"backref"`
	ClusterTemplateId basetypes.StringValue `tfsdk:"cluster_template_id"`
	Count             basetypes.Int64Value  `tfsdk:"count"`
	CreatedAt         basetypes.StringValue `tfsdk:"created_at"`
	Description       basetypes.StringValue `tfsdk:"description"`
	Id                basetypes.StringValue `tfsdk:"id"`
	Name              basetypes.StringValue `tfsdk:"name"`
	NodeProcesses     basetypes.ListValue   `tfsdk:"node_processes"`
	Resource          basetypes.ObjectValue `tfsdk:"resource"`
	TemplateType      basetypes.StringValue `tfsdk:"template_type"`
	Volumes           basetypes.MapValue    `tfsdk:"volumes"`
	state             attr.ValueState
}

func (v ClusterTemplatesPodGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backref"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cluster_template_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["template_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.MapType{
		ElemType: ClusterTemplatesPodGroupsVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Backref.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backref"] = val

		val, err = v.ClusterTemplateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_template_id"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_processes"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.TemplateType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template_type"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPodGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPodGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPodGroupsValue) String() string {
	return "ClusterTemplatesPodGroupsValue"
}

func (v ClusterTemplatesPodGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	volumes := types.MapValueMust(
		ClusterTemplatesPodGroupsVolumesType{
			basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPodGroupsVolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.MapNull(
			ClusterTemplatesPodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.MapUnknown(
			ClusterTemplatesPodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeProcessesVal basetypes.ListValue
	switch {
	case v.NodeProcesses.IsUnknown():
		nodeProcessesVal = types.ListUnknown(types.StringType)
	case v.NodeProcesses.IsNull():
		nodeProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeProcessesVal, d = types.ListValue(types.StringType, v.NodeProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"alias":               basetypes.StringType{},
			"backref":             basetypes.StringType{},
			"cluster_template_id": basetypes.StringType{},
			"count":               basetypes.Int64Type{},
			"created_at":          basetypes.StringType{},
			"description":         basetypes.StringType{},
			"id":                  basetypes.StringType{},
			"name":                basetypes.StringType{},
			"node_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"resource": basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
			},
			"template_type": basetypes.StringType{},
			"volumes": basetypes.MapType{
				ElemType: ClusterTemplatesPodGroupsVolumesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"alias":               basetypes.StringType{},
		"backref":             basetypes.StringType{},
		"cluster_template_id": basetypes.StringType{},
		"count":               basetypes.Int64Type{},
		"created_at":          basetypes.StringType{},
		"description":         basetypes.StringType{},
		"id":                  basetypes.StringType{},
		"name":                basetypes.StringType{},
		"node_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"resource": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"template_type": basetypes.StringType{},
		"volumes": basetypes.MapType{
			ElemType: ClusterTemplatesPodGroupsVolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias":               v.Alias,
			"backref":             v.Backref,
			"cluster_template_id": v.ClusterTemplateId,
			"count":               v.Count,
			"created_at":          v.CreatedAt,
			"description":         v.Description,
			"id":                  v.Id,
			"name":                v.Name,
			"node_processes":      nodeProcessesVal,
			"resource":            resource,
			"template_type":       v.TemplateType,
			"volumes":             volumes,
		})

	return objVal, diags
}

func (v ClusterTemplatesPodGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPodGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Backref.Equal(other.Backref) {
		return false
	}

	if !v.ClusterTemplateId.Equal(other.ClusterTemplateId) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeProcesses.Equal(other.NodeProcesses) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.TemplateType.Equal(other.TemplateType) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v ClusterTemplatesPodGroupsValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPodGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPodGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":               basetypes.StringType{},
		"backref":             basetypes.StringType{},
		"cluster_template_id": basetypes.StringType{},
		"count":               basetypes.Int64Type{},
		"created_at":          basetypes.StringType{},
		"description":         basetypes.StringType{},
		"id":                  basetypes.StringType{},
		"name":                basetypes.StringType{},
		"node_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"resource": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"template_type": basetypes.StringType{},
		"volumes": basetypes.MapType{
			ElemType: ClusterTemplatesPodGroupsVolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPodGroupsResourceType{}

type ClusterTemplatesPodGroupsResourceType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPodGroupsResourceType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPodGroupsResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPodGroupsResourceType) String() string {
	return "ClusterTemplatesPodGroupsResourceType"
}

func (t ClusterTemplatesPodGroupsResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuMarginAttribute, ok := attributes["cpu_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_margin is missing from object`)

		return nil, diags
	}

	cpuMarginVal, ok := cpuMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_margin expected to be basetypes.NumberValue, was: %T`, cpuMarginAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return nil, diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramMarginAttribute, ok := attributes["ram_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_margin is missing from object`)

		return nil, diags
	}

	ramMarginVal, ok := ramMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_margin expected to be basetypes.NumberValue, was: %T`, ramMarginAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return nil, diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPodGroupsResourceValue{
		CpuMargin:  cpuMarginVal,
		CpuRequest: cpuRequestVal,
		RamMargin:  ramMarginVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsResourceValueNull() ClusterTemplatesPodGroupsResourceValue {
	return ClusterTemplatesPodGroupsResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPodGroupsResourceValueUnknown() ClusterTemplatesPodGroupsResourceValue {
	return ClusterTemplatesPodGroupsResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPodGroupsResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPodGroupsResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPodGroupsResourceValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsResourceValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPodGroupsResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPodGroupsResourceValue Attribute Type",
				"While creating a ClusterTemplatesPodGroupsResourceValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPodGroupsResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPodGroupsResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPodGroupsResourceValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsResourceValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPodGroupsResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPodGroupsResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	cpuMarginAttribute, ok := attributes["cpu_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_margin is missing from object`)

		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	cpuMarginVal, ok := cpuMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_margin expected to be basetypes.NumberValue, was: %T`, cpuMarginAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramMarginAttribute, ok := attributes["ram_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_margin is missing from object`)

		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	ramMarginVal, ok := ramMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_margin expected to be basetypes.NumberValue, was: %T`, ramMarginAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsResourceValueUnknown(), diags
	}

	return ClusterTemplatesPodGroupsResourceValue{
		CpuMargin:  cpuMarginVal,
		CpuRequest: cpuRequestVal,
		RamMargin:  ramMarginVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPodGroupsResourceValue {
	object, diags := NewClusterTemplatesPodGroupsResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPodGroupsResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPodGroupsResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPodGroupsResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPodGroupsResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPodGroupsResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPodGroupsResourceValueMust(ClusterTemplatesPodGroupsResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPodGroupsResourceType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPodGroupsResourceValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPodGroupsResourceValue{}

type ClusterTemplatesPodGroupsResourceValue struct {
	CpuMargin  basetypes.NumberValue `tfsdk:"cpu_margin"`
	CpuRequest basetypes.StringValue `tfsdk:"cpu_request"`
	RamMargin  basetypes.NumberValue `tfsdk:"ram_margin"`
	RamRequest basetypes.StringValue `tfsdk:"ram_request"`
	state      attr.ValueState
}

func (v ClusterTemplatesPodGroupsResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_margin"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["cpu_request"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_margin"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["ram_request"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuMargin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_margin"] = val

		val, err = v.CpuRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_request"] = val

		val, err = v.RamMargin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_margin"] = val

		val, err = v.RamRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_request"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPodGroupsResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPodGroupsResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPodGroupsResourceValue) String() string {
	return "ClusterTemplatesPodGroupsResourceValue"
}

func (v ClusterTemplatesPodGroupsResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_margin":  basetypes.NumberType{},
		"cpu_request": basetypes.StringType{},
		"ram_margin":  basetypes.NumberType{},
		"ram_request": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_margin":  v.CpuMargin,
			"cpu_request": v.CpuRequest,
			"ram_margin":  v.RamMargin,
			"ram_request": v.RamRequest,
		})

	return objVal, diags
}

func (v ClusterTemplatesPodGroupsResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPodGroupsResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuMargin.Equal(other.CpuMargin) {
		return false
	}

	if !v.CpuRequest.Equal(other.CpuRequest) {
		return false
	}

	if !v.RamMargin.Equal(other.RamMargin) {
		return false
	}

	if !v.RamRequest.Equal(other.RamRequest) {
		return false
	}

	return true
}

func (v ClusterTemplatesPodGroupsResourceValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPodGroupsResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPodGroupsResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_margin":  basetypes.NumberType{},
		"cpu_request": basetypes.StringType{},
		"ram_margin":  basetypes.NumberType{},
		"ram_request": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPodGroupsVolumesType{}

type ClusterTemplatesPodGroupsVolumesType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPodGroupsVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPodGroupsVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPodGroupsVolumesType) String() string {
	return "ClusterTemplatesPodGroupsVolumesType"
}

func (t ClusterTemplatesPodGroupsVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return nil, diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsVolumesValueNull() ClusterTemplatesPodGroupsVolumesValue {
	return ClusterTemplatesPodGroupsVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPodGroupsVolumesValueUnknown() ClusterTemplatesPodGroupsVolumesValue {
	return ClusterTemplatesPodGroupsVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPodGroupsVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPodGroupsVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPodGroupsVolumesValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsVolumesValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPodGroupsVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPodGroupsVolumesValue Attribute Type",
				"While creating a ClusterTemplatesPodGroupsVolumesValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPodGroupsVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPodGroupsVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPodGroupsVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPodGroupsVolumesValue Attribute Value",
				"While creating a ClusterTemplatesPodGroupsVolumesValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPodGroupsVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPodGroupsVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), diags
	}

	return ClusterTemplatesPodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPodGroupsVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPodGroupsVolumesValue {
	object, diags := NewClusterTemplatesPodGroupsVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPodGroupsVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPodGroupsVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPodGroupsVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPodGroupsVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPodGroupsVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPodGroupsVolumesValueMust(ClusterTemplatesPodGroupsVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPodGroupsVolumesType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPodGroupsVolumesValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPodGroupsVolumesValue{}

type ClusterTemplatesPodGroupsVolumesValue struct {
	Count            basetypes.Int64Value  `tfsdk:"count"`
	Storage          basetypes.StringValue `tfsdk:"storage"`
	StorageClassName basetypes.StringValue `tfsdk:"storage_class_name"`
	state            attr.ValueState
}

func (v ClusterTemplatesPodGroupsVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		val, err = v.StorageClassName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPodGroupsVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPodGroupsVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPodGroupsVolumesValue) String() string {
	return "ClusterTemplatesPodGroupsVolumesValue"
}

func (v ClusterTemplatesPodGroupsVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":              v.Count,
			"storage":            v.Storage,
			"storage_class_name": v.StorageClassName,
		})

	return objVal, diags
}

func (v ClusterTemplatesPodGroupsVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPodGroupsVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	if !v.StorageClassName.Equal(other.StorageClassName) {
		return false
	}

	return true
}

func (v ClusterTemplatesPodGroupsVolumesValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPodGroupsVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPodGroupsVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsType{}

type ClusterTemplatesPresetsType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsType) String() string {
	return "ClusterTemplatesPresetsType"
}

func (t ClusterTemplatesPresetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podGroupsAttribute, ok := attributes["pod_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_groups is missing from object`)

		return nil, diags
	}

	podGroupsVal, ok := podGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_groups expected to be basetypes.ListValue, was: %T`, podGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsValue{
		Name:      nameVal,
		PodGroups: podGroupsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsValueNull() ClusterTemplatesPresetsValue {
	return ClusterTemplatesPresetsValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsValueUnknown() ClusterTemplatesPresetsValue {
	return ClusterTemplatesPresetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsValue Attribute Value",
				"While creating a ClusterTemplatesPresetsValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsValue Attribute Type",
				"While creating a ClusterTemplatesPresetsValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsValue Attribute Value",
				"While creating a ClusterTemplatesPresetsValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewClusterTemplatesPresetsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	podGroupsAttribute, ok := attributes["pod_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_groups is missing from object`)

		return NewClusterTemplatesPresetsValueUnknown(), diags
	}

	podGroupsVal, ok := podGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_groups expected to be basetypes.ListValue, was: %T`, podGroupsAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsValueUnknown(), diags
	}

	return ClusterTemplatesPresetsValue{
		Name:      nameVal,
		PodGroups: podGroupsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsValue {
	object, diags := NewClusterTemplatesPresetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsValueMust(ClusterTemplatesPresetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsValue{}

type ClusterTemplatesPresetsValue struct {
	Name      basetypes.StringValue `tfsdk:"name"`
	PodGroups basetypes.ListValue   `tfsdk:"pod_groups"`
	state     attr.ValueState
}

func (v ClusterTemplatesPresetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_groups"] = basetypes.ListType{
		ElemType: ClusterTemplatesPresetsPodGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PodGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsValue) String() string {
	return "ClusterTemplatesPresetsValue"
}

func (v ClusterTemplatesPresetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	podGroups := types.ListValueMust(
		ClusterTemplatesPresetsPodGroupsType{
			basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPresetsPodGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.PodGroups.Elements(),
	)

	if v.PodGroups.IsNull() {
		podGroups = types.ListNull(
			ClusterTemplatesPresetsPodGroupsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsPodGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PodGroups.IsUnknown() {
		podGroups = types.ListUnknown(
			ClusterTemplatesPresetsPodGroupsType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsPodGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"pod_groups": basetypes.ListType{
			ElemType: ClusterTemplatesPresetsPodGroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":       v.Name,
			"pod_groups": podGroups,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PodGroups.Equal(other.PodGroups) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"pod_groups": basetypes.ListType{
			ElemType: ClusterTemplatesPresetsPodGroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsType{}

type ClusterTemplatesPresetsPodGroupsType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsType) String() string {
	return "ClusterTemplatesPresetsPodGroupsType"
}

func (t ClusterTemplatesPresetsPodGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return nil, diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsValue{
		Count:    countVal,
		Meta:     metaVal,
		Name:     nameVal,
		Resource: resourceVal,
		Volumes:  volumesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsValueNull() ClusterTemplatesPresetsPodGroupsValue {
	return ClusterTemplatesPresetsPodGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsValueUnknown() ClusterTemplatesPresetsPodGroupsValue {
	return ClusterTemplatesPresetsPodGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	metaAttribute, ok := attributes["meta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`meta is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	metaVal, ok := metaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`meta expected to be basetypes.ObjectValue, was: %T`, metaAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsValue{
		Count:    countVal,
		Meta:     metaVal,
		Name:     nameVal,
		Resource: resourceVal,
		Volumes:  volumesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsValueMust(ClusterTemplatesPresetsPodGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsValue{}

type ClusterTemplatesPresetsPodGroupsValue struct {
	Count    basetypes.Int64Value  `tfsdk:"count"`
	Meta     basetypes.ObjectValue `tfsdk:"meta"`
	Name     basetypes.StringValue `tfsdk:"name"`
	Resource basetypes.ObjectValue `tfsdk:"resource"`
	Volumes  basetypes.MapValue    `tfsdk:"volumes"`
	state    attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["meta"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.MapType{
		ElemType: ClusterTemplatesPresetsPodGroupsVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Meta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["meta"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsValue"
}

func (v ClusterTemplatesPresetsPodGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var meta basetypes.ObjectValue

	if v.Meta.IsNull() {
		meta = types.ObjectNull(
			ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
		)
	}

	if v.Meta.IsUnknown() {
		meta = types.ObjectUnknown(
			ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Meta.IsNull() && !v.Meta.IsUnknown() {
		meta = types.ObjectValueMust(
			ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
			v.Meta.Attributes(),
		)
	}

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	volumes := types.MapValueMust(
		ClusterTemplatesPresetsPodGroupsVolumesType{
			basetypes.ObjectType{
				AttrTypes: ClusterTemplatesPresetsPodGroupsVolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.MapNull(
			ClusterTemplatesPresetsPodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsPodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.MapUnknown(
			ClusterTemplatesPresetsPodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: ClusterTemplatesPresetsPodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"meta": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: ClusterTemplatesPresetsPodGroupsVolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":    v.Count,
			"meta":     meta,
			"name":     v.Name,
			"resource": resource,
			"volumes":  volumes,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Meta.Equal(other.Meta) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"meta": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: ClusterTemplatesPresetsPodGroupsVolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsMetaType{}

type ClusterTemplatesPresetsPodGroupsMetaType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsMetaType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsMetaType) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaType"
}

func (t ClusterTemplatesPresetsPodGroupsMetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return nil, diags
	}

	createVal, ok := createAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.ObjectValue, was: %T`, createAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaValue{
		Create: createVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaValueNull() ClusterTemplatesPresetsPodGroupsMetaValue {
	return ClusterTemplatesPresetsPodGroupsMetaValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaValueUnknown() ClusterTemplatesPresetsPodGroupsMetaValue {
	return ClusterTemplatesPresetsPodGroupsMetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsMetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsMetaValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsMetaValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsMetaValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsMetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaValueUnknown(), diags
	}

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaValueUnknown(), diags
	}

	createVal, ok := createAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.ObjectValue, was: %T`, createAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaValue{
		Create: createVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsMetaValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsMetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsMetaValueMust(ClusterTemplatesPresetsPodGroupsMetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsMetaType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsMetaValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsMetaValue{}

type ClusterTemplatesPresetsPodGroupsMetaValue struct {
	Create basetypes.ObjectValue `tfsdk:"create"`
	state  attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["create"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Create.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaValue"
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var create basetypes.ObjectValue

	if v.Create.IsNull() {
		create = types.ObjectNull(
			ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Create.IsUnknown() {
		create = types.ObjectUnknown(
			ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Create.IsNull() && !v.Create.IsUnknown() {
		create = types.ObjectValueMust(
			ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
			v.Create.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"create": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create": create,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Create.Equal(other.Create) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsMetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsMetaCreateType{}

type ClusterTemplatesPresetsPodGroupsMetaCreateType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreateType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreateType) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreateType"
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	propertyAttribute, ok := attributes["property"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`property is missing from object`)

		return nil, diags
	}

	propertyVal, ok := propertyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`property expected to be basetypes.ObjectValue, was: %T`, propertyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreateValue{
		Property: propertyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreateValueNull() ClusterTemplatesPresetsPodGroupsMetaCreateValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreateValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreateValueUnknown() ClusterTemplatesPresetsPodGroupsMetaCreateValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsMetaCreateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreateValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreateValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreateValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsMetaCreateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueUnknown(), diags
	}

	propertyAttribute, ok := attributes["property"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`property is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueUnknown(), diags
	}

	propertyVal, ok := propertyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`property expected to be basetypes.ObjectValue, was: %T`, propertyAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreateValue{
		Property: propertyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsMetaCreateValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsMetaCreateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsMetaCreateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsMetaCreateValueMust(ClusterTemplatesPresetsPodGroupsMetaCreateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreateType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsMetaCreateValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsMetaCreateValue{}

type ClusterTemplatesPresetsPodGroupsMetaCreateValue struct {
	Property basetypes.ObjectValue `tfsdk:"property"`
	state    attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["property"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Property.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["property"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreateValue"
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var property basetypes.ObjectValue

	if v.Property.IsNull() {
		property = types.ObjectNull(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
		)
	}

	if v.Property.IsUnknown() {
		property = types.ObjectUnknown(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Property.IsNull() && !v.Property.IsUnknown() {
		property = types.ObjectValueMust(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
			v.Property.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"property": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"property": property,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Property.Equal(other.Property) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsMetaCreateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"property": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType{}

type ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType"
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	multiplicatorAttribute, ok := attributes["multiplicator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multiplicator is missing from object`)

		return nil, diags
	}

	multiplicatorVal, ok := multiplicatorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multiplicator expected to be basetypes.ObjectValue, was: %T`, multiplicatorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{
		Multiplicator: multiplicatorVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueNull() ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueUnknown() ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueUnknown(), diags
	}

	multiplicatorAttribute, ok := attributes["multiplicator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multiplicator is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueUnknown(), diags
	}

	multiplicatorVal, ok := multiplicatorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multiplicator expected to be basetypes.ObjectValue, was: %T`, multiplicatorAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{
		Multiplicator: multiplicatorVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyValueMust(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue{}

type ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue struct {
	Multiplicator basetypes.ObjectValue `tfsdk:"multiplicator"`
	state         attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["multiplicator"] = basetypes.ObjectType{
		AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Multiplicator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multiplicator"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue"
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var multiplicator basetypes.ObjectValue

	if v.Multiplicator.IsNull() {
		multiplicator = types.ObjectNull(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
		)
	}

	if v.Multiplicator.IsUnknown() {
		multiplicator = types.ObjectUnknown(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Multiplicator.IsNull() && !v.Multiplicator.IsUnknown() {
		multiplicator = types.ObjectValueMust(
			ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
			v.Multiplicator.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"multiplicator": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"multiplicator": multiplicator,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Multiplicator.Equal(other.Multiplicator) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"multiplicator": basetypes.ObjectType{
			AttrTypes: ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType{}

type ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType"
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return nil, diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	allowAddAttribute, ok := attributes["allow_add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_add is missing from object`)

		return nil, diags
	}

	allowAddVal, ok := allowAddAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_add expected to be basetypes.BoolValue, was: %T`, allowAddAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	isReadOnlyAttribute, ok := attributes["is_read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_read_only is missing from object`)

		return nil, diags
	}

	isReadOnlyVal, ok := isReadOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_read_only expected to be basetypes.BoolValue, was: %T`, isReadOnlyAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{
		Allow:      allowVal,
		AllowAdd:   allowAddVal,
		Count:      countVal,
		IsReadOnly: isReadOnlyVal,
		Max:        maxVal,
		Min:        minVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueNull() ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown() ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	allowAttribute, ok := attributes["allow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	allowVal, ok := allowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow expected to be basetypes.BoolValue, was: %T`, allowAttribute))
	}

	allowAddAttribute, ok := attributes["allow_add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_add is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	allowAddVal, ok := allowAddAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_add expected to be basetypes.BoolValue, was: %T`, allowAddAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	isReadOnlyAttribute, ok := attributes["is_read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_read_only is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	isReadOnlyVal, ok := isReadOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_read_only expected to be basetypes.BoolValue, was: %T`, isReadOnlyAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{
		Allow:      allowVal,
		AllowAdd:   allowAddVal,
		Count:      countVal,
		IsReadOnly: isReadOnlyVal,
		Max:        maxVal,
		Min:        minVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValueMust(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue{}

type ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue struct {
	Allow      basetypes.BoolValue  `tfsdk:"allow"`
	AllowAdd   basetypes.BoolValue  `tfsdk:"allow_add"`
	Count      basetypes.Int64Value `tfsdk:"count"`
	IsReadOnly basetypes.BoolValue  `tfsdk:"is_read_only"`
	Max        basetypes.Int64Value `tfsdk:"max"`
	Min        basetypes.Int64Value `tfsdk:"min"`
	state      attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["allow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_add"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Allow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow"] = val

		val, err = v.AllowAdd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_add"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.IsReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_read_only"] = val

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue"
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow":        basetypes.BoolType{},
		"allow_add":    basetypes.BoolType{},
		"count":        basetypes.Int64Type{},
		"is_read_only": basetypes.BoolType{},
		"max":          basetypes.Int64Type{},
		"min":          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow":        v.Allow,
			"allow_add":    v.AllowAdd,
			"count":        v.Count,
			"is_read_only": v.IsReadOnly,
			"max":          v.Max,
			"min":          v.Min,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Allow.Equal(other.Allow) {
		return false
	}

	if !v.AllowAdd.Equal(other.AllowAdd) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.IsReadOnly.Equal(other.IsReadOnly) {
		return false
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsMetaCreatePropertyMultiplicatorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow":        basetypes.BoolType{},
		"allow_add":    basetypes.BoolType{},
		"count":        basetypes.Int64Type{},
		"is_read_only": basetypes.BoolType{},
		"max":          basetypes.Int64Type{},
		"min":          basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsResourceType{}

type ClusterTemplatesPresetsPodGroupsResourceType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsResourceType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsResourceType) String() string {
	return "ClusterTemplatesPresetsPodGroupsResourceType"
}

func (t ClusterTemplatesPresetsPodGroupsResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return nil, diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return nil, diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsResourceValue{
		CpuRequest: cpuRequestVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsResourceValueNull() ClusterTemplatesPresetsPodGroupsResourceValue {
	return ClusterTemplatesPresetsPodGroupsResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsResourceValueUnknown() ClusterTemplatesPresetsPodGroupsResourceValue {
	return ClusterTemplatesPresetsPodGroupsResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsResourceValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsResourceValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsResourceValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsResourceValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsResourceValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsResourceValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsResourceValueUnknown(), diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsResourceValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsResourceValue{
		CpuRequest: cpuRequestVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsResourceValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsResourceValueMust(ClusterTemplatesPresetsPodGroupsResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsResourceType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsResourceValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsResourceValue{}

type ClusterTemplatesPresetsPodGroupsResourceValue struct {
	CpuRequest basetypes.StringValue `tfsdk:"cpu_request"`
	RamRequest basetypes.StringValue `tfsdk:"ram_request"`
	state      attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cpu_request"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_request"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CpuRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_request"] = val

		val, err = v.RamRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_request"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsResourceValue"
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_request": basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_request": v.CpuRequest,
			"ram_request": v.RamRequest,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuRequest.Equal(other.CpuRequest) {
		return false
	}

	if !v.RamRequest.Equal(other.RamRequest) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_request": basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterTemplatesPresetsPodGroupsVolumesType{}

type ClusterTemplatesPresetsPodGroupsVolumesType struct {
	basetypes.ObjectType
}

func (t ClusterTemplatesPresetsPodGroupsVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterTemplatesPresetsPodGroupsVolumesType) String() string {
	return "ClusterTemplatesPresetsPodGroupsVolumesType"
}

func (t ClusterTemplatesPresetsPodGroupsVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return nil, diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterTemplatesPresetsPodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsVolumesValueNull() ClusterTemplatesPresetsPodGroupsVolumesValue {
	return ClusterTemplatesPresetsPodGroupsVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown() ClusterTemplatesPresetsPodGroupsVolumesValue {
	return ClusterTemplatesPresetsPodGroupsVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterTemplatesPresetsPodGroupsVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterTemplatesPresetsPodGroupsVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsVolumesValue value, a missing attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Type",
				"While creating a ClusterTemplatesPresetsPodGroupsVolumesValue value, an invalid attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Value",
				"While creating a ClusterTemplatesPresetsPodGroupsVolumesValue value, an extra attribute value was detected. "+
					"A ClusterTemplatesPresetsPodGroupsVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterTemplatesPresetsPodGroupsVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), diags
	}

	return ClusterTemplatesPresetsPodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewClusterTemplatesPresetsPodGroupsVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterTemplatesPresetsPodGroupsVolumesValue {
	object, diags := NewClusterTemplatesPresetsPodGroupsVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterTemplatesPresetsPodGroupsVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterTemplatesPresetsPodGroupsVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterTemplatesPresetsPodGroupsVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterTemplatesPresetsPodGroupsVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterTemplatesPresetsPodGroupsVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterTemplatesPresetsPodGroupsVolumesValueMust(ClusterTemplatesPresetsPodGroupsVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterTemplatesPresetsPodGroupsVolumesType) ValueType(ctx context.Context) attr.Value {
	return ClusterTemplatesPresetsPodGroupsVolumesValue{}
}

var _ basetypes.ObjectValuable = ClusterTemplatesPresetsPodGroupsVolumesValue{}

type ClusterTemplatesPresetsPodGroupsVolumesValue struct {
	Count            basetypes.Int64Value  `tfsdk:"count"`
	Storage          basetypes.StringValue `tfsdk:"storage"`
	StorageClassName basetypes.StringValue `tfsdk:"storage_class_name"`
	state            attr.ValueState
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		val, err = v.StorageClassName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) String() string {
	return "ClusterTemplatesPresetsPodGroupsVolumesValue"
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":              v.Count,
			"storage":            v.Storage,
			"storage_class_name": v.StorageClassName,
		})

	return objVal, diags
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterTemplatesPresetsPodGroupsVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	if !v.StorageClassName.Equal(other.StorageClassName) {
		return false
	}

	return true
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) Type(ctx context.Context) attr.Type {
	return ClusterTemplatesPresetsPodGroupsVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterTemplatesPresetsPodGroupsVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}
}
