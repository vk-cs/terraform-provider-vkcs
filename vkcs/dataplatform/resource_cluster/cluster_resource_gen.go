// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"availability_zone": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Availability zone to create cluster in.",
				MarkdownDescription: "Availability zone to create cluster in.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(255),
				},
			},
			"cluster_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"cluster_template_id": schema.StringAttribute{
				Required:            true,
				Description:         "ID of the cluster template.",
				MarkdownDescription: "ID of the cluster template.",
			},
			"configs": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"features": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"volume_autoresize": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Enables option.",
												MarkdownDescription: "Enables option.",
												Default:             booldefault.StaticBool(false),
											},
											"max_scale_size": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Maximum scale size.",
												MarkdownDescription: "Maximum scale size.",
												Default:             int64default.StaticInt64(2000),
											},
											"scale_step_size": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Scale step size.",
												MarkdownDescription: "Scale step size.",
												Default:             int64default.StaticInt64(50),
											},
											"size_scale_threshold": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Size scale threshold.",
												MarkdownDescription: "Size scale threshold.",
												Default:             int64default.StaticInt64(90),
											},
										},
										CustomType: ConfigsFeaturesVolumeAutoresizeDataType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Data volume options.",
										MarkdownDescription: "Data volume options.",
									},
									"wal": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Enables option.",
												MarkdownDescription: "Enables option.",
												Default:             booldefault.StaticBool(false),
											},
											"max_scale_size": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Maximum scale size.",
												MarkdownDescription: "Maximum scale size.",
												Default:             int64default.StaticInt64(2000),
											},
											"scale_step_size": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Scale step size.",
												MarkdownDescription: "Scale step size.",
												Default:             int64default.StaticInt64(50),
											},
											"size_scale_threshold": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "Size scale threshold.",
												MarkdownDescription: "Size scale threshold.",
												Default:             int64default.StaticInt64(90),
											},
										},
										CustomType: ConfigsFeaturesVolumeAutoresizeWalType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Data volume options.",
										MarkdownDescription: "Data volume options.",
									},
								},
								CustomType: ConfigsFeaturesVolumeAutoresizeType{
									ObjectType: types.ObjectType{
										AttrTypes: ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume autoresize options.",
								MarkdownDescription: "Volume autoresize options.",
							},
						},
						CustomType: ConfigsFeaturesType{
							ObjectType: types.ObjectType{
								AttrTypes: ConfigsFeaturesValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Product features.",
						MarkdownDescription: "Product features.",
					},
					"maintenance": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"backup": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"differential": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether differential backup is enabled.",
												MarkdownDescription: "Whether differential backup is enabled.",
												Default:             booldefault.StaticBool(true),
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Differential backup schedule.",
												MarkdownDescription: "Differential backup schedule.",
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
												},
											},
										},
										CustomType: ConfigsMaintenanceBackupDifferentialType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Differential backup settings.",
										MarkdownDescription: "Differential backup settings.",
									},
									"full": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether full backup is enabled.",
												MarkdownDescription: "Whether full backup is enabled.",
												Default:             booldefault.StaticBool(true),
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Full backup schedule.",
												MarkdownDescription: "Full backup schedule.",
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
												},
											},
										},
										CustomType: ConfigsMaintenanceBackupFullType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Full backup settings.",
										MarkdownDescription: "Full backup settings.",
									},
									"incremental": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether incremental backup is enabled.",
												MarkdownDescription: "Whether incremental backup is enabled.",
												Default:             booldefault.StaticBool(true),
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Incremental backup schedule.",
												MarkdownDescription: "Incremental backup schedule.",
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
												},
											},
										},
										CustomType: ConfigsMaintenanceBackupIncrementalType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Incremental backup settings.",
										MarkdownDescription: "Incremental backup settings.",
									},
								},
								CustomType: ConfigsMaintenanceBackupType{
									ObjectType: types.ObjectType{
										AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Backup settings.",
								MarkdownDescription: "Backup settings.",
							},
							"crontabs": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required:            true,
											Description:         "Cron tab name.",
											MarkdownDescription: "Cron tab name.",
										},
										"required": schema.BoolAttribute{
											Computed:            true,
											Description:         "Whether cron tab is required.",
											MarkdownDescription: "Whether cron tab is required.",
										},
										"settings": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"alias": schema.StringAttribute{
														Required:            true,
														Description:         "Setting alias.",
														MarkdownDescription: "Setting alias.",
													},
													"value": schema.StringAttribute{
														Required:            true,
														Description:         "Setting value.",
														MarkdownDescription: "Setting value.",
													},
												},
												CustomType: ConfigsMaintenanceCrontabsSettingsType{
													ObjectType: types.ObjectType{
														AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Additional cron settings.",
											MarkdownDescription: "Additional cron settings.",
										},
										"start": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Cron tab schedule.",
											MarkdownDescription: "Cron tab schedule.",
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
											},
										},
									},
									CustomType: ConfigsMaintenanceCrontabsType{
										ObjectType: types.ObjectType{
											AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Cron tabs settings.",
								MarkdownDescription: "Cron tabs settings.",
							},
							"start": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Maintenance cron schedule.",
								MarkdownDescription: "Maintenance cron schedule.",
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
								},
							},
						},
						CustomType: ConfigsMaintenanceType{
							ObjectType: types.ObjectType{
								AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
							},
						},
						Required:            true,
						Description:         "Maintenance settings.",
						MarkdownDescription: "Maintenance settings.",
					},
					"settings": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"alias": schema.StringAttribute{
									Required:            true,
									Description:         "Setting alias.",
									MarkdownDescription: "Setting alias.",
								},
								"value": schema.StringAttribute{
									Required:            true,
									Description:         "Setting value.",
									MarkdownDescription: "Setting value.",
								},
							},
							CustomType: ConfigsSettingsType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Additional common settings.",
						MarkdownDescription: "Additional common settings.",
					},
					"users": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"access": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Computed:            true,
											Description:         "Access ID.",
											MarkdownDescription: "Access ID.",
										},
										"settings": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"alias": schema.StringAttribute{
														Required:            true,
														Description:         "Setting alias.",
														MarkdownDescription: "Setting alias.",
														Validators: []validator.String{
															stringvalidator.LengthAtMost(80),
														},
													},
													"value": schema.StringAttribute{
														Required:            true,
														Description:         "Setting value.",
														MarkdownDescription: "Setting value.",
														Validators: []validator.String{
															stringvalidator.LengthAtMost(255),
														},
													},
												},
												CustomType: ConfigsUsersAccessSettingsType{
													ObjectType: types.ObjectType{
														AttrTypes: ConfigsUsersAccessSettingsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Access users settings.",
											MarkdownDescription: "Access users settings.",
										},
									},
									CustomType: ConfigsUsersAccessType{
										ObjectType: types.ObjectType{
											AttrTypes: ConfigsUsersAccessValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Access settings.",
									MarkdownDescription: "Access settings.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "User creation timestamp.",
									MarkdownDescription: "User creation timestamp.",
								},
								"id": schema.StringAttribute{
									Computed:            true,
									Description:         "User ID.",
									MarkdownDescription: "User ID.",
								},
								"password": schema.StringAttribute{
									Required:            true,
									Description:         "Password.",
									MarkdownDescription: "Password.",
									Validators: []validator.String{
										stringvalidator.LengthBetween(16, 50),
										stringvalidator.RegexMatches(regexp.MustCompile("^[^'`:;,.@&<>' ]+$"), ""),
									},
								},
								"role": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "User role.",
									MarkdownDescription: "User role.",
									Validators: []validator.String{
										stringvalidator.LengthAtMost(80),
									},
								},
								"username": schema.StringAttribute{
									Required:            true,
									Description:         "Username.",
									MarkdownDescription: "Username.",
									Validators: []validator.String{
										stringvalidator.LengthAtMost(128),
									},
								},
							},
							CustomType: ConfigsUsersType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Users settings.",
						MarkdownDescription: "Users settings.",
					},
					"warehouses": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"connections": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"created_at": schema.StringAttribute{
												Computed:            true,
												Description:         "Connection creation timestamp.",
												MarkdownDescription: "Connection creation timestamp.",
											},
											"id": schema.StringAttribute{
												Computed:            true,
												Description:         "Connection ID.",
												MarkdownDescription: "Connection ID.",
											},
											"name": schema.StringAttribute{
												Required:            true,
												Description:         "Connection name.",
												MarkdownDescription: "Connection name.",
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"plug": schema.StringAttribute{
												Required:            true,
												Description:         "Connection plug.",
												MarkdownDescription: "Connection plug.",
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"settings": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"alias": schema.StringAttribute{
															Required:            true,
															Description:         "Setting alias.",
															MarkdownDescription: "Setting alias.",
															Validators: []validator.String{
																stringvalidator.LengthAtMost(80),
															},
														},
														"value": schema.StringAttribute{
															Required:            true,
															Description:         "Setting value.",
															MarkdownDescription: "Setting value.",
															Validators: []validator.String{
																stringvalidator.LengthAtMost(255),
															},
														},
													},
													CustomType: ConfigsWarehousesConnectionsSettingsType{
														ObjectType: types.ObjectType{
															AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
														},
													},
												},
												Required:            true,
												Description:         "Additional warehouse settings.",
												MarkdownDescription: "Additional warehouse settings.",
											},
										},
										CustomType: ConfigsWarehousesConnectionsType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse connections.",
									MarkdownDescription: "Warehouse connections.",
								},
								"extensions": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"created_at": schema.StringAttribute{
												Computed:            true,
												Description:         "Extension creation timestamp.",
												MarkdownDescription: "Extension creation timestamp.",
											},
											"id": schema.StringAttribute{
												Computed:            true,
												Description:         "Extension ID",
												MarkdownDescription: "Extension ID",
											},
											"settings": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"alias": schema.StringAttribute{
															Required:            true,
															Description:         "Setting alias.",
															MarkdownDescription: "Setting alias.",
															Validators: []validator.String{
																stringvalidator.LengthAtMost(80),
															},
														},
														"value": schema.StringAttribute{
															Required:            true,
															Description:         "Setting value.",
															MarkdownDescription: "Setting value.",
															Validators: []validator.String{
																stringvalidator.LengthAtMost(255),
															},
														},
													},
													CustomType: ConfigsWarehousesExtensionsSettingsType{
														ObjectType: types.ObjectType{
															AttrTypes: ConfigsWarehousesExtensionsSettingsValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional:            true,
												Computed:            true,
												Description:         "Additional extension settings.",
												MarkdownDescription: "Additional extension settings.",
											},
											"type": schema.StringAttribute{
												Required:            true,
												Description:         "Extension type.",
												MarkdownDescription: "Extension type.",
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"version": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Extension version.",
												MarkdownDescription: "Extension version.",
												Validators: []validator.String{
													stringvalidator.LengthAtMost(36),
												},
											},
										},
										CustomType: ConfigsWarehousesExtensionsType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsWarehousesExtensionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse extensions.",
									MarkdownDescription: "Warehouse extensions.",
								},
								"id": schema.StringAttribute{
									Computed:            true,
									Description:         "Warehouse ID.",
									MarkdownDescription: "Warehouse ID.",
								},
								"name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse name.",
									MarkdownDescription: "Warehouse name.",
									Validators: []validator.String{
										stringvalidator.LengthAtMost(63),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_]+$"), ""),
									},
								},
								"users": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse users.",
									MarkdownDescription: "Warehouse users.",
								},
							},
							CustomType: ConfigsWarehousesType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Warehouses settings.",
						MarkdownDescription: "Warehouses settings.",
					},
				},
				CustomType: ConfigsType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfigsValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Product configuration.",
				MarkdownDescription: "Product configuration.",
			},
			"created_at": schema.StringAttribute{
				Computed:            true,
				Description:         "Cluster creation timestamp.",
				MarkdownDescription: "Cluster creation timestamp.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Cluster description.",
				MarkdownDescription: "Cluster description.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(255),
				},
				Default: stringdefault.StaticString(""),
			},
			"floating_ip_pool": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Floating IP pool ID.",
				MarkdownDescription: "Floating IP pool ID.",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "ID of the cluster.",
				MarkdownDescription: "ID of the cluster.",
			},
			"info": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"services": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"connection_string": schema.StringAttribute{
									Computed:            true,
									Description:         "Service connection string.",
									MarkdownDescription: "Service connection string.",
								},
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "Service description.",
									MarkdownDescription: "Service description.",
									Default:             stringdefault.StaticString(""),
								},
								"exposed": schema.BoolAttribute{
									Computed:            true,
									Description:         "Is service exposed.",
									MarkdownDescription: "Is service exposed.",
									Default:             booldefault.StaticBool(false),
								},
								"type": schema.StringAttribute{
									Computed:            true,
									Description:         "Service type.",
									MarkdownDescription: "Service type.",
								},
							},
							CustomType: InfoServicesType{
								ObjectType: types.ObjectType{
									AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Cluster services info.",
						MarkdownDescription: "Cluster services info.",
					},
				},
				CustomType: InfoType{
					ObjectType: types.ObjectType{
						AttrTypes: InfoValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Cluster info.",
				MarkdownDescription: "Cluster info.",
			},
			"multiaz": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enables multi az support.",
				MarkdownDescription: "Enables multi az support.",
				Default:             booldefault.StaticBool(false),
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the cluster.",
				MarkdownDescription: "Name of the cluster.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 60),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Zа-яА-Я0-9][a-zA-Zа-яА-Я0-9-_]*$"), ""),
				},
			},
			"network_id": schema.StringAttribute{
				Required:            true,
				Description:         "ID of the cluster network.",
				MarkdownDescription: "ID of the cluster network.",
			},
			"pod_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alias": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group alias.",
							MarkdownDescription: "Pod group alias.",
						},
						"availability_zone": schema.StringAttribute{
							Computed: true,
						},
						"count": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Pod count.",
							MarkdownDescription: "Pod count.",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
						},
						"floating_ip_pool": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Floating IP pool ID.",
							MarkdownDescription: "Floating IP pool ID.",
							Validators: []validator.String{
								stringvalidator.LengthAtMost(36),
							},
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group ID.",
							MarkdownDescription: "Pod group ID.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group name.",
							MarkdownDescription: "Pod group name.",
						},
						"node_processes": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Node processes.",
							MarkdownDescription: "Node processes.",
							Validators: []validator.List{
								listvalidator.SizeAtMost(1),
								listvalidator.UniqueValues(),
							},
						},
						"pod_group_template_id": schema.StringAttribute{
							Required:            true,
							Description:         "Pod group template ID.",
							MarkdownDescription: "Pod group template ID.",
						},
						"resource": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"cpu_limit": schema.StringAttribute{
									Computed:            true,
									Description:         "CPU limit.",
									MarkdownDescription: "CPU limit.",
								},
								"cpu_request": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Resource request settings.",
									MarkdownDescription: "Resource request settings.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^\\d*\\.?\\d*$"), ""),
									},
								},
								"ram_limit": schema.StringAttribute{
									Computed:            true,
									Description:         "RAM limit settings.",
									MarkdownDescription: "RAM limit settings.",
								},
								"ram_request": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "RAM request settings.",
									MarkdownDescription: "RAM request settings.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^\\d*\\.?\\d*$"), ""),
									},
								},
							},
							CustomType: PodGroupsResourceType{
								ObjectType: types.ObjectType{
									AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Resource request settings.",
							MarkdownDescription: "Resource request settings.",
						},
						"volumes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"count": schema.Int64Attribute{
										Required:            true,
										Description:         "Volume count.",
										MarkdownDescription: "Volume count.",
									},
									"storage": schema.StringAttribute{
										Required:            true,
										Description:         "Storage size.",
										MarkdownDescription: "Storage size.",
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile("^(\\d+|(\\d+)G)$"), ""),
										},
									},
									"storage_class_name": schema.StringAttribute{
										Required:            true,
										Description:         "Storage class name.",
										MarkdownDescription: "Storage class name.",
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile("(csi-)?(?P<type>(ceph|high-iops|ceph-ssd|ef-nvme))(-(?P<zone>[a-zA-Z0-9]+))?(?P<suffix>-(delete|retain))?"), ""),
										},
									},
								},
								CustomType: PodGroupsVolumesType{
									ObjectType: types.ObjectType{
										AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Volumes settings.",
							MarkdownDescription: "Volumes settings.",
						},
					},
					CustomType: PodGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: PodGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Cluster pod groups.",
				MarkdownDescription: "Cluster pod groups.",
			},
			"product_name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the product.",
				MarkdownDescription: "Name of the product.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(80),
				},
			},
			"product_type": schema.StringAttribute{
				Computed:            true,
				Description:         "Type of the product.",
				MarkdownDescription: "Type of the product.",
			},
			"product_version": schema.StringAttribute{
				Required:            true,
				Description:         "Version of the product.",
				MarkdownDescription: "Version of the product.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(80),
				},
			},
			"project_id": schema.StringAttribute{
				Computed: true,
			},
			"stack_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cluster stack.",
				MarkdownDescription: "ID of the cluster stack.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "Cluster status.",
				MarkdownDescription: "Cluster status.",
			},
			"status_description": schema.StringAttribute{
				Computed:            true,
				Description:         "Cluster status description.",
				MarkdownDescription: "Cluster status description.",
			},
			"subnet_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cluster subnet.",
				MarkdownDescription: "ID of the cluster subnet.",
			},
		},
	}
}

type ClusterModel struct {
	AvailabilityZone  types.String `tfsdk:"availability_zone"`
	ClusterId         types.String `tfsdk:"cluster_id"`
	ClusterTemplateId types.String `tfsdk:"cluster_template_id"`
	Configs           ConfigsValue `tfsdk:"configs"`
	CreatedAt         types.String `tfsdk:"created_at"`
	Description       types.String `tfsdk:"description"`
	FloatingIpPool    types.String `tfsdk:"floating_ip_pool"`
	Id                types.String `tfsdk:"id"`
	Info              InfoValue    `tfsdk:"info"`
	Multiaz           types.Bool   `tfsdk:"multiaz"`
	Name              types.String `tfsdk:"name"`
	NetworkId         types.String `tfsdk:"network_id"`
	PodGroups         types.List   `tfsdk:"pod_groups"`
	ProductName       types.String `tfsdk:"product_name"`
	ProductType       types.String `tfsdk:"product_type"`
	ProductVersion    types.String `tfsdk:"product_version"`
	ProjectId         types.String `tfsdk:"project_id"`
	StackId           types.String `tfsdk:"stack_id"`
	Status            types.String `tfsdk:"status"`
	StatusDescription types.String `tfsdk:"status_description"`
	SubnetId          types.String `tfsdk:"subnet_id"`
}

var _ basetypes.ObjectTypable = ConfigsType{}

type ConfigsType struct {
	basetypes.ObjectType
}

func (t ConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsType) String() string {
	return "ConfigsType"
}

func (t ConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return nil, diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	warehousesAttribute, ok := attributes["warehouses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warehouses is missing from object`)

		return nil, diags
	}

	warehousesVal, ok := warehousesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warehouses expected to be basetypes.ListValue, was: %T`, warehousesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsValue{
		Features:    featuresVal,
		Maintenance: maintenanceVal,
		Settings:    settingsVal,
		Users:       usersVal,
		Warehouses:  warehousesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsValueNull() ConfigsValue {
	return ConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsValueUnknown() ConfigsValue {
	return ConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsValue Attribute Value",
				"While creating a ConfigsValue value, a missing attribute value was detected. "+
					"A ConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsValue Attribute Type",
				"While creating a ConfigsValue value, an invalid attribute value was detected. "+
					"A ConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsValue Attribute Value",
				"While creating a ConfigsValue value, an extra attribute value was detected. "+
					"A ConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsValueUnknown(), diags
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ObjectValue, was: %T`, featuresAttribute))
	}

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	warehousesAttribute, ok := attributes["warehouses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warehouses is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	warehousesVal, ok := warehousesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warehouses expected to be basetypes.ListValue, was: %T`, warehousesAttribute))
	}

	if diags.HasError() {
		return NewConfigsValueUnknown(), diags
	}

	return ConfigsValue{
		Features:    featuresVal,
		Maintenance: maintenanceVal,
		Settings:    settingsVal,
		Users:       usersVal,
		Warehouses:  warehousesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsValue {
	object, diags := NewConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsValueMust(ConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsValue{}
}

var _ basetypes.ObjectValuable = ConfigsValue{}

type ConfigsValue struct {
	Features    basetypes.ObjectValue `tfsdk:"features"`
	Maintenance basetypes.ObjectValue `tfsdk:"maintenance"`
	Settings    basetypes.ListValue   `tfsdk:"settings"`
	Users       basetypes.ListValue   `tfsdk:"users"`
	Warehouses  basetypes.ListValue   `tfsdk:"warehouses"`
	state       attr.ValueState
}

func (v ConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["features"] = basetypes.ObjectType{
		AttrTypes: ConfigsFeaturesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["maintenance"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: ConfigsUsersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["warehouses"] = basetypes.ListType{
		ElemType: ConfigsWarehousesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.Maintenance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		val, err = v.Warehouses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warehouses"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsValue) String() string {
	return "ConfigsValue"
}

func (v ConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var features basetypes.ObjectValue

	if v.Features.IsNull() {
		features = types.ObjectNull(
			ConfigsFeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Features.IsUnknown() {
		features = types.ObjectUnknown(
			ConfigsFeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Features.IsNull() && !v.Features.IsUnknown() {
		features = types.ObjectValueMust(
			ConfigsFeaturesValue{}.AttributeTypes(ctx),
			v.Features.Attributes(),
		)
	}

	var maintenance basetypes.ObjectValue

	if v.Maintenance.IsNull() {
		maintenance = types.ObjectNull(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Maintenance.IsUnknown() {
		maintenance = types.ObjectUnknown(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Maintenance.IsNull() && !v.Maintenance.IsUnknown() {
		maintenance = types.ObjectValueMust(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
			v.Maintenance.Attributes(),
		)
	}

	settings := types.ListValueMust(
		ConfigsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	users := types.ListValueMust(
		ConfigsUsersType{
			basetypes.ObjectType{
				AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Users.Elements(),
	)

	if v.Users.IsNull() {
		users = types.ListNull(
			ConfigsUsersType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Users.IsUnknown() {
		users = types.ListUnknown(
			ConfigsUsersType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	warehouses := types.ListValueMust(
		ConfigsWarehousesType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
			},
		},
		v.Warehouses.Elements(),
	)

	if v.Warehouses.IsNull() {
		warehouses = types.ListNull(
			ConfigsWarehousesType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Warehouses.IsUnknown() {
		warehouses = types.ListUnknown(
			ConfigsWarehousesType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesValue{}.AttributeTypes(ctx),
		},
		"maintenance": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		},
		"settings": basetypes.ListType{
			ElemType: ConfigsSettingsValue{}.Type(ctx),
		},
		"users": basetypes.ListType{
			ElemType: ConfigsUsersValue{}.Type(ctx),
		},
		"warehouses": basetypes.ListType{
			ElemType: ConfigsWarehousesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"features":    features,
			"maintenance": maintenance,
			"settings":    settings,
			"users":       users,
			"warehouses":  warehouses,
		})

	return objVal, diags
}

func (v ConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.Maintenance.Equal(other.Maintenance) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	if !v.Warehouses.Equal(other.Warehouses) {
		return false
	}

	return true
}

func (v ConfigsValue) Type(ctx context.Context) attr.Type {
	return ConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"features": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesValue{}.AttributeTypes(ctx),
		},
		"maintenance": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		},
		"settings": basetypes.ListType{
			ElemType: ConfigsSettingsValue{}.Type(ctx),
		},
		"users": basetypes.ListType{
			ElemType: ConfigsUsersValue{}.Type(ctx),
		},
		"warehouses": basetypes.ListType{
			ElemType: ConfigsWarehousesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsFeaturesType{}

type ConfigsFeaturesType struct {
	basetypes.ObjectType
}

func (t ConfigsFeaturesType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsFeaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsFeaturesType) String() string {
	return "ConfigsFeaturesType"
}

func (t ConfigsFeaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	volumeAutoresizeAttribute, ok := attributes["volume_autoresize"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_autoresize is missing from object`)

		return nil, diags
	}

	volumeAutoresizeVal, ok := volumeAutoresizeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_autoresize expected to be basetypes.ObjectValue, was: %T`, volumeAutoresizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsFeaturesValue{
		VolumeAutoresize: volumeAutoresizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesValueNull() ConfigsFeaturesValue {
	return ConfigsFeaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsFeaturesValueUnknown() ConfigsFeaturesValue {
	return ConfigsFeaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsFeaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsFeaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsFeaturesValue Attribute Value",
				"While creating a ConfigsFeaturesValue value, a missing attribute value was detected. "+
					"A ConfigsFeaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsFeaturesValue Attribute Type",
				"While creating a ConfigsFeaturesValue value, an invalid attribute value was detected. "+
					"A ConfigsFeaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsFeaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsFeaturesValue Attribute Value",
				"While creating a ConfigsFeaturesValue value, an extra attribute value was detected. "+
					"A ConfigsFeaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsFeaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsFeaturesValueUnknown(), diags
	}

	volumeAutoresizeAttribute, ok := attributes["volume_autoresize"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_autoresize is missing from object`)

		return NewConfigsFeaturesValueUnknown(), diags
	}

	volumeAutoresizeVal, ok := volumeAutoresizeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_autoresize expected to be basetypes.ObjectValue, was: %T`, volumeAutoresizeAttribute))
	}

	if diags.HasError() {
		return NewConfigsFeaturesValueUnknown(), diags
	}

	return ConfigsFeaturesValue{
		VolumeAutoresize: volumeAutoresizeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsFeaturesValue {
	object, diags := NewConfigsFeaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsFeaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsFeaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsFeaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsFeaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsFeaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsFeaturesValueMust(ConfigsFeaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsFeaturesType) ValueType(ctx context.Context) attr.Value {
	return ConfigsFeaturesValue{}
}

var _ basetypes.ObjectValuable = ConfigsFeaturesValue{}

type ConfigsFeaturesValue struct {
	VolumeAutoresize basetypes.ObjectValue `tfsdk:"volume_autoresize"`
	state            attr.ValueState
}

func (v ConfigsFeaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["volume_autoresize"] = basetypes.ObjectType{
		AttrTypes: ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.VolumeAutoresize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_autoresize"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsFeaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsFeaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsFeaturesValue) String() string {
	return "ConfigsFeaturesValue"
}

func (v ConfigsFeaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var volumeAutoresize basetypes.ObjectValue

	if v.VolumeAutoresize.IsNull() {
		volumeAutoresize = types.ObjectNull(
			ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
		)
	}

	if v.VolumeAutoresize.IsUnknown() {
		volumeAutoresize = types.ObjectUnknown(
			ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.VolumeAutoresize.IsNull() && !v.VolumeAutoresize.IsUnknown() {
		volumeAutoresize = types.ObjectValueMust(
			ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
			v.VolumeAutoresize.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"volume_autoresize": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"volume_autoresize": volumeAutoresize,
		})

	return objVal, diags
}

func (v ConfigsFeaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsFeaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VolumeAutoresize.Equal(other.VolumeAutoresize) {
		return false
	}

	return true
}

func (v ConfigsFeaturesValue) Type(ctx context.Context) attr.Type {
	return ConfigsFeaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsFeaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"volume_autoresize": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsFeaturesVolumeAutoresizeType{}

type ConfigsFeaturesVolumeAutoresizeType struct {
	basetypes.ObjectType
}

func (t ConfigsFeaturesVolumeAutoresizeType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsFeaturesVolumeAutoresizeType) String() string {
	return "ConfigsFeaturesVolumeAutoresizeType"
}

func (t ConfigsFeaturesVolumeAutoresizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return nil, diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	walAttribute, ok := attributes["wal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wal is missing from object`)

		return nil, diags
	}

	walVal, ok := walAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wal expected to be basetypes.ObjectValue, was: %T`, walAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsFeaturesVolumeAutoresizeValue{
		Data:  dataVal,
		Wal:   walVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeValueNull() ConfigsFeaturesVolumeAutoresizeValue {
	return ConfigsFeaturesVolumeAutoresizeValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsFeaturesVolumeAutoresizeValueUnknown() ConfigsFeaturesVolumeAutoresizeValue {
	return ConfigsFeaturesVolumeAutoresizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsFeaturesVolumeAutoresizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsFeaturesVolumeAutoresizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsFeaturesVolumeAutoresizeValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeValue value, a missing attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsFeaturesVolumeAutoresizeValue Attribute Type",
				"While creating a ConfigsFeaturesVolumeAutoresizeValue value, an invalid attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsFeaturesVolumeAutoresizeValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeValue value, an extra attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsFeaturesVolumeAutoresizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeValueUnknown(), diags
	}

	dataAttribute, ok := attributes["data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeValueUnknown(), diags
	}

	dataVal, ok := dataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data expected to be basetypes.ObjectValue, was: %T`, dataAttribute))
	}

	walAttribute, ok := attributes["wal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wal is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeValueUnknown(), diags
	}

	walVal, ok := walAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wal expected to be basetypes.ObjectValue, was: %T`, walAttribute))
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeValueUnknown(), diags
	}

	return ConfigsFeaturesVolumeAutoresizeValue{
		Data:  dataVal,
		Wal:   walVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsFeaturesVolumeAutoresizeValue {
	object, diags := NewConfigsFeaturesVolumeAutoresizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsFeaturesVolumeAutoresizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsFeaturesVolumeAutoresizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsFeaturesVolumeAutoresizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsFeaturesVolumeAutoresizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsFeaturesVolumeAutoresizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsFeaturesVolumeAutoresizeValueMust(ConfigsFeaturesVolumeAutoresizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsFeaturesVolumeAutoresizeType) ValueType(ctx context.Context) attr.Value {
	return ConfigsFeaturesVolumeAutoresizeValue{}
}

var _ basetypes.ObjectValuable = ConfigsFeaturesVolumeAutoresizeValue{}

type ConfigsFeaturesVolumeAutoresizeValue struct {
	Data  basetypes.ObjectValue `tfsdk:"data"`
	Wal   basetypes.ObjectValue `tfsdk:"wal"`
	state attr.ValueState
}

func (v ConfigsFeaturesVolumeAutoresizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["data"] = basetypes.ObjectType{
		AttrTypes: ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wal"] = basetypes.ObjectType{
		AttrTypes: ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Data.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data"] = val

		val, err = v.Wal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wal"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsFeaturesVolumeAutoresizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsFeaturesVolumeAutoresizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsFeaturesVolumeAutoresizeValue) String() string {
	return "ConfigsFeaturesVolumeAutoresizeValue"
}

func (v ConfigsFeaturesVolumeAutoresizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var data basetypes.ObjectValue

	if v.Data.IsNull() {
		data = types.ObjectNull(
			ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Data.IsUnknown() {
		data = types.ObjectUnknown(
			ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Data.IsNull() && !v.Data.IsUnknown() {
		data = types.ObjectValueMust(
			ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
			v.Data.Attributes(),
		)
	}

	var wal basetypes.ObjectValue

	if v.Wal.IsNull() {
		wal = types.ObjectNull(
			ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Wal.IsUnknown() {
		wal = types.ObjectUnknown(
			ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Wal.IsNull() && !v.Wal.IsUnknown() {
		wal = types.ObjectValueMust(
			ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
			v.Wal.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
		},
		"wal": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data": data,
			"wal":  wal,
		})

	return objVal, diags
}

func (v ConfigsFeaturesVolumeAutoresizeValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Data.Equal(other.Data) {
		return false
	}

	if !v.Wal.Equal(other.Wal) {
		return false
	}

	return true
}

func (v ConfigsFeaturesVolumeAutoresizeValue) Type(ctx context.Context) attr.Type {
	return ConfigsFeaturesVolumeAutoresizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsFeaturesVolumeAutoresizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx),
		},
		"wal": basetypes.ObjectType{
			AttrTypes: ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsFeaturesVolumeAutoresizeDataType{}

type ConfigsFeaturesVolumeAutoresizeDataType struct {
	basetypes.ObjectType
}

func (t ConfigsFeaturesVolumeAutoresizeDataType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeDataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsFeaturesVolumeAutoresizeDataType) String() string {
	return "ConfigsFeaturesVolumeAutoresizeDataType"
}

func (t ConfigsFeaturesVolumeAutoresizeDataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxScaleSizeAttribute, ok := attributes["max_scale_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_scale_size is missing from object`)

		return nil, diags
	}

	maxScaleSizeVal, ok := maxScaleSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_scale_size expected to be basetypes.Int64Value, was: %T`, maxScaleSizeAttribute))
	}

	scaleStepSizeAttribute, ok := attributes["scale_step_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_step_size is missing from object`)

		return nil, diags
	}

	scaleStepSizeVal, ok := scaleStepSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_step_size expected to be basetypes.Int64Value, was: %T`, scaleStepSizeAttribute))
	}

	sizeScaleThresholdAttribute, ok := attributes["size_scale_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_scale_threshold is missing from object`)

		return nil, diags
	}

	sizeScaleThresholdVal, ok := sizeScaleThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_scale_threshold expected to be basetypes.Int64Value, was: %T`, sizeScaleThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsFeaturesVolumeAutoresizeDataValue{
		Enabled:            enabledVal,
		MaxScaleSize:       maxScaleSizeVal,
		ScaleStepSize:      scaleStepSizeVal,
		SizeScaleThreshold: sizeScaleThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeDataValueNull() ConfigsFeaturesVolumeAutoresizeDataValue {
	return ConfigsFeaturesVolumeAutoresizeDataValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsFeaturesVolumeAutoresizeDataValueUnknown() ConfigsFeaturesVolumeAutoresizeDataValue {
	return ConfigsFeaturesVolumeAutoresizeDataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsFeaturesVolumeAutoresizeDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsFeaturesVolumeAutoresizeDataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsFeaturesVolumeAutoresizeDataValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeDataValue value, a missing attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeDataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeDataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsFeaturesVolumeAutoresizeDataValue Attribute Type",
				"While creating a ConfigsFeaturesVolumeAutoresizeDataValue value, an invalid attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeDataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeDataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeDataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsFeaturesVolumeAutoresizeDataValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeDataValue value, an extra attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeDataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsFeaturesVolumeAutoresizeDataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxScaleSizeAttribute, ok := attributes["max_scale_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_scale_size is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	maxScaleSizeVal, ok := maxScaleSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_scale_size expected to be basetypes.Int64Value, was: %T`, maxScaleSizeAttribute))
	}

	scaleStepSizeAttribute, ok := attributes["scale_step_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_step_size is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	scaleStepSizeVal, ok := scaleStepSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_step_size expected to be basetypes.Int64Value, was: %T`, scaleStepSizeAttribute))
	}

	sizeScaleThresholdAttribute, ok := attributes["size_scale_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_scale_threshold is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	sizeScaleThresholdVal, ok := sizeScaleThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_scale_threshold expected to be basetypes.Int64Value, was: %T`, sizeScaleThresholdAttribute))
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), diags
	}

	return ConfigsFeaturesVolumeAutoresizeDataValue{
		Enabled:            enabledVal,
		MaxScaleSize:       maxScaleSizeVal,
		ScaleStepSize:      scaleStepSizeVal,
		SizeScaleThreshold: sizeScaleThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsFeaturesVolumeAutoresizeDataValue {
	object, diags := NewConfigsFeaturesVolumeAutoresizeDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsFeaturesVolumeAutoresizeDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsFeaturesVolumeAutoresizeDataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsFeaturesVolumeAutoresizeDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsFeaturesVolumeAutoresizeDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsFeaturesVolumeAutoresizeDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsFeaturesVolumeAutoresizeDataValueMust(ConfigsFeaturesVolumeAutoresizeDataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsFeaturesVolumeAutoresizeDataType) ValueType(ctx context.Context) attr.Value {
	return ConfigsFeaturesVolumeAutoresizeDataValue{}
}

var _ basetypes.ObjectValuable = ConfigsFeaturesVolumeAutoresizeDataValue{}

type ConfigsFeaturesVolumeAutoresizeDataValue struct {
	Enabled            basetypes.BoolValue  `tfsdk:"enabled"`
	MaxScaleSize       basetypes.Int64Value `tfsdk:"max_scale_size"`
	ScaleStepSize      basetypes.Int64Value `tfsdk:"scale_step_size"`
	SizeScaleThreshold basetypes.Int64Value `tfsdk:"size_scale_threshold"`
	state              attr.ValueState
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_scale_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scale_step_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size_scale_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MaxScaleSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_scale_size"] = val

		val, err = v.ScaleStepSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scale_step_size"] = val

		val, err = v.SizeScaleThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_scale_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) String() string {
	return "ConfigsFeaturesVolumeAutoresizeDataValue"
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"max_scale_size":       basetypes.Int64Type{},
		"scale_step_size":      basetypes.Int64Type{},
		"size_scale_threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":              v.Enabled,
			"max_scale_size":       v.MaxScaleSize,
			"scale_step_size":      v.ScaleStepSize,
			"size_scale_threshold": v.SizeScaleThreshold,
		})

	return objVal, diags
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeDataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MaxScaleSize.Equal(other.MaxScaleSize) {
		return false
	}

	if !v.ScaleStepSize.Equal(other.ScaleStepSize) {
		return false
	}

	if !v.SizeScaleThreshold.Equal(other.SizeScaleThreshold) {
		return false
	}

	return true
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) Type(ctx context.Context) attr.Type {
	return ConfigsFeaturesVolumeAutoresizeDataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsFeaturesVolumeAutoresizeDataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"max_scale_size":       basetypes.Int64Type{},
		"scale_step_size":      basetypes.Int64Type{},
		"size_scale_threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ConfigsFeaturesVolumeAutoresizeWalType{}

type ConfigsFeaturesVolumeAutoresizeWalType struct {
	basetypes.ObjectType
}

func (t ConfigsFeaturesVolumeAutoresizeWalType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeWalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsFeaturesVolumeAutoresizeWalType) String() string {
	return "ConfigsFeaturesVolumeAutoresizeWalType"
}

func (t ConfigsFeaturesVolumeAutoresizeWalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxScaleSizeAttribute, ok := attributes["max_scale_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_scale_size is missing from object`)

		return nil, diags
	}

	maxScaleSizeVal, ok := maxScaleSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_scale_size expected to be basetypes.Int64Value, was: %T`, maxScaleSizeAttribute))
	}

	scaleStepSizeAttribute, ok := attributes["scale_step_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_step_size is missing from object`)

		return nil, diags
	}

	scaleStepSizeVal, ok := scaleStepSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_step_size expected to be basetypes.Int64Value, was: %T`, scaleStepSizeAttribute))
	}

	sizeScaleThresholdAttribute, ok := attributes["size_scale_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_scale_threshold is missing from object`)

		return nil, diags
	}

	sizeScaleThresholdVal, ok := sizeScaleThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_scale_threshold expected to be basetypes.Int64Value, was: %T`, sizeScaleThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsFeaturesVolumeAutoresizeWalValue{
		Enabled:            enabledVal,
		MaxScaleSize:       maxScaleSizeVal,
		ScaleStepSize:      scaleStepSizeVal,
		SizeScaleThreshold: sizeScaleThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeWalValueNull() ConfigsFeaturesVolumeAutoresizeWalValue {
	return ConfigsFeaturesVolumeAutoresizeWalValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsFeaturesVolumeAutoresizeWalValueUnknown() ConfigsFeaturesVolumeAutoresizeWalValue {
	return ConfigsFeaturesVolumeAutoresizeWalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsFeaturesVolumeAutoresizeWalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsFeaturesVolumeAutoresizeWalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsFeaturesVolumeAutoresizeWalValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeWalValue value, a missing attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeWalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeWalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsFeaturesVolumeAutoresizeWalValue Attribute Type",
				"While creating a ConfigsFeaturesVolumeAutoresizeWalValue value, an invalid attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeWalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeWalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsFeaturesVolumeAutoresizeWalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsFeaturesVolumeAutoresizeWalValue Attribute Value",
				"While creating a ConfigsFeaturesVolumeAutoresizeWalValue value, an extra attribute value was detected. "+
					"A ConfigsFeaturesVolumeAutoresizeWalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsFeaturesVolumeAutoresizeWalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxScaleSizeAttribute, ok := attributes["max_scale_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_scale_size is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	maxScaleSizeVal, ok := maxScaleSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_scale_size expected to be basetypes.Int64Value, was: %T`, maxScaleSizeAttribute))
	}

	scaleStepSizeAttribute, ok := attributes["scale_step_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_step_size is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	scaleStepSizeVal, ok := scaleStepSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_step_size expected to be basetypes.Int64Value, was: %T`, scaleStepSizeAttribute))
	}

	sizeScaleThresholdAttribute, ok := attributes["size_scale_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_scale_threshold is missing from object`)

		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	sizeScaleThresholdVal, ok := sizeScaleThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_scale_threshold expected to be basetypes.Int64Value, was: %T`, sizeScaleThresholdAttribute))
	}

	if diags.HasError() {
		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), diags
	}

	return ConfigsFeaturesVolumeAutoresizeWalValue{
		Enabled:            enabledVal,
		MaxScaleSize:       maxScaleSizeVal,
		ScaleStepSize:      scaleStepSizeVal,
		SizeScaleThreshold: sizeScaleThresholdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigsFeaturesVolumeAutoresizeWalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsFeaturesVolumeAutoresizeWalValue {
	object, diags := NewConfigsFeaturesVolumeAutoresizeWalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsFeaturesVolumeAutoresizeWalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsFeaturesVolumeAutoresizeWalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsFeaturesVolumeAutoresizeWalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsFeaturesVolumeAutoresizeWalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsFeaturesVolumeAutoresizeWalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsFeaturesVolumeAutoresizeWalValueMust(ConfigsFeaturesVolumeAutoresizeWalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsFeaturesVolumeAutoresizeWalType) ValueType(ctx context.Context) attr.Value {
	return ConfigsFeaturesVolumeAutoresizeWalValue{}
}

var _ basetypes.ObjectValuable = ConfigsFeaturesVolumeAutoresizeWalValue{}

type ConfigsFeaturesVolumeAutoresizeWalValue struct {
	Enabled            basetypes.BoolValue  `tfsdk:"enabled"`
	MaxScaleSize       basetypes.Int64Value `tfsdk:"max_scale_size"`
	ScaleStepSize      basetypes.Int64Value `tfsdk:"scale_step_size"`
	SizeScaleThreshold basetypes.Int64Value `tfsdk:"size_scale_threshold"`
	state              attr.ValueState
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_scale_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scale_step_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size_scale_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MaxScaleSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_scale_size"] = val

		val, err = v.ScaleStepSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scale_step_size"] = val

		val, err = v.SizeScaleThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_scale_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) String() string {
	return "ConfigsFeaturesVolumeAutoresizeWalValue"
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"max_scale_size":       basetypes.Int64Type{},
		"scale_step_size":      basetypes.Int64Type{},
		"size_scale_threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":              v.Enabled,
			"max_scale_size":       v.MaxScaleSize,
			"scale_step_size":      v.ScaleStepSize,
			"size_scale_threshold": v.SizeScaleThreshold,
		})

	return objVal, diags
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsFeaturesVolumeAutoresizeWalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MaxScaleSize.Equal(other.MaxScaleSize) {
		return false
	}

	if !v.ScaleStepSize.Equal(other.ScaleStepSize) {
		return false
	}

	if !v.SizeScaleThreshold.Equal(other.SizeScaleThreshold) {
		return false
	}

	return true
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) Type(ctx context.Context) attr.Type {
	return ConfigsFeaturesVolumeAutoresizeWalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsFeaturesVolumeAutoresizeWalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"max_scale_size":       basetypes.Int64Type{},
		"scale_step_size":      basetypes.Int64Type{},
		"size_scale_threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceType{}

type ConfigsMaintenanceType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceType) String() string {
	return "ConfigsMaintenanceType"
}

func (t ConfigsMaintenanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return nil, diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	crontabsAttribute, ok := attributes["crontabs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`crontabs is missing from object`)

		return nil, diags
	}

	crontabsVal, ok := crontabsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`crontabs expected to be basetypes.ListValue, was: %T`, crontabsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceValue{
		Backup:   backupVal,
		Crontabs: crontabsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceValueNull() ConfigsMaintenanceValue {
	return ConfigsMaintenanceValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceValueUnknown() ConfigsMaintenanceValue {
	return ConfigsMaintenanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceValue Attribute Value",
				"While creating a ConfigsMaintenanceValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceValue Attribute Type",
				"While creating a ConfigsMaintenanceValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceValue Attribute Value",
				"While creating a ConfigsMaintenanceValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceValueUnknown(), diags
	}

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	crontabsAttribute, ok := attributes["crontabs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`crontabs is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	crontabsVal, ok := crontabsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`crontabs expected to be basetypes.ListValue, was: %T`, crontabsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceValueUnknown(), diags
	}

	return ConfigsMaintenanceValue{
		Backup:   backupVal,
		Crontabs: crontabsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceValue {
	object, diags := NewConfigsMaintenanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceValueMust(ConfigsMaintenanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceValue{}

type ConfigsMaintenanceValue struct {
	Backup   basetypes.ObjectValue `tfsdk:"backup"`
	Crontabs basetypes.ListValue   `tfsdk:"crontabs"`
	Start    basetypes.StringValue `tfsdk:"start"`
	state    attr.ValueState
}

func (v ConfigsMaintenanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["backup"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["crontabs"] = basetypes.ListType{
		ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Backup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup"] = val

		val, err = v.Crontabs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["crontabs"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceValue) String() string {
	return "ConfigsMaintenanceValue"
}

func (v ConfigsMaintenanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var backup basetypes.ObjectValue

	if v.Backup.IsNull() {
		backup = types.ObjectNull(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if v.Backup.IsUnknown() {
		backup = types.ObjectUnknown(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Backup.IsNull() && !v.Backup.IsUnknown() {
		backup = types.ObjectValueMust(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
			v.Backup.Attributes(),
		)
	}

	crontabs := types.ListValueMust(
		ConfigsMaintenanceCrontabsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
			},
		},
		v.Crontabs.Elements(),
	)

	if v.Crontabs.IsNull() {
		crontabs = types.ListNull(
			ConfigsMaintenanceCrontabsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Crontabs.IsUnknown() {
		crontabs = types.ListUnknown(
			ConfigsMaintenanceCrontabsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"crontabs": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup":   backup,
			"crontabs": crontabs,
			"start":    v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Backup.Equal(other.Backup) {
		return false
	}

	if !v.Crontabs.Equal(other.Crontabs) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"crontabs": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupType{}

type ConfigsMaintenanceBackupType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupType) String() string {
	return "ConfigsMaintenanceBackupType"
}

func (t ConfigsMaintenanceBackupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return nil, diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return nil, diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return nil, diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupValueNull() ConfigsMaintenanceBackupValue {
	return ConfigsMaintenanceBackupValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupValueUnknown() ConfigsMaintenanceBackupValue {
	return ConfigsMaintenanceBackupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupValue {
	object, diags := NewConfigsMaintenanceBackupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupValueMust(ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupValue{}

type ConfigsMaintenanceBackupValue struct {
	Differential basetypes.ObjectValue `tfsdk:"differential"`
	Full         basetypes.ObjectValue `tfsdk:"full"`
	Incremental  basetypes.ObjectValue `tfsdk:"incremental"`
	state        attr.ValueState
}

func (v ConfigsMaintenanceBackupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["differential"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["full"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["incremental"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Differential.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["differential"] = val

		val, err = v.Full.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full"] = val

		val, err = v.Incremental.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incremental"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupValue) String() string {
	return "ConfigsMaintenanceBackupValue"
}

func (v ConfigsMaintenanceBackupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var differential basetypes.ObjectValue

	if v.Differential.IsNull() {
		differential = types.ObjectNull(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if v.Differential.IsUnknown() {
		differential = types.ObjectUnknown(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Differential.IsNull() && !v.Differential.IsUnknown() {
		differential = types.ObjectValueMust(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
			v.Differential.Attributes(),
		)
	}

	var full basetypes.ObjectValue

	if v.Full.IsNull() {
		full = types.ObjectNull(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if v.Full.IsUnknown() {
		full = types.ObjectUnknown(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Full.IsNull() && !v.Full.IsUnknown() {
		full = types.ObjectValueMust(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
			v.Full.Attributes(),
		)
	}

	var incremental basetypes.ObjectValue

	if v.Incremental.IsNull() {
		incremental = types.ObjectNull(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Incremental.IsUnknown() {
		incremental = types.ObjectUnknown(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Incremental.IsNull() && !v.Incremental.IsUnknown() {
		incremental = types.ObjectValueMust(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
			v.Incremental.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"differential": differential,
			"full":         full,
			"incremental":  incremental,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Differential.Equal(other.Differential) {
		return false
	}

	if !v.Full.Equal(other.Full) {
		return false
	}

	if !v.Incremental.Equal(other.Incremental) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupDifferentialType{}

type ConfigsMaintenanceBackupDifferentialType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupDifferentialType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupDifferentialType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupDifferentialType) String() string {
	return "ConfigsMaintenanceBackupDifferentialType"
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupDifferentialValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupDifferentialValueNull() ConfigsMaintenanceBackupDifferentialValue {
	return ConfigsMaintenanceBackupDifferentialValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupDifferentialValueUnknown() ConfigsMaintenanceBackupDifferentialValue {
	return ConfigsMaintenanceBackupDifferentialValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupDifferentialValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupDifferentialValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupDifferentialValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupDifferentialValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupDifferentialValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupDifferentialValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupDifferentialValue {
	object, diags := NewConfigsMaintenanceBackupDifferentialValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupDifferentialValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupDifferentialValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupDifferentialValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupDifferentialValueMust(ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupDifferentialValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupDifferentialValue{}

type ConfigsMaintenanceBackupDifferentialValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupDifferentialValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupDifferentialValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupDifferentialValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupDifferentialValue) String() string {
	return "ConfigsMaintenanceBackupDifferentialValue"
}

func (v ConfigsMaintenanceBackupDifferentialValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupDifferentialValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupDifferentialValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupDifferentialValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupDifferentialType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupDifferentialValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupFullType{}

type ConfigsMaintenanceBackupFullType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupFullType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupFullType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupFullType) String() string {
	return "ConfigsMaintenanceBackupFullType"
}

func (t ConfigsMaintenanceBackupFullType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupFullValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupFullValueNull() ConfigsMaintenanceBackupFullValue {
	return ConfigsMaintenanceBackupFullValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupFullValueUnknown() ConfigsMaintenanceBackupFullValue {
	return ConfigsMaintenanceBackupFullValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupFullValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupFullValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupFullValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupFullValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupFullValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupFullValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupFullValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupFullValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupFullValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupFullValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupFullValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupFullValue {
	object, diags := NewConfigsMaintenanceBackupFullValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupFullValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupFullType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupFullValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupFullValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupFullValueMust(ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupFullType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupFullValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupFullValue{}

type ConfigsMaintenanceBackupFullValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupFullValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupFullValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupFullValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupFullValue) String() string {
	return "ConfigsMaintenanceBackupFullValue"
}

func (v ConfigsMaintenanceBackupFullValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupFullValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupFullValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupFullValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupFullType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupFullValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupIncrementalType{}

type ConfigsMaintenanceBackupIncrementalType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupIncrementalType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupIncrementalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupIncrementalType) String() string {
	return "ConfigsMaintenanceBackupIncrementalType"
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupIncrementalValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupIncrementalValueNull() ConfigsMaintenanceBackupIncrementalValue {
	return ConfigsMaintenanceBackupIncrementalValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupIncrementalValueUnknown() ConfigsMaintenanceBackupIncrementalValue {
	return ConfigsMaintenanceBackupIncrementalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupIncrementalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupIncrementalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupIncrementalValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupIncrementalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupIncrementalValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupIncrementalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupIncrementalValue {
	object, diags := NewConfigsMaintenanceBackupIncrementalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupIncrementalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupIncrementalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupIncrementalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupIncrementalValueMust(ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupIncrementalValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupIncrementalValue{}

type ConfigsMaintenanceBackupIncrementalValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupIncrementalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupIncrementalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupIncrementalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupIncrementalValue) String() string {
	return "ConfigsMaintenanceBackupIncrementalValue"
}

func (v ConfigsMaintenanceBackupIncrementalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupIncrementalValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupIncrementalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupIncrementalValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupIncrementalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupIncrementalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceCrontabsType{}

type ConfigsMaintenanceCrontabsType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceCrontabsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceCrontabsType) String() string {
	return "ConfigsMaintenanceCrontabsType"
}

func (t ConfigsMaintenanceCrontabsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceCrontabsValue{
		Name:     nameVal,
		Required: requiredVal,
		Settings: settingsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsValueNull() ConfigsMaintenanceCrontabsValue {
	return ConfigsMaintenanceCrontabsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceCrontabsValueUnknown() ConfigsMaintenanceCrontabsValue {
	return ConfigsMaintenanceCrontabsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceCrontabsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceCrontabsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceCrontabsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceCrontabsValue Attribute Type",
				"While creating a ConfigsMaintenanceCrontabsValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceCrontabsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceCrontabsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	return ConfigsMaintenanceCrontabsValue{
		Name:     nameVal,
		Required: requiredVal,
		Settings: settingsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceCrontabsValue {
	object, diags := NewConfigsMaintenanceCrontabsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceCrontabsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceCrontabsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceCrontabsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceCrontabsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceCrontabsValueMust(ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceCrontabsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceCrontabsValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceCrontabsValue{}

type ConfigsMaintenanceCrontabsValue struct {
	Name     basetypes.StringValue `tfsdk:"name"`
	Required basetypes.BoolValue   `tfsdk:"required"`
	Settings basetypes.ListValue   `tfsdk:"settings"`
	Start    basetypes.StringValue `tfsdk:"start"`
	state    attr.ValueState
}

func (v ConfigsMaintenanceCrontabsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceCrontabsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceCrontabsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceCrontabsValue) String() string {
	return "ConfigsMaintenanceCrontabsValue"
}

func (v ConfigsMaintenanceCrontabsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsMaintenanceCrontabsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsMaintenanceCrontabsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsMaintenanceCrontabsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"name":     basetypes.StringType{},
		"required": basetypes.BoolType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":     v.Name,
			"required": v.Required,
			"settings": settings,
			"start":    v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceCrontabsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceCrontabsValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceCrontabsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceCrontabsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":     basetypes.StringType{},
		"required": basetypes.BoolType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceCrontabsSettingsType{}

type ConfigsMaintenanceCrontabsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceCrontabsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceCrontabsSettingsType) String() string {
	return "ConfigsMaintenanceCrontabsSettingsType"
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceCrontabsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsSettingsValueNull() ConfigsMaintenanceCrontabsSettingsValue {
	return ConfigsMaintenanceCrontabsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceCrontabsSettingsValueUnknown() ConfigsMaintenanceCrontabsSettingsValue {
	return ConfigsMaintenanceCrontabsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceCrontabsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceCrontabsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceCrontabsSettingsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceCrontabsSettingsValue Attribute Type",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceCrontabsSettingsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceCrontabsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	return ConfigsMaintenanceCrontabsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceCrontabsSettingsValue {
	object, diags := NewConfigsMaintenanceCrontabsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceCrontabsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceCrontabsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceCrontabsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceCrontabsSettingsValueMust(ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceCrontabsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceCrontabsSettingsValue{}

type ConfigsMaintenanceCrontabsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsMaintenanceCrontabsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceCrontabsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceCrontabsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceCrontabsSettingsValue) String() string {
	return "ConfigsMaintenanceCrontabsSettingsValue"
}

func (v ConfigsMaintenanceCrontabsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceCrontabsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceCrontabsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceCrontabsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceCrontabsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsSettingsType{}

type ConfigsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsSettingsType) String() string {
	return "ConfigsSettingsType"
}

func (t ConfigsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsSettingsValueNull() ConfigsSettingsValue {
	return ConfigsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsSettingsValueUnknown() ConfigsSettingsValue {
	return ConfigsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsSettingsValue Attribute Value",
				"While creating a ConfigsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsSettingsValue Attribute Type",
				"While creating a ConfigsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsSettingsValue Attribute Value",
				"While creating a ConfigsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsSettingsValueUnknown(), diags
	}

	return ConfigsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsSettingsValue {
	object, diags := NewConfigsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsSettingsValueMust(ConfigsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsSettingsValue{}

type ConfigsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsSettingsValue) String() string {
	return "ConfigsSettingsValue"
}

func (v ConfigsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsUsersType{}

type ConfigsUsersType struct {
	basetypes.ObjectType
}

func (t ConfigsUsersType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsUsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsUsersType) String() string {
	return "ConfigsUsersType"
}

func (t ConfigsUsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return nil, diags
	}

	accessVal, ok := accessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ObjectValue, was: %T`, accessAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsUsersValue{
		Access:    accessVal,
		CreatedAt: createdAtVal,
		Id:        idVal,
		Password:  passwordVal,
		Role:      roleVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersValueNull() ConfigsUsersValue {
	return ConfigsUsersValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsUsersValueUnknown() ConfigsUsersValue {
	return ConfigsUsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsUsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsUsersValue Attribute Value",
				"While creating a ConfigsUsersValue value, a missing attribute value was detected. "+
					"A ConfigsUsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsUsersValue Attribute Type",
				"While creating a ConfigsUsersValue value, an invalid attribute value was detected. "+
					"A ConfigsUsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsUsersValue Attribute Value",
				"While creating a ConfigsUsersValue value, an extra attribute value was detected. "+
					"A ConfigsUsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsUsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsUsersValueUnknown(), diags
	}

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	accessVal, ok := accessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ObjectValue, was: %T`, accessAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewConfigsUsersValueUnknown(), diags
	}

	return ConfigsUsersValue{
		Access:    accessVal,
		CreatedAt: createdAtVal,
		Id:        idVal,
		Password:  passwordVal,
		Role:      roleVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsUsersValue {
	object, diags := NewConfigsUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsUsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsUsersValueMust(ConfigsUsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsUsersType) ValueType(ctx context.Context) attr.Value {
	return ConfigsUsersValue{}
}

var _ basetypes.ObjectValuable = ConfigsUsersValue{}

type ConfigsUsersValue struct {
	Access    basetypes.ObjectValue `tfsdk:"access"`
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Id        basetypes.StringValue `tfsdk:"id"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Role      basetypes.StringValue `tfsdk:"role"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v ConfigsUsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["access"] = basetypes.ObjectType{
		AttrTypes: ConfigsUsersAccessValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Access.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsUsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsUsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsUsersValue) String() string {
	return "ConfigsUsersValue"
}

func (v ConfigsUsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var access basetypes.ObjectValue

	if v.Access.IsNull() {
		access = types.ObjectNull(
			ConfigsUsersAccessValue{}.AttributeTypes(ctx),
		)
	}

	if v.Access.IsUnknown() {
		access = types.ObjectUnknown(
			ConfigsUsersAccessValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Access.IsNull() && !v.Access.IsUnknown() {
		access = types.ObjectValueMust(
			ConfigsUsersAccessValue{}.AttributeTypes(ctx),
			v.Access.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"access": basetypes.ObjectType{
			AttrTypes: ConfigsUsersAccessValue{}.AttributeTypes(ctx),
		},
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"password":   basetypes.StringType{},
		"role":       basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access":     access,
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"password":   v.Password,
			"role":       v.Role,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v ConfigsUsersValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsUsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Access.Equal(other.Access) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v ConfigsUsersValue) Type(ctx context.Context) attr.Type {
	return ConfigsUsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsUsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access": basetypes.ObjectType{
			AttrTypes: ConfigsUsersAccessValue{}.AttributeTypes(ctx),
		},
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"password":   basetypes.StringType{},
		"role":       basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsUsersAccessType{}

type ConfigsUsersAccessType struct {
	basetypes.ObjectType
}

func (t ConfigsUsersAccessType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsUsersAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsUsersAccessType) String() string {
	return "ConfigsUsersAccessType"
}

func (t ConfigsUsersAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsUsersAccessValue{
		Id:       idVal,
		Settings: settingsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersAccessValueNull() ConfigsUsersAccessValue {
	return ConfigsUsersAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsUsersAccessValueUnknown() ConfigsUsersAccessValue {
	return ConfigsUsersAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsUsersAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsUsersAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsUsersAccessValue Attribute Value",
				"While creating a ConfigsUsersAccessValue value, a missing attribute value was detected. "+
					"A ConfigsUsersAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsUsersAccessValue Attribute Type",
				"While creating a ConfigsUsersAccessValue value, an invalid attribute value was detected. "+
					"A ConfigsUsersAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsUsersAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsUsersAccessValue Attribute Value",
				"While creating a ConfigsUsersAccessValue value, an extra attribute value was detected. "+
					"A ConfigsUsersAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsUsersAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsUsersAccessValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsUsersAccessValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsUsersAccessValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewConfigsUsersAccessValueUnknown(), diags
	}

	return ConfigsUsersAccessValue{
		Id:       idVal,
		Settings: settingsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsUsersAccessValue {
	object, diags := NewConfigsUsersAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsUsersAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsUsersAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsUsersAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsUsersAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsUsersAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsUsersAccessValueMust(ConfigsUsersAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsUsersAccessType) ValueType(ctx context.Context) attr.Value {
	return ConfigsUsersAccessValue{}
}

var _ basetypes.ObjectValuable = ConfigsUsersAccessValue{}

type ConfigsUsersAccessValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	Settings basetypes.ListValue   `tfsdk:"settings"`
	state    attr.ValueState
}

func (v ConfigsUsersAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsUsersAccessSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsUsersAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsUsersAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsUsersAccessValue) String() string {
	return "ConfigsUsersAccessValue"
}

func (v ConfigsUsersAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsUsersAccessSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsUsersAccessSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsUsersAccessSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersAccessSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsUsersAccessSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersAccessSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id": basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsUsersAccessSettingsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":       v.Id,
			"settings": settings,
		})

	return objVal, diags
}

func (v ConfigsUsersAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsUsersAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v ConfigsUsersAccessValue) Type(ctx context.Context) attr.Type {
	return ConfigsUsersAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsUsersAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id": basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsUsersAccessSettingsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsUsersAccessSettingsType{}

type ConfigsUsersAccessSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsUsersAccessSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsUsersAccessSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsUsersAccessSettingsType) String() string {
	return "ConfigsUsersAccessSettingsType"
}

func (t ConfigsUsersAccessSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsUsersAccessSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersAccessSettingsValueNull() ConfigsUsersAccessSettingsValue {
	return ConfigsUsersAccessSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsUsersAccessSettingsValueUnknown() ConfigsUsersAccessSettingsValue {
	return ConfigsUsersAccessSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsUsersAccessSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsUsersAccessSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsUsersAccessSettingsValue Attribute Value",
				"While creating a ConfigsUsersAccessSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsUsersAccessSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersAccessSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsUsersAccessSettingsValue Attribute Type",
				"While creating a ConfigsUsersAccessSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsUsersAccessSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersAccessSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsUsersAccessSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsUsersAccessSettingsValue Attribute Value",
				"While creating a ConfigsUsersAccessSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsUsersAccessSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsUsersAccessSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsUsersAccessSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsUsersAccessSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsUsersAccessSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsUsersAccessSettingsValueUnknown(), diags
	}

	return ConfigsUsersAccessSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersAccessSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsUsersAccessSettingsValue {
	object, diags := NewConfigsUsersAccessSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsUsersAccessSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsUsersAccessSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsUsersAccessSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsUsersAccessSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsUsersAccessSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsUsersAccessSettingsValueMust(ConfigsUsersAccessSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsUsersAccessSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsUsersAccessSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsUsersAccessSettingsValue{}

type ConfigsUsersAccessSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsUsersAccessSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsUsersAccessSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsUsersAccessSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsUsersAccessSettingsValue) String() string {
	return "ConfigsUsersAccessSettingsValue"
}

func (v ConfigsUsersAccessSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsUsersAccessSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsUsersAccessSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsUsersAccessSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsUsersAccessSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsUsersAccessSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesType{}

type ConfigsWarehousesType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesType) String() string {
	return "ConfigsWarehousesType"
}

func (t ConfigsWarehousesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectionsAttribute, ok := attributes["connections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connections is missing from object`)

		return nil, diags
	}

	connectionsVal, ok := connectionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connections expected to be basetypes.ListValue, was: %T`, connectionsAttribute))
	}

	extensionsAttribute, ok := attributes["extensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extensions is missing from object`)

		return nil, diags
	}

	extensionsVal, ok := extensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extensions expected to be basetypes.ListValue, was: %T`, extensionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesValue{
		Connections: connectionsVal,
		Extensions:  extensionsVal,
		Id:          idVal,
		Name:        nameVal,
		Users:       usersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesValueNull() ConfigsWarehousesValue {
	return ConfigsWarehousesValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesValueUnknown() ConfigsWarehousesValue {
	return ConfigsWarehousesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesValue Attribute Value",
				"While creating a ConfigsWarehousesValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesValue Attribute Type",
				"While creating a ConfigsWarehousesValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesValue Attribute Value",
				"While creating a ConfigsWarehousesValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesValueUnknown(), diags
	}

	connectionsAttribute, ok := attributes["connections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connections is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	connectionsVal, ok := connectionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connections expected to be basetypes.ListValue, was: %T`, connectionsAttribute))
	}

	extensionsAttribute, ok := attributes["extensions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extensions is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	extensionsVal, ok := extensionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extensions expected to be basetypes.ListValue, was: %T`, extensionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesValueUnknown(), diags
	}

	return ConfigsWarehousesValue{
		Connections: connectionsVal,
		Extensions:  extensionsVal,
		Id:          idVal,
		Name:        nameVal,
		Users:       usersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesValue {
	object, diags := NewConfigsWarehousesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesValueMust(ConfigsWarehousesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesValue{}

type ConfigsWarehousesValue struct {
	Connections basetypes.ListValue   `tfsdk:"connections"`
	Extensions  basetypes.ListValue   `tfsdk:"extensions"`
	Id          basetypes.StringValue `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Users       basetypes.ListValue   `tfsdk:"users"`
	state       attr.ValueState
}

func (v ConfigsWarehousesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["connections"] = basetypes.ListType{
		ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["extensions"] = basetypes.ListType{
		ElemType: ConfigsWarehousesExtensionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Connections.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connections"] = val

		val, err = v.Extensions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extensions"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesValue) String() string {
	return "ConfigsWarehousesValue"
}

func (v ConfigsWarehousesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	connections := types.ListValueMust(
		ConfigsWarehousesConnectionsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Connections.Elements(),
	)

	if v.Connections.IsNull() {
		connections = types.ListNull(
			ConfigsWarehousesConnectionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Connections.IsUnknown() {
		connections = types.ListUnknown(
			ConfigsWarehousesConnectionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	extensions := types.ListValueMust(
		ConfigsWarehousesExtensionsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesExtensionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Extensions.Elements(),
	)

	if v.Extensions.IsNull() {
		extensions = types.ListNull(
			ConfigsWarehousesExtensionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesExtensionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Extensions.IsUnknown() {
		extensions = types.ListUnknown(
			ConfigsWarehousesExtensionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesExtensionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var usersVal basetypes.ListValue
	switch {
	case v.Users.IsUnknown():
		usersVal = types.ListUnknown(types.StringType)
	case v.Users.IsNull():
		usersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		usersVal, d = types.ListValue(types.StringType, v.Users.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"connections": basetypes.ListType{
				ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
			},
			"extensions": basetypes.ListType{
				ElemType: ConfigsWarehousesExtensionsValue{}.Type(ctx),
			},
			"id":   basetypes.StringType{},
			"name": basetypes.StringType{},
			"users": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"connections": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
		},
		"extensions": basetypes.ListType{
			ElemType: ConfigsWarehousesExtensionsValue{}.Type(ctx),
		},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connections": connections,
			"extensions":  extensions,
			"id":          v.Id,
			"name":        v.Name,
			"users":       usersVal,
		})

	return objVal, diags
}

func (v ConfigsWarehousesValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Connections.Equal(other.Connections) {
		return false
	}

	if !v.Extensions.Equal(other.Extensions) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	return true
}

func (v ConfigsWarehousesValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connections": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
		},
		"extensions": basetypes.ListType{
			ElemType: ConfigsWarehousesExtensionsValue{}.Type(ctx),
		},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesConnectionsType{}

type ConfigsWarehousesConnectionsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesConnectionsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesConnectionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesConnectionsType) String() string {
	return "ConfigsWarehousesConnectionsType"
}

func (t ConfigsWarehousesConnectionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	plugAttribute, ok := attributes["plug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plug is missing from object`)

		return nil, diags
	}

	plugVal, ok := plugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plug expected to be basetypes.StringValue, was: %T`, plugAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesConnectionsValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Name:      nameVal,
		Plug:      plugVal,
		Settings:  settingsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsValueNull() ConfigsWarehousesConnectionsValue {
	return ConfigsWarehousesConnectionsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesConnectionsValueUnknown() ConfigsWarehousesConnectionsValue {
	return ConfigsWarehousesConnectionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesConnectionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesConnectionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesConnectionsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesConnectionsValue Attribute Type",
				"While creating a ConfigsWarehousesConnectionsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesConnectionsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesConnectionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	plugAttribute, ok := attributes["plug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plug is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	plugVal, ok := plugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plug expected to be basetypes.StringValue, was: %T`, plugAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	return ConfigsWarehousesConnectionsValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Name:      nameVal,
		Plug:      plugVal,
		Settings:  settingsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesConnectionsValue {
	object, diags := NewConfigsWarehousesConnectionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesConnectionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesConnectionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesConnectionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesConnectionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesConnectionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesConnectionsValueMust(ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesConnectionsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesConnectionsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesConnectionsValue{}

type ConfigsWarehousesConnectionsValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Id        basetypes.StringValue `tfsdk:"id"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Plug      basetypes.StringValue `tfsdk:"plug"`
	Settings  basetypes.ListValue   `tfsdk:"settings"`
	state     attr.ValueState
}

func (v ConfigsWarehousesConnectionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Plug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plug"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesConnectionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesConnectionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesConnectionsValue) String() string {
	return "ConfigsWarehousesConnectionsValue"
}

func (v ConfigsWarehousesConnectionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsWarehousesConnectionsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsWarehousesConnectionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsWarehousesConnectionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"name":       basetypes.StringType{},
		"plug":       basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"name":       v.Name,
			"plug":       v.Plug,
			"settings":   settings,
		})

	return objVal, diags
}

func (v ConfigsWarehousesConnectionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesConnectionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Plug.Equal(other.Plug) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v ConfigsWarehousesConnectionsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesConnectionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesConnectionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"name":       basetypes.StringType{},
		"plug":       basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesConnectionsSettingsType{}

type ConfigsWarehousesConnectionsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesConnectionsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesConnectionsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesConnectionsSettingsType) String() string {
	return "ConfigsWarehousesConnectionsSettingsType"
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesConnectionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsSettingsValueNull() ConfigsWarehousesConnectionsSettingsValue {
	return ConfigsWarehousesConnectionsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesConnectionsSettingsValueUnknown() ConfigsWarehousesConnectionsSettingsValue {
	return ConfigsWarehousesConnectionsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesConnectionsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesConnectionsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesConnectionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesConnectionsSettingsValue Attribute Type",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesConnectionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesConnectionsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	return ConfigsWarehousesConnectionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesConnectionsSettingsValue {
	object, diags := NewConfigsWarehousesConnectionsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesConnectionsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesConnectionsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesConnectionsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesConnectionsSettingsValueMust(ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesConnectionsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesConnectionsSettingsValue{}

type ConfigsWarehousesConnectionsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsWarehousesConnectionsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesConnectionsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesConnectionsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesConnectionsSettingsValue) String() string {
	return "ConfigsWarehousesConnectionsSettingsValue"
}

func (v ConfigsWarehousesConnectionsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsWarehousesConnectionsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesConnectionsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsWarehousesConnectionsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesConnectionsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesConnectionsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesExtensionsType{}

type ConfigsWarehousesExtensionsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesExtensionsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesExtensionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesExtensionsType) String() string {
	return "ConfigsWarehousesExtensionsType"
}

func (t ConfigsWarehousesExtensionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesExtensionsValue{
		CreatedAt:                       createdAtVal,
		Id:                              idVal,
		Settings:                        settingsVal,
		ConfigsWarehousesExtensionsType: typeVal,
		Version:                         versionVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesExtensionsValueNull() ConfigsWarehousesExtensionsValue {
	return ConfigsWarehousesExtensionsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesExtensionsValueUnknown() ConfigsWarehousesExtensionsValue {
	return ConfigsWarehousesExtensionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesExtensionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesExtensionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesExtensionsValue Attribute Value",
				"While creating a ConfigsWarehousesExtensionsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesExtensionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesExtensionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesExtensionsValue Attribute Type",
				"While creating a ConfigsWarehousesExtensionsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesExtensionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesExtensionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesExtensionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesExtensionsValue Attribute Value",
				"While creating a ConfigsWarehousesExtensionsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesExtensionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesExtensionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesExtensionsValueUnknown(), diags
	}

	return ConfigsWarehousesExtensionsValue{
		CreatedAt:                       createdAtVal,
		Id:                              idVal,
		Settings:                        settingsVal,
		ConfigsWarehousesExtensionsType: typeVal,
		Version:                         versionVal,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesExtensionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesExtensionsValue {
	object, diags := NewConfigsWarehousesExtensionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesExtensionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesExtensionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesExtensionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesExtensionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesExtensionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesExtensionsValueMust(ConfigsWarehousesExtensionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesExtensionsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesExtensionsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesExtensionsValue{}

type ConfigsWarehousesExtensionsValue struct {
	CreatedAt                       basetypes.StringValue `tfsdk:"created_at"`
	Id                              basetypes.StringValue `tfsdk:"id"`
	Settings                        basetypes.ListValue   `tfsdk:"settings"`
	ConfigsWarehousesExtensionsType basetypes.StringValue `tfsdk:"type"`
	Version                         basetypes.StringValue `tfsdk:"version"`
	state                           attr.ValueState
}

func (v ConfigsWarehousesExtensionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsWarehousesExtensionsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		val, err = v.ConfigsWarehousesExtensionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesExtensionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesExtensionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesExtensionsValue) String() string {
	return "ConfigsWarehousesExtensionsValue"
}

func (v ConfigsWarehousesExtensionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsWarehousesExtensionsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesExtensionsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsWarehousesExtensionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesExtensionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsWarehousesExtensionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesExtensionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesExtensionsSettingsValue{}.Type(ctx),
		},
		"type":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"settings":   settings,
			"type":       v.ConfigsWarehousesExtensionsType,
			"version":    v.Version,
		})

	return objVal, diags
}

func (v ConfigsWarehousesExtensionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesExtensionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	if !v.ConfigsWarehousesExtensionsType.Equal(other.ConfigsWarehousesExtensionsType) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v ConfigsWarehousesExtensionsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesExtensionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesExtensionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesExtensionsSettingsValue{}.Type(ctx),
		},
		"type":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesExtensionsSettingsType{}

type ConfigsWarehousesExtensionsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesExtensionsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesExtensionsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesExtensionsSettingsType) String() string {
	return "ConfigsWarehousesExtensionsSettingsType"
}

func (t ConfigsWarehousesExtensionsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesExtensionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesExtensionsSettingsValueNull() ConfigsWarehousesExtensionsSettingsValue {
	return ConfigsWarehousesExtensionsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesExtensionsSettingsValueUnknown() ConfigsWarehousesExtensionsSettingsValue {
	return ConfigsWarehousesExtensionsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesExtensionsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesExtensionsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesExtensionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesExtensionsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesExtensionsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesExtensionsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesExtensionsSettingsValue Attribute Type",
				"While creating a ConfigsWarehousesExtensionsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesExtensionsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesExtensionsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesExtensionsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesExtensionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesExtensionsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesExtensionsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesExtensionsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesExtensionsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsWarehousesExtensionsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsWarehousesExtensionsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesExtensionsSettingsValueUnknown(), diags
	}

	return ConfigsWarehousesExtensionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesExtensionsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesExtensionsSettingsValue {
	object, diags := NewConfigsWarehousesExtensionsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesExtensionsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesExtensionsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesExtensionsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesExtensionsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesExtensionsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesExtensionsSettingsValueMust(ConfigsWarehousesExtensionsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesExtensionsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesExtensionsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesExtensionsSettingsValue{}

type ConfigsWarehousesExtensionsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsWarehousesExtensionsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesExtensionsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesExtensionsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesExtensionsSettingsValue) String() string {
	return "ConfigsWarehousesExtensionsSettingsValue"
}

func (v ConfigsWarehousesExtensionsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsWarehousesExtensionsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesExtensionsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsWarehousesExtensionsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesExtensionsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesExtensionsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InfoType{}

type InfoType struct {
	basetypes.ObjectType
}

func (t InfoType) Equal(o attr.Type) bool {
	other, ok := o.(InfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoType) String() string {
	return "InfoType"
}

func (t InfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoValue{
		Services: servicesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewInfoValueNull() InfoValue {
	return InfoValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoValueUnknown() InfoValue {
	return InfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoValue Attribute Value",
				"While creating a InfoValue value, a missing attribute value was detected. "+
					"A InfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoValue Attribute Type",
				"While creating a InfoValue value, an invalid attribute value was detected. "+
					"A InfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoValue Attribute Value",
				"While creating a InfoValue value, an extra attribute value was detected. "+
					"A InfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewInfoValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	return InfoValue{
		Services: servicesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoValue {
	object, diags := NewInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoValueMust(InfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoType) ValueType(ctx context.Context) attr.Value {
	return InfoValue{}
}

var _ basetypes.ObjectValuable = InfoValue{}

type InfoValue struct {
	Services basetypes.ListValue `tfsdk:"services"`
	state    attr.ValueState
}

func (v InfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["services"] = basetypes.ListType{
		ElemType: InfoServicesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoValue) String() string {
	return "InfoValue"
}

func (v InfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	services := types.ListValueMust(
		InfoServicesType{
			basetypes.ObjectType{
				AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Services.Elements(),
	)

	if v.Services.IsNull() {
		services = types.ListNull(
			InfoServicesType{
				basetypes.ObjectType{
					AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Services.IsUnknown() {
		services = types.ListUnknown(
			InfoServicesType{
				basetypes.ObjectType{
					AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"services": basetypes.ListType{
			ElemType: InfoServicesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"services": services,
		})

	return objVal, diags
}

func (v InfoValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	return true
}

func (v InfoValue) Type(ctx context.Context) attr.Type {
	return InfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"services": basetypes.ListType{
			ElemType: InfoServicesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = InfoServicesType{}

type InfoServicesType struct {
	basetypes.ObjectType
}

func (t InfoServicesType) Equal(o attr.Type) bool {
	other, ok := o.(InfoServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoServicesType) String() string {
	return "InfoServicesType"
}

func (t InfoServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return nil, diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exposedAttribute, ok := attributes["exposed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exposed is missing from object`)

		return nil, diags
	}

	exposedVal, ok := exposedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exposed expected to be basetypes.BoolValue, was: %T`, exposedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoServicesValue{
		ConnectionString: connectionStringVal,
		Description:      descriptionVal,
		Exposed:          exposedVal,
		InfoServicesType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInfoServicesValueNull() InfoServicesValue {
	return InfoServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoServicesValueUnknown() InfoServicesValue {
	return InfoServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoServicesValue Attribute Value",
				"While creating a InfoServicesValue value, a missing attribute value was detected. "+
					"A InfoServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoServicesValue Attribute Type",
				"While creating a InfoServicesValue value, an invalid attribute value was detected. "+
					"A InfoServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoServicesValue Attribute Value",
				"While creating a InfoServicesValue value, an extra attribute value was detected. "+
					"A InfoServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoServicesValueUnknown(), diags
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exposedAttribute, ok := attributes["exposed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exposed is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	exposedVal, ok := exposedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exposed expected to be basetypes.BoolValue, was: %T`, exposedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewInfoServicesValueUnknown(), diags
	}

	return InfoServicesValue{
		ConnectionString: connectionStringVal,
		Description:      descriptionVal,
		Exposed:          exposedVal,
		InfoServicesType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInfoServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoServicesValue {
	object, diags := NewInfoServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoServicesValueMust(InfoServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoServicesType) ValueType(ctx context.Context) attr.Value {
	return InfoServicesValue{}
}

var _ basetypes.ObjectValuable = InfoServicesValue{}

type InfoServicesValue struct {
	ConnectionString basetypes.StringValue `tfsdk:"connection_string"`
	Description      basetypes.StringValue `tfsdk:"description"`
	Exposed          basetypes.BoolValue   `tfsdk:"exposed"`
	InfoServicesType basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v InfoServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connection_string"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exposed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectionString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_string"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Exposed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exposed"] = val

		val, err = v.InfoServicesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoServicesValue) String() string {
	return "InfoServicesValue"
}

func (v InfoServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connection_string": basetypes.StringType{},
		"description":       basetypes.StringType{},
		"exposed":           basetypes.BoolType{},
		"type":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connection_string": v.ConnectionString,
			"description":       v.Description,
			"exposed":           v.Exposed,
			"type":              v.InfoServicesType,
		})

	return objVal, diags
}

func (v InfoServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectionString.Equal(other.ConnectionString) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Exposed.Equal(other.Exposed) {
		return false
	}

	if !v.InfoServicesType.Equal(other.InfoServicesType) {
		return false
	}

	return true
}

func (v InfoServicesValue) Type(ctx context.Context) attr.Type {
	return InfoServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connection_string": basetypes.StringType{},
		"description":       basetypes.StringType{},
		"exposed":           basetypes.BoolType{},
		"type":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodGroupsType{}

type PodGroupsType struct {
	basetypes.ObjectType
}

func (t PodGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsType) String() string {
	return "PodGroupsType"
}

func (t PodGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return nil, diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	floatingIpPoolAttribute, ok := attributes["floating_ip_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_pool is missing from object`)

		return nil, diags
	}

	floatingIpPoolVal, ok := floatingIpPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_pool expected to be basetypes.StringValue, was: %T`, floatingIpPoolAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProcessesAttribute, ok := attributes["node_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_processes is missing from object`)

		return nil, diags
	}

	nodeProcessesVal, ok := nodeProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_processes expected to be basetypes.ListValue, was: %T`, nodeProcessesAttribute))
	}

	podGroupTemplateIdAttribute, ok := attributes["pod_group_template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_group_template_id is missing from object`)

		return nil, diags
	}

	podGroupTemplateIdVal, ok := podGroupTemplateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_group_template_id expected to be basetypes.StringValue, was: %T`, podGroupTemplateIdAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsValue{
		Alias:              aliasVal,
		AvailabilityZone:   availabilityZoneVal,
		Count:              countVal,
		FloatingIpPool:     floatingIpPoolVal,
		Id:                 idVal,
		Name:               nameVal,
		NodeProcesses:      nodeProcessesVal,
		PodGroupTemplateId: podGroupTemplateIdVal,
		Resource:           resourceVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueNull() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsValueUnknown() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, a missing attribute value was detected. "+
					"A PodGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsValue Attribute Type",
				"While creating a PodGroupsValue value, an invalid attribute value was detected. "+
					"A PodGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, an extra attribute value was detected. "+
					"A PodGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	floatingIpPoolAttribute, ok := attributes["floating_ip_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_pool is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	floatingIpPoolVal, ok := floatingIpPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_pool expected to be basetypes.StringValue, was: %T`, floatingIpPoolAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeProcessesAttribute, ok := attributes["node_processes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_processes is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	nodeProcessesVal, ok := nodeProcessesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_processes expected to be basetypes.ListValue, was: %T`, nodeProcessesAttribute))
	}

	podGroupTemplateIdAttribute, ok := attributes["pod_group_template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_group_template_id is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	podGroupTemplateIdVal, ok := podGroupTemplateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_group_template_id expected to be basetypes.StringValue, was: %T`, podGroupTemplateIdAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	return PodGroupsValue{
		Alias:              aliasVal,
		AvailabilityZone:   availabilityZoneVal,
		Count:              countVal,
		FloatingIpPool:     floatingIpPoolVal,
		Id:                 idVal,
		Name:               nameVal,
		NodeProcesses:      nodeProcessesVal,
		PodGroupTemplateId: podGroupTemplateIdVal,
		Resource:           resourceVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsValue {
	object, diags := NewPodGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsValueMust(PodGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsValue{}
}

var _ basetypes.ObjectValuable = PodGroupsValue{}

type PodGroupsValue struct {
	Alias              basetypes.StringValue `tfsdk:"alias"`
	AvailabilityZone   basetypes.StringValue `tfsdk:"availability_zone"`
	Count              basetypes.Int64Value  `tfsdk:"count"`
	FloatingIpPool     basetypes.StringValue `tfsdk:"floating_ip_pool"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	Name               basetypes.StringValue `tfsdk:"name"`
	NodeProcesses      basetypes.ListValue   `tfsdk:"node_processes"`
	PodGroupTemplateId basetypes.StringValue `tfsdk:"pod_group_template_id"`
	Resource           basetypes.ObjectValue `tfsdk:"resource"`
	Volumes            basetypes.MapValue    `tfsdk:"volumes"`
	state              attr.ValueState
}

func (v PodGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["availability_zone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["floating_ip_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_processes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["pod_group_template_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.MapType{
		ElemType: PodGroupsVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.AvailabilityZone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zone"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.FloatingIpPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip_pool"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeProcesses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_processes"] = val

		val, err = v.PodGroupTemplateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_group_template_id"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsValue) String() string {
	return "PodGroupsValue"
}

func (v PodGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	volumes := types.MapValueMust(
		PodGroupsVolumesType{
			basetypes.ObjectType{
				AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.MapNull(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.MapUnknown(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var nodeProcessesVal basetypes.ListValue
	switch {
	case v.NodeProcesses.IsUnknown():
		nodeProcessesVal = types.ListUnknown(types.StringType)
	case v.NodeProcesses.IsNull():
		nodeProcessesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeProcessesVal, d = types.ListValue(types.StringType, v.NodeProcesses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"alias":             basetypes.StringType{},
			"availability_zone": basetypes.StringType{},
			"count":             basetypes.Int64Type{},
			"floating_ip_pool":  basetypes.StringType{},
			"id":                basetypes.StringType{},
			"name":              basetypes.StringType{},
			"node_processes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"pod_group_template_id": basetypes.StringType{},
			"resource": basetypes.ObjectType{
				AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
			},
			"volumes": basetypes.MapType{
				ElemType: PodGroupsVolumesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"alias":             basetypes.StringType{},
		"availability_zone": basetypes.StringType{},
		"count":             basetypes.Int64Type{},
		"floating_ip_pool":  basetypes.StringType{},
		"id":                basetypes.StringType{},
		"name":              basetypes.StringType{},
		"node_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pod_group_template_id": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias":                 v.Alias,
			"availability_zone":     v.AvailabilityZone,
			"count":                 v.Count,
			"floating_ip_pool":      v.FloatingIpPool,
			"id":                    v.Id,
			"name":                  v.Name,
			"node_processes":        nodeProcessesVal,
			"pod_group_template_id": v.PodGroupTemplateId,
			"resource":              resource,
			"volumes":               volumes,
		})

	return objVal, diags
}

func (v PodGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.AvailabilityZone.Equal(other.AvailabilityZone) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.FloatingIpPool.Equal(other.FloatingIpPool) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeProcesses.Equal(other.NodeProcesses) {
		return false
	}

	if !v.PodGroupTemplateId.Equal(other.PodGroupTemplateId) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v PodGroupsValue) Type(ctx context.Context) attr.Type {
	return PodGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":             basetypes.StringType{},
		"availability_zone": basetypes.StringType{},
		"count":             basetypes.Int64Type{},
		"floating_ip_pool":  basetypes.StringType{},
		"id":                basetypes.StringType{},
		"name":              basetypes.StringType{},
		"node_processes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pod_group_template_id": basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PodGroupsResourceType{}

type PodGroupsResourceType struct {
	basetypes.ObjectType
}

func (t PodGroupsResourceType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsResourceType) String() string {
	return "PodGroupsResourceType"
}

func (t PodGroupsResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuLimitAttribute, ok := attributes["cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_limit is missing from object`)

		return nil, diags
	}

	cpuLimitVal, ok := cpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_limit expected to be basetypes.StringValue, was: %T`, cpuLimitAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return nil, diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramLimitAttribute, ok := attributes["ram_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_limit is missing from object`)

		return nil, diags
	}

	ramLimitVal, ok := ramLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_limit expected to be basetypes.StringValue, was: %T`, ramLimitAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return nil, diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsResourceValue{
		CpuLimit:   cpuLimitVal,
		CpuRequest: cpuRequestVal,
		RamLimit:   ramLimitVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueNull() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsResourceValueUnknown() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, a missing attribute value was detected. "+
					"A PodGroupsResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsResourceValue Attribute Type",
				"While creating a PodGroupsResourceValue value, an invalid attribute value was detected. "+
					"A PodGroupsResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, an extra attribute value was detected. "+
					"A PodGroupsResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuLimitAttribute, ok := attributes["cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_limit is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuLimitVal, ok := cpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_limit expected to be basetypes.StringValue, was: %T`, cpuLimitAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramLimitAttribute, ok := attributes["ram_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_limit is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramLimitVal, ok := ramLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_limit expected to be basetypes.StringValue, was: %T`, ramLimitAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	return PodGroupsResourceValue{
		CpuLimit:   cpuLimitVal,
		CpuRequest: cpuRequestVal,
		RamLimit:   ramLimitVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsResourceValue {
	object, diags := NewPodGroupsResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsResourceValueMust(PodGroupsResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsResourceType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsResourceValue{}
}

var _ basetypes.ObjectValuable = PodGroupsResourceValue{}

type PodGroupsResourceValue struct {
	CpuLimit   basetypes.StringValue `tfsdk:"cpu_limit"`
	CpuRequest basetypes.StringValue `tfsdk:"cpu_request"`
	RamLimit   basetypes.StringValue `tfsdk:"ram_limit"`
	RamRequest basetypes.StringValue `tfsdk:"ram_request"`
	state      attr.ValueState
}

func (v PodGroupsResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_request"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_request"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_limit"] = val

		val, err = v.CpuRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_request"] = val

		val, err = v.RamLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_limit"] = val

		val, err = v.RamRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_request"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsResourceValue) String() string {
	return "PodGroupsResourceValue"
}

func (v PodGroupsResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_limit":   basetypes.StringType{},
		"cpu_request": basetypes.StringType{},
		"ram_limit":   basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_limit":   v.CpuLimit,
			"cpu_request": v.CpuRequest,
			"ram_limit":   v.RamLimit,
			"ram_request": v.RamRequest,
		})

	return objVal, diags
}

func (v PodGroupsResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuLimit.Equal(other.CpuLimit) {
		return false
	}

	if !v.CpuRequest.Equal(other.CpuRequest) {
		return false
	}

	if !v.RamLimit.Equal(other.RamLimit) {
		return false
	}

	if !v.RamRequest.Equal(other.RamRequest) {
		return false
	}

	return true
}

func (v PodGroupsResourceValue) Type(ctx context.Context) attr.Type {
	return PodGroupsResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_limit":   basetypes.StringType{},
		"cpu_request": basetypes.StringType{},
		"ram_limit":   basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodGroupsVolumesType{}

type PodGroupsVolumesType struct {
	basetypes.ObjectType
}

func (t PodGroupsVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsVolumesType) String() string {
	return "PodGroupsVolumesType"
}

func (t PodGroupsVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return nil, diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueNull() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsVolumesValueUnknown() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, a missing attribute value was detected. "+
					"A PodGroupsVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsVolumesValue Attribute Type",
				"While creating a PodGroupsVolumesValue value, an invalid attribute value was detected. "+
					"A PodGroupsVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, an extra attribute value was detected. "+
					"A PodGroupsVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsVolumesValue {
	object, diags := NewPodGroupsVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsVolumesValueMust(PodGroupsVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsVolumesType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsVolumesValue{}
}

var _ basetypes.ObjectValuable = PodGroupsVolumesValue{}

type PodGroupsVolumesValue struct {
	Count            basetypes.Int64Value  `tfsdk:"count"`
	Storage          basetypes.StringValue `tfsdk:"storage"`
	StorageClassName basetypes.StringValue `tfsdk:"storage_class_name"`
	state            attr.ValueState
}

func (v PodGroupsVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		val, err = v.StorageClassName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsVolumesValue) String() string {
	return "PodGroupsVolumesValue"
}

func (v PodGroupsVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":              v.Count,
			"storage":            v.Storage,
			"storage_class_name": v.StorageClassName,
		})

	return objVal, diags
}

func (v PodGroupsVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	if !v.StorageClassName.Equal(other.StorageClassName) {
		return false
	}

	return true
}

func (v PodGroupsVolumesValue) Type(ctx context.Context) attr.Type {
	return PodGroupsVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}
}
