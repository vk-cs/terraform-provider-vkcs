// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_cluster

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	cluster_planmodifiers "github.com/vk-cs/terraform-provider-vkcs/vkcs/dataplatform/resource_cluster/planmodifiers"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ClusterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"availability_zone": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Availability zone to create cluster in. Changing this creates a new resource.",
				MarkdownDescription: "Availability zone to create cluster in. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtMost(255),
				},
			},
			"cluster_template_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cluster template. Changing this creates a new resource.",
				MarkdownDescription: "ID of the cluster template. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"configs": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"maintenance": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"backup": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"differential": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether differential backup is enabled.",
												MarkdownDescription: "Whether differential backup is enabled.",
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Differential backup schedule. Changing this creates a new resource.",
												MarkdownDescription: "Differential backup schedule. Changing this creates a new resource.",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), ""),
												},
											},
										},
										CustomType: ConfigsMaintenanceBackupDifferentialType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Differential backup settings. Changing this creates a new resource.",
										MarkdownDescription: "Differential backup settings. Changing this creates a new resource.",
									},
									"full": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether full backup is enabled.",
												MarkdownDescription: "Whether full backup is enabled.",
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Full backup schedule. Changing this creates a new resource.",
												MarkdownDescription: "Full backup schedule. Changing this creates a new resource.",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), "")},
											},
										},
										CustomType: ConfigsMaintenanceBackupFullType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Full backup settings. Changing this creates a new resource.",
										MarkdownDescription: "Full backup settings. Changing this creates a new resource.",
									},
									"incremental": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether incremental backup is enabled.",
												MarkdownDescription: "Whether incremental backup is enabled.",
											},
											"keep_count": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"keep_time": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.StringAttribute{
												Required:            true,
												Description:         "Incremental backup schedule. Changing this creates a new resource.",
												MarkdownDescription: "Incremental backup schedule. Changing this creates a new resource.",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
												Validators: []validator.String{
													stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), "")},
											},
										},
										CustomType: ConfigsMaintenanceBackupIncrementalType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Incremental backup settings. Changing this creates a new resource.",
										MarkdownDescription: "Incremental backup settings. Changing this creates a new resource.",
									},
								},
								CustomType: ConfigsMaintenanceBackupType{
									ObjectType: types.ObjectType{
										AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Backup settings. Changing this creates a new resource.",
								MarkdownDescription: "Backup settings. Changing this creates a new resource.",
							},
							"crontabs": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Computed: true,
										},
										"name": schema.StringAttribute{
											Required:            true,
											Description:         "Cron tab name. Changing this creates a new resource.",
											MarkdownDescription: "Cron tab name. Changing this creates a new resource.",
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplace(),
											},
										},
										"required": schema.BoolAttribute{
											Computed:            true,
											Description:         "Whether cron tab is required.",
											MarkdownDescription: "Whether cron tab is required.",
										},
										"settings": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"alias": schema.StringAttribute{
														Required:            true,
														Description:         "Setting alias. Changing this creates a new resource.",
														MarkdownDescription: "Setting alias. Changing this creates a new resource.",
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.RequiresReplace(),
														},
													},
													"value": schema.StringAttribute{
														Required:            true,
														Description:         "Setting value. Changing this creates a new resource.",
														MarkdownDescription: "Setting value. Changing this creates a new resource.",
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.RequiresReplace(),
														},
													},
												},
												CustomType: ConfigsMaintenanceCrontabsSettingsType{
													ObjectType: types.ObjectType{
														AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Additional cron settings. Changing this creates a new resource.",
											MarkdownDescription: "Additional cron settings. Changing this creates a new resource.",
										},
										"start": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Cron tab schedule. Changing this creates a new resource.",
											MarkdownDescription: "Cron tab schedule. Changing this creates a new resource.",
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
											},
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), "")},
										},
									},
									CustomType: ConfigsMaintenanceCrontabsType{
										ObjectType: types.ObjectType{
											AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Cron tabs settings. Changing this creates a new resource.",
								MarkdownDescription: "Cron tabs settings. Changing this creates a new resource.",
							},
							"start": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Maintenance cron schedule. Changing this creates a new resource.",
								MarkdownDescription: "Maintenance cron schedule. Changing this creates a new resource.",
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplace(),
								},
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile("^(\\*|\\*/\\d+|(?:0?[0-9]|[1-5][0-9])(?:-(?:0?[0-9]|[1-5][0-9])(?:/\\d+)?|(?:,(?:0?[0-9]|[1-5][0-9]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[0-9]|1[0-9]|2[0-3])(?:-(?:0?[0-9]|1[0-9]|2[0-3])(?:/\\d+)?|(?:,(?:0?[0-9]|1[0-9]|2[0-3]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|[12][0-9]|3[01])(?:-(?:0?[1-9]|[12][0-9]|3[01])(?:/\\d+)?|(?:,(?:0?[1-9]|[12][0-9]|3[01]))*)?)\\s+(\\*|\\*/\\d+|(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:-(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)(?:/\\d+)?|(?:,(?:0?[1-9]|1[0-2]|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC))*)?)\\s+(\\*|\\*/\\d+|(?:[0-6]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:-(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT)(?:/\\d+)?|(?:,(?:[0-7]|SUN|MON|TUE|WED|THU|FRI|SAT))*)?)$"), "")},
							},
						},
						CustomType: ConfigsMaintenanceType{
							ObjectType: types.ObjectType{
								AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
							},
						},
						Required:            true,
						Description:         "Maintenance settings. Changing this creates a new resource.",
						MarkdownDescription: "Maintenance settings. Changing this creates a new resource.",
					},
					"settings": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"alias": schema.StringAttribute{
									Required:            true,
									Description:         "Setting alias.",
									MarkdownDescription: "Setting alias.",
								},
								"value": schema.StringAttribute{
									Required:            true,
									Description:         "Setting value.",
									MarkdownDescription: "Setting value.",
								},
							},
							CustomType: ConfigsSettingsType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Additional common settings.",
						MarkdownDescription: "Additional common settings.",
					},
					"users": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"password": schema.StringAttribute{
									Required:            true,
									Sensitive:           true,
									Description:         "Password. Changing this creates a new resource.",
									MarkdownDescription: "Password. Changing this creates a new resource.",
									PlanModifiers: []planmodifier.String{
										cluster_planmodifiers.RequiresReplaceIfWasPresent(),
									},
									Validators: []validator.String{
										stringvalidator.LengthBetween(16, 50),
										stringvalidator.RegexMatches(regexp.MustCompile("^[^'`:;,.@&<>' ]+$"), ""),
									},
								},
								"role": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "User role. Changing this creates a new resource.",
									MarkdownDescription: "User role. Changing this creates a new resource.",
									PlanModifiers: []planmodifier.String{
										cluster_planmodifiers.RequiresReplaceIfWasPresent(),
									},
									Validators: []validator.String{
										stringvalidator.LengthAtMost(80),
									},
								},
								"username": schema.StringAttribute{
									Required:            true,
									Description:         "Username",
									MarkdownDescription: "Username",
									Validators: []validator.String{
										stringvalidator.LengthAtMost(128),
									},
								},
							},
							CustomType: ConfigsUsersType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Users settings.",
						MarkdownDescription: "Users settings.",
					},
					"warehouses": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"connections": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"created_at": schema.StringAttribute{
												Computed:            true,
												Description:         "Connection creation timestamp.",
												MarkdownDescription: "Connection creation timestamp.",
											},
											"id": schema.StringAttribute{
												Computed:            true,
												Description:         "Connection ID.",
												MarkdownDescription: "Connection ID.",
											},
											"name": schema.StringAttribute{
												Required:            true,
												Description:         "Connection name. Changing this creates a new resource.",
												MarkdownDescription: "Connection name. Changing this creates a new resource.",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"plug": schema.StringAttribute{
												Required:            true,
												Description:         "Connection plug. Changing this creates a new resource.",
												MarkdownDescription: "Connection plug. Changing this creates a new resource.",
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.RequiresReplace(),
												},
												Validators: []validator.String{
													stringvalidator.LengthAtMost(255),
												},
											},
											"settings": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"alias": schema.StringAttribute{
															Required:            true,
															Description:         "Setting alias. Changing this creates a new resource.",
															MarkdownDescription: "Setting alias. Changing this creates a new resource.",
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.RequiresReplace(),
															},
															Validators: []validator.String{
																stringvalidator.LengthAtMost(80),
															},
														},
														"value": schema.StringAttribute{
															Required:            true,
															Description:         "Setting value. Changing this creates a new resource.",
															MarkdownDescription: "Setting value. Changing this creates a new resource.",
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.RequiresReplace(),
															},
															Validators: []validator.String{
																stringvalidator.LengthAtMost(255),
															},
														},
													},
													CustomType: ConfigsWarehousesConnectionsSettingsType{
														ObjectType: types.ObjectType{
															AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
														},
													},
												},
												Required:            true,
												Description:         "Additional warehouse settings. Changing this creates a new resource.",
												MarkdownDescription: "Additional warehouse settings. Changing this creates a new resource.",
											},
										},
										CustomType: ConfigsWarehousesConnectionsType{
											ObjectType: types.ObjectType{
												AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse connections. Changing this creates a new resource.",
									MarkdownDescription: "Warehouse connections. Changing this creates a new resource.",
								},
								"id": schema.StringAttribute{
									Computed:            true,
									Description:         "Warehouse ID.",
									MarkdownDescription: "Warehouse ID.",
								},
								"name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Warehouse name. Changing this creates a new resource.",
									MarkdownDescription: "Warehouse name. Changing this creates a new resource.",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
									Validators: []validator.String{
										stringvalidator.LengthAtMost(63),
										stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_]+$"), ""),
									},
								},
							},
							CustomType: ConfigsWarehousesType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Warehouses settings. Changing this creates a new resource.",
						MarkdownDescription: "Warehouses settings. Changing this creates a new resource.",
					},
				},
				CustomType: ConfigsType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfigsValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Product configuration.",
				MarkdownDescription: "Product configuration.",
			},
			"created_at": schema.StringAttribute{
				Computed:            true,
				Description:         "Cluster creation timestamp.",
				MarkdownDescription: "Cluster creation timestamp.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Cluster description.",
				MarkdownDescription: "Cluster description.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(255),
				},
				Default: stringdefault.StaticString(""),
			},
			"floating_ip_pool": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Floating IP pool ID. Use `auto` for autoselect. Changing this creates a new resource.",
				MarkdownDescription: "Floating IP pool ID. Use `auto` for autoselect. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "ID of the cluster.",
				MarkdownDescription: "ID of the cluster.",
			},
			"info": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"services": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"connection_string": schema.StringAttribute{
									Computed:            true,
									Description:         "Service connection string",
									MarkdownDescription: "Service connection string",
								},
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "Service description",
									MarkdownDescription: "Service description",
								},
								"exposed": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether service is exposed",
									MarkdownDescription: "Whether service is exposed",
								},
								"type": schema.StringAttribute{
									Computed:            true,
									Description:         "Service type",
									MarkdownDescription: "Service type",
								},
							},
							CustomType: InfoServicesType{
								ObjectType: types.ObjectType{
									AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Application services info",
						MarkdownDescription: "Application services info",
					},
				},
				CustomType: InfoType{
					ObjectType: types.ObjectType{
						AttrTypes: InfoValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Application info",
				MarkdownDescription: "Application info",
			},
			"multiaz": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enables multi az support. Changing this creates a new resource.",
				MarkdownDescription: "Enables multi az support. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Default: booldefault.StaticBool(false),
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the cluster.",
				MarkdownDescription: "Name of the cluster.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 60),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Zа-яА-Я0-9][a-zA-Zа-яА-Я0-9-_]*$"), ""),
				},
			},
			"network_id": schema.StringAttribute{
				Required:            true,
				Description:         "ID of the cluster network. Changing this creates a new resource.",
				MarkdownDescription: "ID of the cluster network. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"pod_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alias": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group alias.",
							MarkdownDescription: "Pod group alias.",
						},
						"availability_zone": schema.StringAttribute{
							Computed: true,
						},
						"count": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Pod count.",
							MarkdownDescription: "Pod count.",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
						},
						"floating_ip_pool": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Floating IP pool ID. Changing this creates a new resource.",
							MarkdownDescription: "Floating IP pool ID. Changing this creates a new resource.",
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.RequiresReplaceIfConfigured(),
							},
							Validators: []validator.String{
								stringvalidator.LengthAtMost(36),
							},
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group ID.",
							MarkdownDescription: "Pod group ID.",
						},
						"name": schema.StringAttribute{
							Required:            true,
							Description:         "Pod group name.",
							MarkdownDescription: "Pod group name.",
						},
						"resource": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"cpu_limit": schema.StringAttribute{
									Computed:            true,
									Description:         "CPU limit.",
									MarkdownDescription: "CPU limit.",
								},
								"cpu_request": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Resource request settings. Changing this creates a new resource.",
									MarkdownDescription: "Resource request settings. Changing this creates a new resource.",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^\\d*\\.?\\d*$"), ""),
									},
								},
								"ram_limit": schema.StringAttribute{
									Computed:            true,
									Description:         "RAM limit settings.",
									MarkdownDescription: "RAM limit settings.",
								},
								"ram_request": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "RAM request settings. Changing this creates a new resource.",
									MarkdownDescription: "RAM request settings. Changing this creates a new resource.",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.RequiresReplace(),
									},
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^\\d*\\.?\\d*$"), ""),
									},
								},
							},
							CustomType: PodGroupsResourceType{
								ObjectType: types.ObjectType{
									AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Resource request settings. Changing this creates a new resource.",
							MarkdownDescription: "Resource request settings. Changing this creates a new resource.",
						},
						"volumes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"count": schema.Int64Attribute{
										Required:            true,
										Description:         "Volume count. Changing this creates a new resource.",
										MarkdownDescription: "Volume count. Changing this creates a new resource.",
										PlanModifiers: []planmodifier.Int64{
											int64planmodifier.RequiresReplace(),
										},
									},
									"storage": schema.StringAttribute{
										Required:            true,
										Description:         "Storage size. Changing this creates a new resource.",
										MarkdownDescription: "Storage size. Changing this creates a new resource.",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile("^(\\d+|(\\d+)G)$"), ""),
										},
									},
									"storage_class_name": schema.StringAttribute{
										Required:            true,
										Description:         "Storage class name. Changing this creates a new resource.",
										MarkdownDescription: "Storage class name. Changing this creates a new resource.",
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplace(),
										},
										Validators: []validator.String{
											stringvalidator.LengthAtMost(255),
										},
									},
								},
								CustomType: PodGroupsVolumesType{
									ObjectType: types.ObjectType{
										AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Volumes settings. Changing this creates a new resource.",
							MarkdownDescription: "Volumes settings. Changing this creates a new resource.",
						},
					},
					CustomType: PodGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: PodGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Cluster pod groups. Changing this creates a new resource.",
				MarkdownDescription: "Cluster pod groups. Changing this creates a new resource.",
			},
			"product_name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the product.",
				MarkdownDescription: "Name of the product.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(80),
				},
			},
			"product_type": schema.StringAttribute{
				Computed:            true,
				Description:         "Type of the product.",
				MarkdownDescription: "Type of the product.",
			},
			"product_version": schema.StringAttribute{
				Required:            true,
				Description:         "Version of the product. Changing this creates a new resource.",
				MarkdownDescription: "Version of the product. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.LengthAtMost(80),
				},
			},
			"stack_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cluster stack. Changing this creates a new resource.",
				MarkdownDescription: "ID of the cluster stack. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"subnet_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "ID of the cluster subnet. Changing this creates a new resource.",
				MarkdownDescription: "ID of the cluster subnet. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"region": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The region in which to obtain the Data platform client. If omitted, the `region` argument of the provider is used. Changing this creates a new resource.",
				MarkdownDescription: "The region in which to obtain the Data platform client. If omitted, the `region` argument of the provider is used. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
		},
	}
}

type ClusterModel struct {
	AvailabilityZone  types.String `tfsdk:"availability_zone"`
	ClusterTemplateId types.String `tfsdk:"cluster_template_id"`
	Configs           ConfigsValue `tfsdk:"configs"`
	CreatedAt         types.String `tfsdk:"created_at"`
	Description       types.String `tfsdk:"description"`
	FloatingIpPool    types.String `tfsdk:"floating_ip_pool"`
	Id                types.String `tfsdk:"id"`
	Info              InfoValue    `tfsdk:"info"`
	Multiaz           types.Bool   `tfsdk:"multiaz"`
	Name              types.String `tfsdk:"name"`
	NetworkId         types.String `tfsdk:"network_id"`
	PodGroups         types.List   `tfsdk:"pod_groups"`
	ProductName       types.String `tfsdk:"product_name"`
	ProductType       types.String `tfsdk:"product_type"`
	ProductVersion    types.String `tfsdk:"product_version"`
	StackId           types.String `tfsdk:"stack_id"`
	SubnetId          types.String `tfsdk:"subnet_id"`
	Region            types.String `tfsdk:"region"`
}

var _ basetypes.ObjectTypable = ConfigsType{}

type ConfigsType struct {
	basetypes.ObjectType
}

func (t ConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsType) String() string {
	return "ConfigsType"
}

func (t ConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return nil, diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	warehousesAttribute, ok := attributes["warehouses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warehouses is missing from object`)

		return nil, diags
	}

	warehousesVal, ok := warehousesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warehouses expected to be basetypes.ListValue, was: %T`, warehousesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsValue{
		Maintenance: maintenanceVal,
		Settings:    settingsVal,
		Users:       usersVal,
		Warehouses:  warehousesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsValueNull() ConfigsValue {
	return ConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsValueUnknown() ConfigsValue {
	return ConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsValue Attribute Value",
				"While creating a ConfigsValue value, a missing attribute value was detected. "+
					"A ConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsValue Attribute Type",
				"While creating a ConfigsValue value, an invalid attribute value was detected. "+
					"A ConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsValue Attribute Value",
				"While creating a ConfigsValue value, an extra attribute value was detected. "+
					"A ConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsValueUnknown(), diags
	}

	maintenanceAttribute, ok := attributes["maintenance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maintenance is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	maintenanceVal, ok := maintenanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maintenance expected to be basetypes.ObjectValue, was: %T`, maintenanceAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	warehousesAttribute, ok := attributes["warehouses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warehouses is missing from object`)

		return NewConfigsValueUnknown(), diags
	}

	warehousesVal, ok := warehousesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warehouses expected to be basetypes.ListValue, was: %T`, warehousesAttribute))
	}

	if diags.HasError() {
		return NewConfigsValueUnknown(), diags
	}

	return ConfigsValue{
		Maintenance: maintenanceVal,
		Settings:    settingsVal,
		Users:       usersVal,
		Warehouses:  warehousesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsValue {
	object, diags := NewConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsValueMust(ConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsValue{}
}

var _ basetypes.ObjectValuable = ConfigsValue{}

type ConfigsValue struct {
	Maintenance basetypes.ObjectValue `tfsdk:"maintenance"`
	Settings    basetypes.ListValue   `tfsdk:"settings"`
	Users       basetypes.ListValue   `tfsdk:"users"`
	Warehouses  basetypes.ListValue   `tfsdk:"warehouses"`
	state       attr.ValueState
}

func (v ConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["maintenance"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: ConfigsUsersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["warehouses"] = basetypes.ListType{
		ElemType: ConfigsWarehousesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Maintenance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maintenance"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		val, err = v.Warehouses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warehouses"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsValue) String() string {
	return "ConfigsValue"
}

func (v ConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var maintenance basetypes.ObjectValue

	if v.Maintenance.IsNull() {
		maintenance = types.ObjectNull(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Maintenance.IsUnknown() {
		maintenance = types.ObjectUnknown(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Maintenance.IsNull() && !v.Maintenance.IsUnknown() {
		maintenance = types.ObjectValueMust(
			ConfigsMaintenanceValue{}.AttributeTypes(ctx),
			v.Maintenance.Attributes(),
		)
	}

	settings := types.ListValueMust(
		ConfigsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	users := types.ListValueMust(
		ConfigsUsersType{
			basetypes.ObjectType{
				AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Users.Elements(),
	)

	if v.Users.IsNull() {
		users = types.ListNull(
			ConfigsUsersType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Users.IsUnknown() {
		users = types.ListUnknown(
			ConfigsUsersType{
				basetypes.ObjectType{
					AttrTypes: ConfigsUsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	warehouses := types.ListValueMust(
		ConfigsWarehousesType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
			},
		},
		v.Warehouses.Elements(),
	)

	if v.Warehouses.IsNull() {
		warehouses = types.ListNull(
			ConfigsWarehousesType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Warehouses.IsUnknown() {
		warehouses = types.ListUnknown(
			ConfigsWarehousesType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"maintenance": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		},
		"settings": basetypes.ListType{
			ElemType: ConfigsSettingsValue{}.Type(ctx),
		},
		"users": basetypes.ListType{
			ElemType: ConfigsUsersValue{}.Type(ctx),
		},
		"warehouses": basetypes.ListType{
			ElemType: ConfigsWarehousesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"maintenance": maintenance,
			"settings":    settings,
			"users":       users,
			"warehouses":  warehouses,
		})

	return objVal, diags
}

func (v ConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Maintenance.Equal(other.Maintenance) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	if !v.Warehouses.Equal(other.Warehouses) {
		return false
	}

	return true
}

func (v ConfigsValue) Type(ctx context.Context) attr.Type {
	return ConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"maintenance": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceValue{}.AttributeTypes(ctx),
		},
		"settings": basetypes.ListType{
			ElemType: ConfigsSettingsValue{}.Type(ctx),
		},
		"users": basetypes.ListType{
			ElemType: ConfigsUsersValue{}.Type(ctx),
		},
		"warehouses": basetypes.ListType{
			ElemType: ConfigsWarehousesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceType{}

type ConfigsMaintenanceType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceType) String() string {
	return "ConfigsMaintenanceType"
}

func (t ConfigsMaintenanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return nil, diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	crontabsAttribute, ok := attributes["crontabs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`crontabs is missing from object`)

		return nil, diags
	}

	crontabsVal, ok := crontabsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`crontabs expected to be basetypes.ListValue, was: %T`, crontabsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceValue{
		Backup:   backupVal,
		Crontabs: crontabsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceValueNull() ConfigsMaintenanceValue {
	return ConfigsMaintenanceValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceValueUnknown() ConfigsMaintenanceValue {
	return ConfigsMaintenanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceValue Attribute Value",
				"While creating a ConfigsMaintenanceValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceValue Attribute Type",
				"While creating a ConfigsMaintenanceValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceValue Attribute Value",
				"While creating a ConfigsMaintenanceValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceValueUnknown(), diags
	}

	backupAttribute, ok := attributes["backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	backupVal, ok := backupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup expected to be basetypes.ObjectValue, was: %T`, backupAttribute))
	}

	crontabsAttribute, ok := attributes["crontabs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`crontabs is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	crontabsVal, ok := crontabsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`crontabs expected to be basetypes.ListValue, was: %T`, crontabsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceValueUnknown(), diags
	}

	return ConfigsMaintenanceValue{
		Backup:   backupVal,
		Crontabs: crontabsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceValue {
	object, diags := NewConfigsMaintenanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceValueMust(ConfigsMaintenanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceValue{}

type ConfigsMaintenanceValue struct {
	Backup   basetypes.ObjectValue `tfsdk:"backup"`
	Crontabs basetypes.ListValue   `tfsdk:"crontabs"`
	Start    basetypes.StringValue `tfsdk:"start"`
	state    attr.ValueState
}

func (v ConfigsMaintenanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["backup"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["crontabs"] = basetypes.ListType{
		ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Backup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup"] = val

		val, err = v.Crontabs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["crontabs"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceValue) String() string {
	return "ConfigsMaintenanceValue"
}

func (v ConfigsMaintenanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var backup basetypes.ObjectValue

	if v.Backup.IsNull() {
		backup = types.ObjectNull(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if v.Backup.IsUnknown() {
		backup = types.ObjectUnknown(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Backup.IsNull() && !v.Backup.IsUnknown() {
		backup = types.ObjectValueMust(
			ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
			v.Backup.Attributes(),
		)
	}

	crontabs := types.ListValueMust(
		ConfigsMaintenanceCrontabsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
			},
		},
		v.Crontabs.Elements(),
	)

	if v.Crontabs.IsNull() {
		crontabs = types.ListNull(
			ConfigsMaintenanceCrontabsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Crontabs.IsUnknown() {
		crontabs = types.ListUnknown(
			ConfigsMaintenanceCrontabsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"crontabs": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup":   backup,
			"crontabs": crontabs,
			"start":    v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Backup.Equal(other.Backup) {
		return false
	}

	if !v.Crontabs.Equal(other.Crontabs) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx),
		},
		"crontabs": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupType{}

type ConfigsMaintenanceBackupType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupType) String() string {
	return "ConfigsMaintenanceBackupType"
}

func (t ConfigsMaintenanceBackupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return nil, diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return nil, diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return nil, diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupValueNull() ConfigsMaintenanceBackupValue {
	return ConfigsMaintenanceBackupValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupValueUnknown() ConfigsMaintenanceBackupValue {
	return ConfigsMaintenanceBackupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	differentialAttribute, ok := attributes["differential"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`differential is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	differentialVal, ok := differentialAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`differential expected to be basetypes.ObjectValue, was: %T`, differentialAttribute))
	}

	fullAttribute, ok := attributes["full"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	fullVal, ok := fullAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full expected to be basetypes.ObjectValue, was: %T`, fullAttribute))
	}

	incrementalAttribute, ok := attributes["incremental"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental is missing from object`)

		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	incrementalVal, ok := incrementalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental expected to be basetypes.ObjectValue, was: %T`, incrementalAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupValue{
		Differential: differentialVal,
		Full:         fullVal,
		Incremental:  incrementalVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupValue {
	object, diags := NewConfigsMaintenanceBackupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupValueMust(ConfigsMaintenanceBackupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupValue{}

type ConfigsMaintenanceBackupValue struct {
	Differential basetypes.ObjectValue `tfsdk:"differential"`
	Full         basetypes.ObjectValue `tfsdk:"full"`
	Incremental  basetypes.ObjectValue `tfsdk:"incremental"`
	state        attr.ValueState
}

func (v ConfigsMaintenanceBackupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["differential"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["full"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["incremental"] = basetypes.ObjectType{
		AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Differential.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["differential"] = val

		val, err = v.Full.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full"] = val

		val, err = v.Incremental.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incremental"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupValue) String() string {
	return "ConfigsMaintenanceBackupValue"
}

func (v ConfigsMaintenanceBackupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var differential basetypes.ObjectValue

	if v.Differential.IsNull() {
		differential = types.ObjectNull(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if v.Differential.IsUnknown() {
		differential = types.ObjectUnknown(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Differential.IsNull() && !v.Differential.IsUnknown() {
		differential = types.ObjectValueMust(
			ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
			v.Differential.Attributes(),
		)
	}

	var full basetypes.ObjectValue

	if v.Full.IsNull() {
		full = types.ObjectNull(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if v.Full.IsUnknown() {
		full = types.ObjectUnknown(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Full.IsNull() && !v.Full.IsUnknown() {
		full = types.ObjectValueMust(
			ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
			v.Full.Attributes(),
		)
	}

	var incremental basetypes.ObjectValue

	if v.Incremental.IsNull() {
		incremental = types.ObjectNull(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Incremental.IsUnknown() {
		incremental = types.ObjectUnknown(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Incremental.IsNull() && !v.Incremental.IsUnknown() {
		incremental = types.ObjectValueMust(
			ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
			v.Incremental.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"differential": differential,
			"full":         full,
			"incremental":  incremental,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Differential.Equal(other.Differential) {
		return false
	}

	if !v.Full.Equal(other.Full) {
		return false
	}

	if !v.Incremental.Equal(other.Incremental) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"differential": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx),
		},
		"full": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx),
		},
		"incremental": basetypes.ObjectType{
			AttrTypes: ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupDifferentialType{}

type ConfigsMaintenanceBackupDifferentialType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupDifferentialType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupDifferentialType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupDifferentialType) String() string {
	return "ConfigsMaintenanceBackupDifferentialType"
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupDifferentialValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupDifferentialValueNull() ConfigsMaintenanceBackupDifferentialValue {
	return ConfigsMaintenanceBackupDifferentialValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupDifferentialValueUnknown() ConfigsMaintenanceBackupDifferentialValue {
	return ConfigsMaintenanceBackupDifferentialValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupDifferentialValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupDifferentialValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupDifferentialValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupDifferentialValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupDifferentialValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupDifferentialValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupDifferentialValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupDifferentialValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupDifferentialValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupDifferentialValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupDifferentialValue {
	object, diags := NewConfigsMaintenanceBackupDifferentialValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupDifferentialValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupDifferentialValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupDifferentialValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupDifferentialValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupDifferentialValueMust(ConfigsMaintenanceBackupDifferentialValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupDifferentialType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupDifferentialValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupDifferentialValue{}

type ConfigsMaintenanceBackupDifferentialValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupDifferentialValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupDifferentialValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupDifferentialValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupDifferentialValue) String() string {
	return "ConfigsMaintenanceBackupDifferentialValue"
}

func (v ConfigsMaintenanceBackupDifferentialValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupDifferentialValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupDifferentialValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupDifferentialValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupDifferentialType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupDifferentialValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupFullType{}

type ConfigsMaintenanceBackupFullType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupFullType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupFullType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupFullType) String() string {
	return "ConfigsMaintenanceBackupFullType"
}

func (t ConfigsMaintenanceBackupFullType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupFullValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupFullValueNull() ConfigsMaintenanceBackupFullValue {
	return ConfigsMaintenanceBackupFullValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupFullValueUnknown() ConfigsMaintenanceBackupFullValue {
	return ConfigsMaintenanceBackupFullValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupFullValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupFullValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupFullValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupFullValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupFullValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupFullValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupFullValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupFullValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupFullValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupFullValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupFullValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupFullValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupFullValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupFullValue {
	object, diags := NewConfigsMaintenanceBackupFullValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupFullValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupFullType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupFullValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupFullValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupFullValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupFullValueMust(ConfigsMaintenanceBackupFullValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupFullType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupFullValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupFullValue{}

type ConfigsMaintenanceBackupFullValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupFullValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupFullValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupFullValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupFullValue) String() string {
	return "ConfigsMaintenanceBackupFullValue"
}

func (v ConfigsMaintenanceBackupFullValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupFullValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupFullValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupFullValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupFullType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupFullValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceBackupIncrementalType{}

type ConfigsMaintenanceBackupIncrementalType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceBackupIncrementalType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceBackupIncrementalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceBackupIncrementalType) String() string {
	return "ConfigsMaintenanceBackupIncrementalType"
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return nil, diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return nil, diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceBackupIncrementalValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupIncrementalValueNull() ConfigsMaintenanceBackupIncrementalValue {
	return ConfigsMaintenanceBackupIncrementalValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceBackupIncrementalValueUnknown() ConfigsMaintenanceBackupIncrementalValue {
	return ConfigsMaintenanceBackupIncrementalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceBackupIncrementalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceBackupIncrementalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceBackupIncrementalValue Attribute Type",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceBackupIncrementalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceBackupIncrementalValue Attribute Value",
				"While creating a ConfigsMaintenanceBackupIncrementalValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceBackupIncrementalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceBackupIncrementalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keepCountAttribute, ok := attributes["keep_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_count is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepCountVal, ok := keepCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_count expected to be basetypes.Int64Value, was: %T`, keepCountAttribute))
	}

	keepTimeAttribute, ok := attributes["keep_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_time is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	keepTimeVal, ok := keepTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_time expected to be basetypes.Int64Value, was: %T`, keepTimeAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), diags
	}

	return ConfigsMaintenanceBackupIncrementalValue{
		Enabled:   enabledVal,
		KeepCount: keepCountVal,
		KeepTime:  keepTimeVal,
		Start:     startVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceBackupIncrementalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceBackupIncrementalValue {
	object, diags := NewConfigsMaintenanceBackupIncrementalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceBackupIncrementalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceBackupIncrementalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceBackupIncrementalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceBackupIncrementalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceBackupIncrementalValueMust(ConfigsMaintenanceBackupIncrementalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceBackupIncrementalType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceBackupIncrementalValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceBackupIncrementalValue{}

type ConfigsMaintenanceBackupIncrementalValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	KeepCount basetypes.Int64Value  `tfsdk:"keep_count"`
	KeepTime  basetypes.Int64Value  `tfsdk:"keep_time"`
	Start     basetypes.StringValue `tfsdk:"start"`
	state     attr.ValueState
}

func (v ConfigsMaintenanceBackupIncrementalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.KeepCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_count"] = val

		val, err = v.KeepTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_time"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceBackupIncrementalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceBackupIncrementalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceBackupIncrementalValue) String() string {
	return "ConfigsMaintenanceBackupIncrementalValue"
}

func (v ConfigsMaintenanceBackupIncrementalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":    v.Enabled,
			"keep_count": v.KeepCount,
			"keep_time":  v.KeepTime,
			"start":      v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceBackupIncrementalValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceBackupIncrementalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.KeepCount.Equal(other.KeepCount) {
		return false
	}

	if !v.KeepTime.Equal(other.KeepTime) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceBackupIncrementalValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceBackupIncrementalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceBackupIncrementalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":    basetypes.BoolType{},
		"keep_count": basetypes.Int64Type{},
		"keep_time":  basetypes.Int64Type{},
		"start":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceCrontabsType{}

type ConfigsMaintenanceCrontabsType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceCrontabsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceCrontabsType) String() string {
	return "ConfigsMaintenanceCrontabsType"
}

func (t ConfigsMaintenanceCrontabsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceCrontabsValue{
		Id:       idVal,
		Name:     nameVal,
		Required: requiredVal,
		Settings: settingsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsValueNull() ConfigsMaintenanceCrontabsValue {
	return ConfigsMaintenanceCrontabsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceCrontabsValueUnknown() ConfigsMaintenanceCrontabsValue {
	return ConfigsMaintenanceCrontabsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceCrontabsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceCrontabsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceCrontabsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceCrontabsValue Attribute Type",
				"While creating a ConfigsMaintenanceCrontabsValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceCrontabsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceCrontabsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceCrontabsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), diags
	}

	return ConfigsMaintenanceCrontabsValue{
		Id:       idVal,
		Name:     nameVal,
		Required: requiredVal,
		Settings: settingsVal,
		Start:    startVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceCrontabsValue {
	object, diags := NewConfigsMaintenanceCrontabsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceCrontabsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceCrontabsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceCrontabsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceCrontabsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceCrontabsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceCrontabsValueMust(ConfigsMaintenanceCrontabsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceCrontabsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceCrontabsValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceCrontabsValue{}

type ConfigsMaintenanceCrontabsValue struct {
	Id       basetypes.StringValue `tfsdk:"id"`
	Name     basetypes.StringValue `tfsdk:"name"`
	Required basetypes.BoolValue   `tfsdk:"required"`
	Settings basetypes.ListValue   `tfsdk:"settings"`
	Start    basetypes.StringValue `tfsdk:"start"`
	state    attr.ValueState
}

func (v ConfigsMaintenanceCrontabsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceCrontabsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceCrontabsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceCrontabsValue) String() string {
	return "ConfigsMaintenanceCrontabsValue"
}

func (v ConfigsMaintenanceCrontabsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsMaintenanceCrontabsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsMaintenanceCrontabsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsMaintenanceCrontabsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"id":       basetypes.StringType{},
		"name":     basetypes.StringType{},
		"required": basetypes.BoolType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":       v.Id,
			"name":     v.Name,
			"required": v.Required,
			"settings": settings,
			"start":    v.Start,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceCrontabsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceCrontabsValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceCrontabsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceCrontabsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":       basetypes.StringType{},
		"name":     basetypes.StringType{},
		"required": basetypes.BoolType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsMaintenanceCrontabsSettingsValue{}.Type(ctx),
		},
		"start": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsMaintenanceCrontabsSettingsType{}

type ConfigsMaintenanceCrontabsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsMaintenanceCrontabsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsMaintenanceCrontabsSettingsType) String() string {
	return "ConfigsMaintenanceCrontabsSettingsType"
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsMaintenanceCrontabsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsSettingsValueNull() ConfigsMaintenanceCrontabsSettingsValue {
	return ConfigsMaintenanceCrontabsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsMaintenanceCrontabsSettingsValueUnknown() ConfigsMaintenanceCrontabsSettingsValue {
	return ConfigsMaintenanceCrontabsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsMaintenanceCrontabsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsMaintenanceCrontabsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsMaintenanceCrontabsSettingsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsMaintenanceCrontabsSettingsValue Attribute Type",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsMaintenanceCrontabsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsMaintenanceCrontabsSettingsValue Attribute Value",
				"While creating a ConfigsMaintenanceCrontabsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsMaintenanceCrontabsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsMaintenanceCrontabsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), diags
	}

	return ConfigsMaintenanceCrontabsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsMaintenanceCrontabsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsMaintenanceCrontabsSettingsValue {
	object, diags := NewConfigsMaintenanceCrontabsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsMaintenanceCrontabsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsMaintenanceCrontabsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsMaintenanceCrontabsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsMaintenanceCrontabsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsMaintenanceCrontabsSettingsValueMust(ConfigsMaintenanceCrontabsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsMaintenanceCrontabsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsMaintenanceCrontabsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsMaintenanceCrontabsSettingsValue{}

type ConfigsMaintenanceCrontabsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsMaintenanceCrontabsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsMaintenanceCrontabsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsMaintenanceCrontabsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsMaintenanceCrontabsSettingsValue) String() string {
	return "ConfigsMaintenanceCrontabsSettingsValue"
}

func (v ConfigsMaintenanceCrontabsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsMaintenanceCrontabsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsMaintenanceCrontabsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsMaintenanceCrontabsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsMaintenanceCrontabsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsMaintenanceCrontabsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsSettingsType{}

type ConfigsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsSettingsType) String() string {
	return "ConfigsSettingsType"
}

func (t ConfigsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsSettingsValueNull() ConfigsSettingsValue {
	return ConfigsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsSettingsValueUnknown() ConfigsSettingsValue {
	return ConfigsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsSettingsValue Attribute Value",
				"While creating a ConfigsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsSettingsValue Attribute Type",
				"While creating a ConfigsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsSettingsValue Attribute Value",
				"While creating a ConfigsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsSettingsValueUnknown(), diags
	}

	return ConfigsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsSettingsValue {
	object, diags := NewConfigsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsSettingsValueMust(ConfigsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsSettingsValue{}

type ConfigsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsSettingsValue) String() string {
	return "ConfigsSettingsValue"
}

func (v ConfigsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsUsersType{}

type ConfigsUsersType struct {
	basetypes.ObjectType
}

func (t ConfigsUsersType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsUsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsUsersType) String() string {
	return "ConfigsUsersType"
}

func (t ConfigsUsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsUsersValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Password:  passwordVal,
		Role:      roleVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersValueNull() ConfigsUsersValue {
	return ConfigsUsersValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsUsersValueUnknown() ConfigsUsersValue {
	return ConfigsUsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsUsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsUsersValue Attribute Value",
				"While creating a ConfigsUsersValue value, a missing attribute value was detected. "+
					"A ConfigsUsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsUsersValue Attribute Type",
				"While creating a ConfigsUsersValue value, an invalid attribute value was detected. "+
					"A ConfigsUsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsUsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsUsersValue Attribute Value",
				"While creating a ConfigsUsersValue value, an extra attribute value was detected. "+
					"A ConfigsUsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsUsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsUsersValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewConfigsUsersValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewConfigsUsersValueUnknown(), diags
	}

	return ConfigsUsersValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Password:  passwordVal,
		Role:      roleVal,
		Username:  usernameVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsUsersValue {
	object, diags := NewConfigsUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsUsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsUsersValueMust(ConfigsUsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsUsersType) ValueType(ctx context.Context) attr.Value {
	return ConfigsUsersValue{}
}

var _ basetypes.ObjectValuable = ConfigsUsersValue{}

type ConfigsUsersValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Id        basetypes.StringValue `tfsdk:"id"`
	Password  basetypes.StringValue `tfsdk:"password"`
	Role      basetypes.StringValue `tfsdk:"role"`
	Username  basetypes.StringValue `tfsdk:"username"`
	state     attr.ValueState
}

func (v ConfigsUsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsUsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsUsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsUsersValue) String() string {
	return "ConfigsUsersValue"
}

func (v ConfigsUsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"password":   basetypes.StringType{},
		"role":       basetypes.StringType{},
		"username":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"password":   v.Password,
			"role":       v.Role,
			"username":   v.Username,
		})

	return objVal, diags
}

func (v ConfigsUsersValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsUsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v ConfigsUsersValue) Type(ctx context.Context) attr.Type {
	return ConfigsUsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsUsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"password":   basetypes.StringType{},
		"role":       basetypes.StringType{},
		"username":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesType{}

type ConfigsWarehousesType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesType) String() string {
	return "ConfigsWarehousesType"
}

func (t ConfigsWarehousesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectionsAttribute, ok := attributes["connections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connections is missing from object`)

		return nil, diags
	}

	connectionsVal, ok := connectionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connections expected to be basetypes.ListValue, was: %T`, connectionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesValue{
		Connections: connectionsVal,
		Id:          idVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesValueNull() ConfigsWarehousesValue {
	return ConfigsWarehousesValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesValueUnknown() ConfigsWarehousesValue {
	return ConfigsWarehousesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesValue Attribute Value",
				"While creating a ConfigsWarehousesValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesValue Attribute Type",
				"While creating a ConfigsWarehousesValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesValue Attribute Value",
				"While creating a ConfigsWarehousesValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesValueUnknown(), diags
	}

	connectionsAttribute, ok := attributes["connections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connections is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	connectionsVal, ok := connectionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connections expected to be basetypes.ListValue, was: %T`, connectionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsWarehousesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesValueUnknown(), diags
	}

	return ConfigsWarehousesValue{
		Connections: connectionsVal,
		Id:          idVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesValue {
	object, diags := NewConfigsWarehousesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesValueMust(ConfigsWarehousesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesValue{}

type ConfigsWarehousesValue struct {
	Connections basetypes.ListValue   `tfsdk:"connections"`
	Id          basetypes.StringValue `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	state       attr.ValueState
}

func (v ConfigsWarehousesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["connections"] = basetypes.ListType{
		ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Connections.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connections"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesValue) String() string {
	return "ConfigsWarehousesValue"
}

func (v ConfigsWarehousesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	connections := types.ListValueMust(
		ConfigsWarehousesConnectionsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Connections.Elements(),
	)

	if v.Connections.IsNull() {
		connections = types.ListNull(
			ConfigsWarehousesConnectionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Connections.IsUnknown() {
		connections = types.ListUnknown(
			ConfigsWarehousesConnectionsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"connections": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
		},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connections": connections,
			"id":          v.Id,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v ConfigsWarehousesValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Connections.Equal(other.Connections) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v ConfigsWarehousesValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connections": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsValue{}.Type(ctx),
		},
		"id":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesConnectionsType{}

type ConfigsWarehousesConnectionsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesConnectionsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesConnectionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesConnectionsType) String() string {
	return "ConfigsWarehousesConnectionsType"
}

func (t ConfigsWarehousesConnectionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	plugAttribute, ok := attributes["plug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plug is missing from object`)

		return nil, diags
	}

	plugVal, ok := plugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plug expected to be basetypes.StringValue, was: %T`, plugAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return nil, diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesConnectionsValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Name:      nameVal,
		Plug:      plugVal,
		Settings:  settingsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsValueNull() ConfigsWarehousesConnectionsValue {
	return ConfigsWarehousesConnectionsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesConnectionsValueUnknown() ConfigsWarehousesConnectionsValue {
	return ConfigsWarehousesConnectionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesConnectionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesConnectionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesConnectionsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesConnectionsValue Attribute Type",
				"While creating a ConfigsWarehousesConnectionsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesConnectionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesConnectionsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesConnectionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesConnectionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	plugAttribute, ok := attributes["plug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plug is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	plugVal, ok := plugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plug expected to be basetypes.StringValue, was: %T`, plugAttribute))
	}

	settingsAttribute, ok := attributes["settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`settings is missing from object`)

		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	settingsVal, ok := settingsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`settings expected to be basetypes.ListValue, was: %T`, settingsAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsValueUnknown(), diags
	}

	return ConfigsWarehousesConnectionsValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Name:      nameVal,
		Plug:      plugVal,
		Settings:  settingsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesConnectionsValue {
	object, diags := NewConfigsWarehousesConnectionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesConnectionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesConnectionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesConnectionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesConnectionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesConnectionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesConnectionsValueMust(ConfigsWarehousesConnectionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesConnectionsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesConnectionsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesConnectionsValue{}

type ConfigsWarehousesConnectionsValue struct {
	CreatedAt basetypes.StringValue `tfsdk:"created_at"`
	Id        basetypes.StringValue `tfsdk:"id"`
	Name      basetypes.StringValue `tfsdk:"name"`
	Plug      basetypes.StringValue `tfsdk:"plug"`
	Settings  basetypes.ListValue   `tfsdk:"settings"`
	state     attr.ValueState
}

func (v ConfigsWarehousesConnectionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["settings"] = basetypes.ListType{
		ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Plug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plug"] = val

		val, err = v.Settings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesConnectionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesConnectionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesConnectionsValue) String() string {
	return "ConfigsWarehousesConnectionsValue"
}

func (v ConfigsWarehousesConnectionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	settings := types.ListValueMust(
		ConfigsWarehousesConnectionsSettingsType{
			basetypes.ObjectType{
				AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
			},
		},
		v.Settings.Elements(),
	)

	if v.Settings.IsNull() {
		settings = types.ListNull(
			ConfigsWarehousesConnectionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Settings.IsUnknown() {
		settings = types.ListUnknown(
			ConfigsWarehousesConnectionsSettingsType{
				basetypes.ObjectType{
					AttrTypes: ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"name":       basetypes.StringType{},
		"plug":       basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"name":       v.Name,
			"plug":       v.Plug,
			"settings":   settings,
		})

	return objVal, diags
}

func (v ConfigsWarehousesConnectionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesConnectionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Plug.Equal(other.Plug) {
		return false
	}

	if !v.Settings.Equal(other.Settings) {
		return false
	}

	return true
}

func (v ConfigsWarehousesConnectionsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesConnectionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesConnectionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": basetypes.StringType{},
		"id":         basetypes.StringType{},
		"name":       basetypes.StringType{},
		"plug":       basetypes.StringType{},
		"settings": basetypes.ListType{
			ElemType: ConfigsWarehousesConnectionsSettingsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ConfigsWarehousesConnectionsSettingsType{}

type ConfigsWarehousesConnectionsSettingsType struct {
	basetypes.ObjectType
}

func (t ConfigsWarehousesConnectionsSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigsWarehousesConnectionsSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigsWarehousesConnectionsSettingsType) String() string {
	return "ConfigsWarehousesConnectionsSettingsType"
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigsWarehousesConnectionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsSettingsValueNull() ConfigsWarehousesConnectionsSettingsValue {
	return ConfigsWarehousesConnectionsSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigsWarehousesConnectionsSettingsValueUnknown() ConfigsWarehousesConnectionsSettingsValue {
	return ConfigsWarehousesConnectionsSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigsWarehousesConnectionsSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigsWarehousesConnectionsSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigsWarehousesConnectionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, a missing attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigsWarehousesConnectionsSettingsValue Attribute Type",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, an invalid attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigsWarehousesConnectionsSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigsWarehousesConnectionsSettingsValue Attribute Value",
				"While creating a ConfigsWarehousesConnectionsSettingsValue value, an extra attribute value was detected. "+
					"A ConfigsWarehousesConnectionsSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigsWarehousesConnectionsSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), diags
	}

	return ConfigsWarehousesConnectionsSettingsValue{
		Alias: aliasVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewConfigsWarehousesConnectionsSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigsWarehousesConnectionsSettingsValue {
	object, diags := NewConfigsWarehousesConnectionsSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigsWarehousesConnectionsSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigsWarehousesConnectionsSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigsWarehousesConnectionsSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigsWarehousesConnectionsSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigsWarehousesConnectionsSettingsValueMust(ConfigsWarehousesConnectionsSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigsWarehousesConnectionsSettingsType) ValueType(ctx context.Context) attr.Value {
	return ConfigsWarehousesConnectionsSettingsValue{}
}

var _ basetypes.ObjectValuable = ConfigsWarehousesConnectionsSettingsValue{}

type ConfigsWarehousesConnectionsSettingsValue struct {
	Alias basetypes.StringValue `tfsdk:"alias"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v ConfigsWarehousesConnectionsSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigsWarehousesConnectionsSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigsWarehousesConnectionsSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigsWarehousesConnectionsSettingsValue) String() string {
	return "ConfigsWarehousesConnectionsSettingsValue"
}

func (v ConfigsWarehousesConnectionsSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias": v.Alias,
			"value": v.Value,
		})

	return objVal, diags
}

func (v ConfigsWarehousesConnectionsSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigsWarehousesConnectionsSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v ConfigsWarehousesConnectionsSettingsValue) Type(ctx context.Context) attr.Type {
	return ConfigsWarehousesConnectionsSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigsWarehousesConnectionsSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias": basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InfoType{}

type InfoType struct {
	basetypes.ObjectType
}

func (t InfoType) Equal(o attr.Type) bool {
	other, ok := o.(InfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoType) String() string {
	return "InfoType"
}

func (t InfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoValue{
		Services: servicesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewInfoValueNull() InfoValue {
	return InfoValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoValueUnknown() InfoValue {
	return InfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoValue Attribute Value",
				"While creating a InfoValue value, a missing attribute value was detected. "+
					"A InfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoValue Attribute Type",
				"While creating a InfoValue value, an invalid attribute value was detected. "+
					"A InfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoValue Attribute Value",
				"While creating a InfoValue value, an extra attribute value was detected. "+
					"A InfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewInfoValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	return InfoValue{
		Services: servicesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoValue {
	object, diags := NewInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoValueMust(InfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoType) ValueType(ctx context.Context) attr.Value {
	return InfoValue{}
}

var _ basetypes.ObjectValuable = InfoValue{}

type InfoValue struct {
	Services basetypes.ListValue `tfsdk:"services"`
	state    attr.ValueState
}

func (v InfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["services"] = basetypes.ListType{
		ElemType: InfoServicesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoValue) String() string {
	return "InfoValue"
}

func (v InfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	services := types.ListValueMust(
		InfoServicesType{
			basetypes.ObjectType{
				AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Services.Elements(),
	)

	if v.Services.IsNull() {
		services = types.ListNull(
			InfoServicesType{
				basetypes.ObjectType{
					AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Services.IsUnknown() {
		services = types.ListUnknown(
			InfoServicesType{
				basetypes.ObjectType{
					AttrTypes: InfoServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"services": basetypes.ListType{
			ElemType: InfoServicesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"services": services,
		})

	return objVal, diags
}

func (v InfoValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	return true
}

func (v InfoValue) Type(ctx context.Context) attr.Type {
	return InfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"services": basetypes.ListType{
			ElemType: InfoServicesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = InfoServicesType{}

type InfoServicesType struct {
	basetypes.ObjectType
}

func (t InfoServicesType) Equal(o attr.Type) bool {
	other, ok := o.(InfoServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoServicesType) String() string {
	return "ServiceType"
}

func (t InfoServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return nil, diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exposedAttribute, ok := attributes["exposed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exposed is missing from object`)

		return nil, diags
	}

	exposedVal, ok := exposedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exposed expected to be basetypes.BoolValue, was: %T`, exposedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoServicesValue{
		ConnectionString: connectionStringVal,
		Description:      descriptionVal,
		Exposed:          exposedVal,
		ServiceType:      typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInfoServicesValueNull() InfoServicesValue {
	return InfoServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoServicesValueUnknown() InfoServicesValue {
	return InfoServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoServicesValue Attribute Value",
				"While creating a InfoServicesValue value, a missing attribute value was detected. "+
					"A InfoServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoServicesValue Attribute Type",
				"While creating a InfoServicesValue value, an invalid attribute value was detected. "+
					"A InfoServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoServicesValue Attribute Value",
				"While creating a InfoServicesValue value, an extra attribute value was detected. "+
					"A InfoServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoServicesValueUnknown(), diags
	}

	connectionStringAttribute, ok := attributes["connection_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connection_string is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	connectionStringVal, ok := connectionStringAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connection_string expected to be basetypes.StringValue, was: %T`, connectionStringAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exposedAttribute, ok := attributes["exposed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exposed is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	exposedVal, ok := exposedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exposed expected to be basetypes.BoolValue, was: %T`, exposedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewInfoServicesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewInfoServicesValueUnknown(), diags
	}

	return InfoServicesValue{
		ConnectionString: connectionStringVal,
		Description:      descriptionVal,
		Exposed:          exposedVal,
		ServiceType:      typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInfoServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoServicesValue {
	object, diags := NewInfoServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoServicesValueMust(InfoServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoServicesType) ValueType(ctx context.Context) attr.Value {
	return InfoServicesValue{}
}

var _ basetypes.ObjectValuable = InfoServicesValue{}

type InfoServicesValue struct {
	ConnectionString basetypes.StringValue `tfsdk:"connection_string"`
	Description      basetypes.StringValue `tfsdk:"description"`
	Exposed          basetypes.BoolValue   `tfsdk:"exposed"`
	ServiceType      basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v InfoServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connection_string"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exposed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectionString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connection_string"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Exposed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exposed"] = val

		val, err = v.ServiceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoServicesValue) String() string {
	return "InfoServicesValue"
}

func (v InfoServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connection_string": basetypes.StringType{},
		"description":       basetypes.StringType{},
		"exposed":           basetypes.BoolType{},
		"type":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connection_string": v.ConnectionString,
			"description":       v.Description,
			"exposed":           v.Exposed,
			"type":              v.ServiceType,
		})

	return objVal, diags
}

func (v InfoServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectionString.Equal(other.ConnectionString) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Exposed.Equal(other.Exposed) {
		return false
	}

	if !v.ServiceType.Equal(other.ServiceType) {
		return false
	}

	return true
}

func (v InfoServicesValue) Type(ctx context.Context) attr.Type {
	return InfoServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connection_string": basetypes.StringType{},
		"description":       basetypes.StringType{},
		"exposed":           basetypes.BoolType{},
		"type":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodGroupsType{}

type PodGroupsType struct {
	basetypes.ObjectType
}

func (t PodGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsType) String() string {
	return "PodGroupsType"
}

func (t PodGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return nil, diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	floatingIpPoolAttribute, ok := attributes["floating_ip_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_pool is missing from object`)

		return nil, diags
	}

	floatingIpPoolVal, ok := floatingIpPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_pool expected to be basetypes.StringValue, was: %T`, floatingIpPoolAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsValue{
		Alias:            aliasVal,
		AvailabilityZone: availabilityZoneVal,
		Count:            countVal,
		FloatingIpPool:   floatingIpPoolVal,
		Id:               idVal,
		Name:             nameVal,
		Resource:         resourceVal,
		Volumes:          volumesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueNull() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsValueUnknown() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, a missing attribute value was detected. "+
					"A PodGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsValue Attribute Type",
				"While creating a PodGroupsValue value, an invalid attribute value was detected. "+
					"A PodGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, an extra attribute value was detected. "+
					"A PodGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be basetypes.StringValue, was: %T`, aliasAttribute))
	}

	availabilityZoneAttribute, ok := attributes["availability_zone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`availability_zone is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	availabilityZoneVal, ok := availabilityZoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`availability_zone expected to be basetypes.StringValue, was: %T`, availabilityZoneAttribute))
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	floatingIpPoolAttribute, ok := attributes["floating_ip_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ip_pool is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	floatingIpPoolVal, ok := floatingIpPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ip_pool expected to be basetypes.StringValue, was: %T`, floatingIpPoolAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	return PodGroupsValue{
		Alias:            aliasVal,
		AvailabilityZone: availabilityZoneVal,
		Count:            countVal,
		FloatingIpPool:   floatingIpPoolVal,
		Id:               idVal,
		Name:             nameVal,
		Resource:         resourceVal,
		Volumes:          volumesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsValue {
	object, diags := NewPodGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsValueMust(PodGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsValue{}
}

var _ basetypes.ObjectValuable = PodGroupsValue{}

type PodGroupsValue struct {
	Alias            basetypes.StringValue `tfsdk:"alias"`
	AvailabilityZone basetypes.StringValue `tfsdk:"availability_zone"`
	Count            basetypes.Int64Value  `tfsdk:"count"`
	FloatingIpPool   basetypes.StringValue `tfsdk:"floating_ip_pool"`
	Id               basetypes.StringValue `tfsdk:"id"`
	Name             basetypes.StringValue `tfsdk:"name"`
	Resource         basetypes.ObjectValue `tfsdk:"resource"`
	Volumes          basetypes.MapValue    `tfsdk:"volumes"`
	state            attr.ValueState
}

func (v PodGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["availability_zone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["floating_ip_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.MapType{
		ElemType: PodGroupsVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.AvailabilityZone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["availability_zone"] = val

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.FloatingIpPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ip_pool"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsValue) String() string {
	return "PodGroupsValue"
}

func (v PodGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	volumes := types.MapValueMust(
		PodGroupsVolumesType{
			basetypes.ObjectType{
				AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.MapNull(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.MapUnknown(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"alias":             basetypes.StringType{},
		"availability_zone": basetypes.StringType{},
		"count":             basetypes.Int64Type{},
		"floating_ip_pool":  basetypes.StringType{},
		"id":                basetypes.StringType{},
		"name":              basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alias":             v.Alias,
			"availability_zone": v.AvailabilityZone,
			"count":             v.Count,
			"floating_ip_pool":  v.FloatingIpPool,
			"id":                v.Id,
			"name":              v.Name,
			"resource":          resource,
			"volumes":           volumes,
		})

	return objVal, diags
}

func (v PodGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.AvailabilityZone.Equal(other.AvailabilityZone) {
		return false
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.FloatingIpPool.Equal(other.FloatingIpPool) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v PodGroupsValue) Type(ctx context.Context) attr.Type {
	return PodGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":             basetypes.StringType{},
		"availability_zone": basetypes.StringType{},
		"count":             basetypes.Int64Type{},
		"floating_ip_pool":  basetypes.StringType{},
		"id":                basetypes.StringType{},
		"name":              basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PodGroupsResourceType{}

type PodGroupsResourceType struct {
	basetypes.ObjectType
}

func (t PodGroupsResourceType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsResourceType) String() string {
	return "PodGroupsResourceType"
}

func (t PodGroupsResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuLimitAttribute, ok := attributes["cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_limit is missing from object`)

		return nil, diags
	}

	cpuLimitVal, ok := cpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_limit expected to be basetypes.StringValue, was: %T`, cpuLimitAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return nil, diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramLimitAttribute, ok := attributes["ram_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_limit is missing from object`)

		return nil, diags
	}

	ramLimitVal, ok := ramLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_limit expected to be basetypes.StringValue, was: %T`, ramLimitAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return nil, diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsResourceValue{
		CpuLimit:   cpuLimitVal,
		CpuRequest: cpuRequestVal,
		RamLimit:   ramLimitVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueNull() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsResourceValueUnknown() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, a missing attribute value was detected. "+
					"A PodGroupsResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsResourceValue Attribute Type",
				"While creating a PodGroupsResourceValue value, an invalid attribute value was detected. "+
					"A PodGroupsResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, an extra attribute value was detected. "+
					"A PodGroupsResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuLimitAttribute, ok := attributes["cpu_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_limit is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuLimitVal, ok := cpuLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_limit expected to be basetypes.StringValue, was: %T`, cpuLimitAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramLimitAttribute, ok := attributes["ram_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_limit is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramLimitVal, ok := ramLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_limit expected to be basetypes.StringValue, was: %T`, ramLimitAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	return PodGroupsResourceValue{
		CpuLimit:   cpuLimitVal,
		CpuRequest: cpuRequestVal,
		RamLimit:   ramLimitVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsResourceValue {
	object, diags := NewPodGroupsResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsResourceValueMust(PodGroupsResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsResourceType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsResourceValue{}
}

var _ basetypes.ObjectValuable = PodGroupsResourceValue{}

type PodGroupsResourceValue struct {
	CpuLimit   basetypes.StringValue `tfsdk:"cpu_limit"`
	CpuRequest basetypes.StringValue `tfsdk:"cpu_request"`
	RamLimit   basetypes.StringValue `tfsdk:"ram_limit"`
	RamRequest basetypes.StringValue `tfsdk:"ram_request"`
	state      attr.ValueState
}

func (v PodGroupsResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_request"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_request"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_limit"] = val

		val, err = v.CpuRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_request"] = val

		val, err = v.RamLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_limit"] = val

		val, err = v.RamRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_request"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsResourceValue) String() string {
	return "PodGroupsResourceValue"
}

func (v PodGroupsResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_limit":   basetypes.StringType{},
		"cpu_request": basetypes.StringType{},
		"ram_limit":   basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_limit":   v.CpuLimit,
			"cpu_request": v.CpuRequest,
			"ram_limit":   v.RamLimit,
			"ram_request": v.RamRequest,
		})

	return objVal, diags
}

func (v PodGroupsResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuLimit.Equal(other.CpuLimit) {
		return false
	}

	if !v.CpuRequest.Equal(other.CpuRequest) {
		return false
	}

	if !v.RamLimit.Equal(other.RamLimit) {
		return false
	}

	if !v.RamRequest.Equal(other.RamRequest) {
		return false
	}

	return true
}

func (v PodGroupsResourceValue) Type(ctx context.Context) attr.Type {
	return PodGroupsResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_limit":   basetypes.StringType{},
		"cpu_request": basetypes.StringType{},
		"ram_limit":   basetypes.StringType{},
		"ram_request": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodGroupsVolumesType{}

type PodGroupsVolumesType struct {
	basetypes.ObjectType
}

func (t PodGroupsVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsVolumesType) String() string {
	return "PodGroupsVolumesType"
}

func (t PodGroupsVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return nil, diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueNull() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsVolumesValueUnknown() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, a missing attribute value was detected. "+
					"A PodGroupsVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsVolumesValue Attribute Type",
				"While creating a PodGroupsVolumesValue value, an invalid attribute value was detected. "+
					"A PodGroupsVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, an extra attribute value was detected. "+
					"A PodGroupsVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsVolumesValue {
	object, diags := NewPodGroupsVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsVolumesValueMust(PodGroupsVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsVolumesType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsVolumesValue{}
}

var _ basetypes.ObjectValuable = PodGroupsVolumesValue{}

type PodGroupsVolumesValue struct {
	Count            basetypes.Int64Value  `tfsdk:"count"`
	Storage          basetypes.StringValue `tfsdk:"storage"`
	StorageClassName basetypes.StringValue `tfsdk:"storage_class_name"`
	state            attr.ValueState
}

func (v PodGroupsVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		val, err = v.StorageClassName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsVolumesValue) String() string {
	return "PodGroupsVolumesValue"
}

func (v PodGroupsVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":              v.Count,
			"storage":            v.Storage,
			"storage_class_name": v.StorageClassName,
		})

	return objVal, diags
}

func (v PodGroupsVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	if !v.StorageClassName.Equal(other.StorageClassName) {
		return false
	}

	return true
}

func (v PodGroupsVolumesValue) Type(ctx context.Context) attr.Type {
	return PodGroupsVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}
}
