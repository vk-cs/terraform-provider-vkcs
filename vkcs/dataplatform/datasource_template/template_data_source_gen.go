// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_template

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func TemplateDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "ID of the cluster template.",
				MarkdownDescription: "ID of the cluster template.",
			},
			"name": schema.StringAttribute{
				Computed:            true,
				Description:         "Name of the cluster template.",
				MarkdownDescription: "Name of the cluster template.",
			},
			"pod_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"count": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of pods in the pod group.",
							MarkdownDescription: "Number of pods in the pod group.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Pod group name.",
							MarkdownDescription: "Pod group name.",
						},
						"resource": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"cpu_margin": schema.NumberAttribute{
									Computed:            true,
									Description:         "CPU margin for the pod group.",
									MarkdownDescription: "CPU margin for the pod group.",
								},
								"cpu_request": schema.StringAttribute{
									Computed:            true,
									Description:         "CPU request for the pod group.",
									MarkdownDescription: "CPU request for the pod group.",
								},
								"ram_margin": schema.NumberAttribute{
									Computed:            true,
									Description:         "RAM margin for the pod group.",
									MarkdownDescription: "RAM margin for the pod group.",
								},
								"ram_request": schema.StringAttribute{
									Computed:            true,
									Description:         "RAM request for the pod group.",
									MarkdownDescription: "RAM request for the pod group.",
								},
							},
							CustomType: PodGroupsResourceType{
								ObjectType: types.ObjectType{
									AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Resource settings for the pod group.",
							MarkdownDescription: "Resource settings for the pod group.",
						},
						"volumes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"count": schema.Int64Attribute{
										Computed:            true,
										Description:         "Volume count.",
										MarkdownDescription: "Volume count.",
									},
									"storage": schema.StringAttribute{
										Computed:            true,
										Description:         "Volume storage size.",
										MarkdownDescription: "Volume storage size.",
									},
									"storage_class_name": schema.StringAttribute{
										Computed:            true,
										Description:         "Storage class name for the volume.",
										MarkdownDescription: "Storage class name for the volume.",
									},
								},
								CustomType: PodGroupsVolumesType{
									ObjectType: types.ObjectType{
										AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Volumes configuration for the pod group.",
							MarkdownDescription: "Volumes configuration for the pod group.",
						},
					},
					CustomType: PodGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: PodGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "List of pod groups in the template.",
				MarkdownDescription: "List of pod groups in the template.",
			},
			"product_name": schema.StringAttribute{
				Required:            true,
				Description:         "Product name.",
				MarkdownDescription: "Product name.",
			},
			"product_version": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Product version.",
				MarkdownDescription: "Product version.",
			},
		},
	}
}

type TemplateModel struct {
	Id             types.String `tfsdk:"id"`
	Name           types.String `tfsdk:"name"`
	PodGroups      types.List   `tfsdk:"pod_groups"`
	ProductName    types.String `tfsdk:"product_name"`
	ProductVersion types.String `tfsdk:"product_version"`
}

var _ basetypes.ObjectTypable = PodGroupsType{}

type PodGroupsType struct {
	basetypes.ObjectType
}

func (t PodGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsType) String() string {
	return "PodGroupsType"
}

func (t PodGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return nil, diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsValue{
		Count:    countVal,
		Name:     nameVal,
		Resource: resourceVal,
		Volumes:  volumesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueNull() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsValueUnknown() PodGroupsValue {
	return PodGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, a missing attribute value was detected. "+
					"A PodGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsValue Attribute Type",
				"While creating a PodGroupsValue value, an invalid attribute value was detected. "+
					"A PodGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsValue Attribute Value",
				"While creating a PodGroupsValue value, an extra attribute value was detected. "+
					"A PodGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceAttribute, ok := attributes["resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	resourceVal, ok := resourceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource expected to be basetypes.ObjectValue, was: %T`, resourceAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewPodGroupsValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.MapValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsValueUnknown(), diags
	}

	return PodGroupsValue{
		Count:    countVal,
		Name:     nameVal,
		Resource: resourceVal,
		Volumes:  volumesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsValue {
	object, diags := NewPodGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsValueMust(PodGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsValue{}
}

var _ basetypes.ObjectValuable = PodGroupsValue{}

type PodGroupsValue struct {
	Count    basetypes.Int64Value  `tfsdk:"count"`
	Name     basetypes.StringValue `tfsdk:"name"`
	Resource basetypes.ObjectValue `tfsdk:"resource"`
	Volumes  basetypes.MapValue    `tfsdk:"volumes"`
	state    attr.ValueState
}

func (v PodGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource"] = basetypes.ObjectType{
		AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.MapType{
		ElemType: PodGroupsVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Resource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsValue) String() string {
	return "PodGroupsValue"
}

func (v PodGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var resource basetypes.ObjectValue

	if v.Resource.IsNull() {
		resource = types.ObjectNull(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if v.Resource.IsUnknown() {
		resource = types.ObjectUnknown(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Resource.IsNull() && !v.Resource.IsUnknown() {
		resource = types.ObjectValueMust(
			PodGroupsResourceValue{}.AttributeTypes(ctx),
			v.Resource.Attributes(),
		)
	}

	volumes := types.MapValueMust(
		PodGroupsVolumesType{
			basetypes.ObjectType{
				AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.MapNull(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.MapUnknown(
			PodGroupsVolumesType{
				basetypes.ObjectType{
					AttrTypes: PodGroupsVolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":    v.Count,
			"name":     v.Name,
			"resource": resource,
			"volumes":  volumes,
		})

	return objVal, diags
}

func (v PodGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Resource.Equal(other.Resource) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v PodGroupsValue) Type(ctx context.Context) attr.Type {
	return PodGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"resource": basetypes.ObjectType{
			AttrTypes: PodGroupsResourceValue{}.AttributeTypes(ctx),
		},
		"volumes": basetypes.MapType{
			ElemType: PodGroupsVolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PodGroupsResourceType{}

type PodGroupsResourceType struct {
	basetypes.ObjectType
}

func (t PodGroupsResourceType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsResourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsResourceType) String() string {
	return "PodGroupsResourceType"
}

func (t PodGroupsResourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuMarginAttribute, ok := attributes["cpu_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_margin is missing from object`)

		return nil, diags
	}

	cpuMarginVal, ok := cpuMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_margin expected to be basetypes.NumberValue, was: %T`, cpuMarginAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return nil, diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramMarginAttribute, ok := attributes["ram_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_margin is missing from object`)

		return nil, diags
	}

	ramMarginVal, ok := ramMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_margin expected to be basetypes.NumberValue, was: %T`, ramMarginAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return nil, diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsResourceValue{
		CpuMargin:  cpuMarginVal,
		CpuRequest: cpuRequestVal,
		RamMargin:  ramMarginVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueNull() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsResourceValueUnknown() PodGroupsResourceValue {
	return PodGroupsResourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsResourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsResourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, a missing attribute value was detected. "+
					"A PodGroupsResourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsResourceValue Attribute Type",
				"While creating a PodGroupsResourceValue value, an invalid attribute value was detected. "+
					"A PodGroupsResourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsResourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsResourceValue Attribute Value",
				"While creating a PodGroupsResourceValue value, an extra attribute value was detected. "+
					"A PodGroupsResourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsResourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuMarginAttribute, ok := attributes["cpu_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_margin is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuMarginVal, ok := cpuMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_margin expected to be basetypes.NumberValue, was: %T`, cpuMarginAttribute))
	}

	cpuRequestAttribute, ok := attributes["cpu_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	cpuRequestVal, ok := cpuRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_request expected to be basetypes.StringValue, was: %T`, cpuRequestAttribute))
	}

	ramMarginAttribute, ok := attributes["ram_margin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_margin is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramMarginVal, ok := ramMarginAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_margin expected to be basetypes.NumberValue, was: %T`, ramMarginAttribute))
	}

	ramRequestAttribute, ok := attributes["ram_request"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ram_request is missing from object`)

		return NewPodGroupsResourceValueUnknown(), diags
	}

	ramRequestVal, ok := ramRequestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ram_request expected to be basetypes.StringValue, was: %T`, ramRequestAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsResourceValueUnknown(), diags
	}

	return PodGroupsResourceValue{
		CpuMargin:  cpuMarginVal,
		CpuRequest: cpuRequestVal,
		RamMargin:  ramMarginVal,
		RamRequest: ramRequestVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsResourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsResourceValue {
	object, diags := NewPodGroupsResourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsResourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsResourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsResourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsResourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsResourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsResourceValueMust(PodGroupsResourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsResourceType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsResourceValue{}
}

var _ basetypes.ObjectValuable = PodGroupsResourceValue{}

type PodGroupsResourceValue struct {
	CpuMargin  basetypes.NumberValue `tfsdk:"cpu_margin"`
	CpuRequest basetypes.StringValue `tfsdk:"cpu_request"`
	RamMargin  basetypes.NumberValue `tfsdk:"ram_margin"`
	RamRequest basetypes.StringValue `tfsdk:"ram_request"`
	state      attr.ValueState
}

func (v PodGroupsResourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cpu_margin"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["cpu_request"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ram_margin"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["ram_request"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpuMargin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_margin"] = val

		val, err = v.CpuRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_request"] = val

		val, err = v.RamMargin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_margin"] = val

		val, err = v.RamRequest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ram_request"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsResourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsResourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsResourceValue) String() string {
	return "PodGroupsResourceValue"
}

func (v PodGroupsResourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu_margin":  basetypes.NumberType{},
		"cpu_request": basetypes.StringType{},
		"ram_margin":  basetypes.NumberType{},
		"ram_request": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu_margin":  v.CpuMargin,
			"cpu_request": v.CpuRequest,
			"ram_margin":  v.RamMargin,
			"ram_request": v.RamRequest,
		})

	return objVal, diags
}

func (v PodGroupsResourceValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsResourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpuMargin.Equal(other.CpuMargin) {
		return false
	}

	if !v.CpuRequest.Equal(other.CpuRequest) {
		return false
	}

	if !v.RamMargin.Equal(other.RamMargin) {
		return false
	}

	if !v.RamRequest.Equal(other.RamRequest) {
		return false
	}

	return true
}

func (v PodGroupsResourceValue) Type(ctx context.Context) attr.Type {
	return PodGroupsResourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsResourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu_margin":  basetypes.NumberType{},
		"cpu_request": basetypes.StringType{},
		"ram_margin":  basetypes.NumberType{},
		"ram_request": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PodGroupsVolumesType{}

type PodGroupsVolumesType struct {
	basetypes.ObjectType
}

func (t PodGroupsVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(PodGroupsVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PodGroupsVolumesType) String() string {
	return "PodGroupsVolumesType"
}

func (t PodGroupsVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return nil, diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return nil, diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueNull() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewPodGroupsVolumesValueUnknown() PodGroupsVolumesValue {
	return PodGroupsVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPodGroupsVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PodGroupsVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, a missing attribute value was detected. "+
					"A PodGroupsVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PodGroupsVolumesValue Attribute Type",
				"While creating a PodGroupsVolumesValue value, an invalid attribute value was detected. "+
					"A PodGroupsVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PodGroupsVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PodGroupsVolumesValue Attribute Value",
				"While creating a PodGroupsVolumesValue value, an extra attribute value was detected. "+
					"A PodGroupsVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PodGroupsVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	storageAttribute, ok := attributes["storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageVal, ok := storageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage expected to be basetypes.StringValue, was: %T`, storageAttribute))
	}

	storageClassNameAttribute, ok := attributes["storage_class_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_class_name is missing from object`)

		return NewPodGroupsVolumesValueUnknown(), diags
	}

	storageClassNameVal, ok := storageClassNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_class_name expected to be basetypes.StringValue, was: %T`, storageClassNameAttribute))
	}

	if diags.HasError() {
		return NewPodGroupsVolumesValueUnknown(), diags
	}

	return PodGroupsVolumesValue{
		Count:            countVal,
		Storage:          storageVal,
		StorageClassName: storageClassNameVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPodGroupsVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PodGroupsVolumesValue {
	object, diags := NewPodGroupsVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPodGroupsVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PodGroupsVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPodGroupsVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPodGroupsVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPodGroupsVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPodGroupsVolumesValueMust(PodGroupsVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PodGroupsVolumesType) ValueType(ctx context.Context) attr.Value {
	return PodGroupsVolumesValue{}
}

var _ basetypes.ObjectValuable = PodGroupsVolumesValue{}

type PodGroupsVolumesValue struct {
	Count            basetypes.Int64Value  `tfsdk:"count"`
	Storage          basetypes.StringValue `tfsdk:"storage"`
	StorageClassName basetypes.StringValue `tfsdk:"storage_class_name"`
	state            attr.ValueState
}

func (v PodGroupsVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_class_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.Storage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage"] = val

		val, err = v.StorageClassName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_class_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PodGroupsVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PodGroupsVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PodGroupsVolumesValue) String() string {
	return "PodGroupsVolumesValue"
}

func (v PodGroupsVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":              v.Count,
			"storage":            v.Storage,
			"storage_class_name": v.StorageClassName,
		})

	return objVal, diags
}

func (v PodGroupsVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(PodGroupsVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.Storage.Equal(other.Storage) {
		return false
	}

	if !v.StorageClassName.Equal(other.StorageClassName) {
		return false
	}

	return true
}

func (v PodGroupsVolumesValue) Type(ctx context.Context) attr.Type {
	return PodGroupsVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PodGroupsVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":              basetypes.Int64Type{},
		"storage":            basetypes.StringType{},
		"storage_class_name": basetypes.StringType{},
	}
}
