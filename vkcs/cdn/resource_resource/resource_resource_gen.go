// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_resource

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	resource_planmodifiers "github.com/vk-cs/terraform-provider-vkcs/vkcs/cdn/resource_resource/planmodifiers"
	resource_validators "github.com/vk-cs/terraform-provider-vkcs/vkcs/cdn/resource_resource/validators"
	fwtypes "github.com/vk-cs/terraform-provider-vkcs/vkcs/internal/framework/types"
	fwvalidators "github.com/vk-cs/terraform-provider-vkcs/vkcs/internal/framework/validators"
	"github.com/vk-cs/terraform-provider-vkcs/vkcs/internal/services/cdn/v1/resources"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ResourceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"active": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Enables or disables a CDN resource.",
				MarkdownDescription: "Enables or disables a CDN resource.",
			},
			"cname": schema.StringAttribute{
				Required:            true,
				Description:         "Delivery domain that will be used for content delivery through a CDN. Use `secondary_hostnames` to add extra domains. _note_ Delivery domains should be added to your DNS settings.",
				MarkdownDescription: "Delivery domain that will be used for content delivery through a CDN. Use `secondary_hostnames` to add extra domains. _note_ Delivery domains should be added to your DNS settings.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"id": schema.Int64Attribute{
				Computed:            true,
				Description:         "ID of the CDN resource.",
				MarkdownDescription: "ID of the CDN resource.",
			},
			"options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allowed_http_methods": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of HTTP methods.",
								MarkdownDescription: "List of HTTP methods.",
								Validators: []validator.List{
									listvalidator.ValueStringsAre(stringvalidator.OneOf(resources.ResourceAllowedHttpMethodValues()...)),
								},
							},
						},
						CustomType: AllowedHttpMethodsType{
							ObjectType: types.ObjectType{
								AttrTypes: AllowedHttpMethodsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "HTTP methods allowed for content requests from the CDN.",
						MarkdownDescription: "HTTP methods allowed for content requests from the CDN.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"brotli_compression": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.SetAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of content types to be compressed. It's required to specify text/html here.",
								MarkdownDescription: "List of content types to be compressed. It's required to specify text/html here.",
							},
						},
						CustomType: BrotliCompressionType{
							ObjectType: types.ObjectType{
								AttrTypes: BrotliCompressionValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Compresses content with Brotli on the CDN side. CDN servers will request only uncompressed content from the origin.",
						MarkdownDescription: "Compresses content with Brotli on the CDN side. CDN servers will request only uncompressed content from the origin.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"browser_cache_settings": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Cache expiration time. Use '0s' to disable caching.",
								MarkdownDescription: "Cache expiration time. Use '0s' to disable caching.",
								Validators: []validator.String{
									resource_validators.NginxTime(),
								},
							},
						},
						CustomType: BrowserCacheSettingsType{
							ObjectType: types.ObjectType{
								AttrTypes: BrowserCacheSettingsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Cache settings for users browsers.\nCache expiration time is applied to the following response codes: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Responses with other codes will not be cached.",
						MarkdownDescription: "Cache settings for users browsers.\nCache expiration time is applied to the following response codes: 200, 201, 204, 206, 301, 302, 303, 304, 307, 308. Responses with other codes will not be cached.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"cors": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "Value of the Access-Control-Allow-Origin header.\nPossible values:\n* [\"*\"] - adds \"*\" as the header value, content will be uploaded for requests from any domain.\n*[\"domain.com\", \"second.dom.com\"] - adds \"$http_origin\" as the header value if the origin matches one of the listed domains, content will be uploaded only for requests from the domains specified in the field.\n* [\"$http_origin\"] - adds \"$http_origin\" as the header value, content will be uploaded for requests from any domain, and the domain from which the request was sent will be added to the header in the response.",
								MarkdownDescription: "Value of the Access-Control-Allow-Origin header.\nPossible values:\n* [\"*\"] - adds \"*\" as the header value, content will be uploaded for requests from any domain.\n*[\"domain.com\", \"second.dom.com\"] - adds \"$http_origin\" as the header value if the origin matches one of the listed domains, content will be uploaded only for requests from the domains specified in the field.\n* [\"$http_origin\"] - adds \"$http_origin\" as the header value, content will be uploaded for requests from any domain, and the domain from which the request was sent will be added to the header in the response.",
							},
						},
						CustomType: CorsType{
							ObjectType: types.ObjectType{
								AttrTypes: CorsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Enables or disables CORS (Cross-Origin Resource Sharing) header support.\nCORS header support allows the CDN to add the Access-Control-Allow-Origin header to a response to a browser.",
						MarkdownDescription: "Enables or disables CORS (Cross-Origin Resource Sharing) header support.\nCORS header support allows the CDN to add the Access-Control-Allow-Origin header to a response to a browser.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"country_acl": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"excepted_values": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of countries according to ISO-3166-1. The meaning of the argument depends on `policy_type` value.",
								MarkdownDescription: "List of countries according to ISO-3166-1. The meaning of the argument depends on `policy_type` value.",
							},
							"policy_type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								MarkdownDescription: "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								Validators: []validator.String{
									stringvalidator.OneOf(resources.ResourceACLPolicyTypeValues()...),
								},
							},
						},
						CustomType: CountryAclType{
							ObjectType: types.ObjectType{
								AttrTypes: CountryAclValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Use this option to control access to the content for specified countries.",
						MarkdownDescription: "Use this option to control access to the content for specified countries.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"edge_cache_settings": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"custom_values": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "A map representing the caching time for a response with a specific response code.\nThese settings have a higher priority than the value field.\n* Use `any` key to specify caching time for all response codes.\n* Use `0s` value to disable caching for a specific response code.",
								MarkdownDescription: "A map representing the caching time for a response with a specific response code.\nThese settings have a higher priority than the value field.\n* Use `any` key to specify caching time for all response codes.\n* Use `0s` value to disable caching for a specific response code.",
								Validators: []validator.Map{
									mapvalidator.ValueStringsAre(resource_validators.NginxTime()),
								},
							},
							"default": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enables content caching according to the origin cache settings.",
								MarkdownDescription: "Enables content caching according to the origin cache settings.",
								Validators: []validator.String{
									resource_validators.NginxTime(),
								},
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Caching time. The value is applied to the following response codes: 200, 206, 301, 302.\nResponses with codes 4xx, 5xx will not be cached. Use `0s` to disable caching.",
								MarkdownDescription: "Caching time. The value is applied to the following response codes: 200, 206, 301, 302.\nResponses with codes 4xx, 5xx will not be cached. Use `0s` to disable caching.",
								Validators: []validator.String{
									resource_validators.NginxTime(),
								},
							},
						},
						CustomType: EdgeCacheSettingsType{
							ObjectType: types.ObjectType{
								AttrTypes: EdgeCacheSettingsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Cache settings for CDN servers.",
						MarkdownDescription: "Cache settings for CDN servers.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"fetch_compressed": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If enabled, CDN servers request and cache compressed content from the origin. The origin server should support compression. CDN servers will not decompress your content even if a user browser does not accept compression. Conflicts with `gzip_on` if both enabled simultaneously.",
						MarkdownDescription: "If enabled, CDN servers request and cache compressed content from the origin. The origin server should support compression. CDN servers will not decompress your content even if a user browser does not accept compression. Conflicts with `gzip_on` if both enabled simultaneously.",
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.UseStateForUnknown(),
						},
					},
					"force_return": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"body": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "URL for redirection or text.",
								MarkdownDescription: "URL for redirection or text.",
							},
							"code": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Status code value.",
								MarkdownDescription: "Status code value.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
						},
						CustomType: ForceReturnType{
							ObjectType: types.ObjectType{
								AttrTypes: ForceReturnValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Allows to apply custom HTTP code to the CDN content.\nSpecify HTTP-code you need and text or URL if you're going to set up redirection.",
						MarkdownDescription: "Allows to apply custom HTTP code to the CDN content.\nSpecify HTTP-code you need and text or URL if you're going to set up redirection.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"forward_host_header": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Forwards the Host header from a end-user request to an origin server. Conflicts with `host_header` if both enabled simultaneously.",
						MarkdownDescription: "Forwards the Host header from a end-user request to an origin server. Conflicts with `host_header` if both enabled simultaneously.",
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.UseStateForUnknown(),
						},
					},
					"gzip_compression": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.SetAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of content types to be compressed. It's required to specify text/html here.",
								MarkdownDescription: "List of content types to be compressed. It's required to specify text/html here.",
							},
						},
						CustomType: GzipCompressionType{
							ObjectType: types.ObjectType{
								AttrTypes: GzipCompressionValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Compresses content with GZip on the CDN side. CDN servers will request only uncompressed content from the origin. Conflicts with `fetch_compressed`, `slice` and `gzip_on` if any of them are enabled simultaneously. `application/wasm` value is not supported when the shielded option is disabled, compression in this case is performed on the origin shielding, so it must be active for the MIME type to be compressed.",
						MarkdownDescription: "Compresses content with GZip on the CDN side. CDN servers will request only uncompressed content from the origin. Conflicts with `fetch_compressed`, `slice` and `gzip_on` if any of them are enabled simultaneously. `application/wasm` value is not supported when the shielded option is disabled, compression in this case is performed on the origin shielding, so it must be active for the MIME type to be compressed.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"gzip_on": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Enables content compression using gzip on the CDN side. CDN servers will request only uncompressed content from the origin. Conflicts with `fetch_compressed`, `slice` and `gzip_compression` if any of them are enabled simultaneously.",
						MarkdownDescription: "Enables content compression using gzip on the CDN side. CDN servers will request only uncompressed content from the origin. Conflicts with `fetch_compressed`, `slice` and `gzip_compression` if any of them are enabled simultaneously.",
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.UseStateForUnknown(),
						},
						Validators: []validator.Bool{
							boolvalidator.ConflictsWith(path.MatchRoot("options").AtName("gzip_compression")),
						},
					},
					"host_header": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Host Header value.",
								MarkdownDescription: "Host Header value.",
							},
						},
						CustomType: HostHeaderType{
							ObjectType: types.ObjectType{
								AttrTypes: HostHeaderValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Use this option to specify the Host header that CDN servers use when request content from an origin server. If the option is not set, the header value is equal to the first CNAME. Conflicts with `forward_host_header` if both enabled simultaneously.",
						MarkdownDescription: "Use this option to specify the Host header that CDN servers use when request content from an origin server. If the option is not set, the header value is equal to the first CNAME. Conflicts with `forward_host_header` if both enabled simultaneously.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"ignore_cookie": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Defines whether the files with the Set-Cookies header are cached as one file or as different ones.",
						MarkdownDescription: "Defines whether the files with the Set-Cookies header are cached as one file or as different ones.",
					},
					"ignore_query_string": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Allows to specify how a file with different query strings is cached: either as one object (option is enabled) or as different objects (option is disabled.). `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						MarkdownDescription: "Allows to specify how a file with different query strings is cached: either as one object (option is enabled) or as different objects (option is disabled.). `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.UseStateForUnknown(),
						},
					},
					"ip_address_acl": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"excepted_values": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of IP addresses with a subnet mask. The meaning of the argument depends on `policy_type` value.",
								MarkdownDescription: "List of IP addresses with a subnet mask. The meaning of the argument depends on `policy_type` value.",
							},
							"policy_type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								MarkdownDescription: "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								Validators: []validator.String{
									stringvalidator.OneOf(resources.ResourceACLPolicyTypeValues()...),
								},
							},
						},
						CustomType: IpAddressAclType{
							ObjectType: types.ObjectType{
								AttrTypes: IpAddressAclValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The option allows to control access to the CDN Resource content for specific IP addresses.",
						MarkdownDescription: "The option allows to control access to the CDN Resource content for specific IP addresses.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"query_params_blacklist": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of query parameters.",
								MarkdownDescription: "List of query parameters.",
							},
						},
						CustomType: QueryParamsBlacklistType{
							ObjectType: types.ObjectType{
								AttrTypes: QueryParamsBlacklistValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Use this option to specify query parameters, so files with these query strings will be cached as one object, and files with other parameters will be cached as different objects. `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						MarkdownDescription: "Use this option to specify query parameters, so files with these query strings will be cached as one object, and files with other parameters will be cached as different objects. `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"query_params_whitelist": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of query parameters.",
								MarkdownDescription: "List of query parameters.",
							},
						},
						CustomType: QueryParamsWhitelistType{
							ObjectType: types.ObjectType{
								AttrTypes: QueryParamsWhitelistValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Use this option to specify query parameters, so files with these query strings will be cached as different objects, and files with other parameters will be cached as one object. `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						MarkdownDescription: "Use this option to specify query parameters, so files with these query strings will be cached as different objects, and files with other parameters will be cached as one object. `ignore_query_string`, `query_params_whitelist` and `query_params_blacklist` options cannot be enabled simultaneously.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"referrer_acl": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"excepted_values": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of domain names or wildcard domains, without protocol. The meaning of the argument depends on `policy_type` value.",
								MarkdownDescription: "List of domain names or wildcard domains, without protocol. The meaning of the argument depends on `policy_type` value.",
							},
							"policy_type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								MarkdownDescription: "The type of CDN resource access policy. Must be one of following: \"allow\", \"deny\".",
								Validators: []validator.String{
									stringvalidator.OneOf(resources.ResourceACLPolicyTypeValues()...),
								},
							},
						},
						CustomType: ReferrerAclType{
							ObjectType: types.ObjectType{
								AttrTypes: ReferrerAclValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Use this option to control access to the CDN resource content for specified domain names.",
						MarkdownDescription: "Use this option to control access to the CDN resource content for specified domain names.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"secure_key": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"key": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Secure key generated on your side which will be used for the URL signing.",
								MarkdownDescription: "Secure key generated on your side which will be used for the URL signing.",
							},
							"type": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Type of the URL signing. Choose one of the values: 0 — to include the end user's IP address to secure token generation, 2 — to exclude the end user's IP address from the secure token generation.",
								MarkdownDescription: "Type of the URL signing. Choose one of the values: 0 — to include the end user's IP address to secure token generation, 2 — to exclude the end user's IP address from the secure token generation.",
								Validators: []validator.Int64{
									int64validator.OneOf(resources.ResourceSecureKeyTypeValues()...),
								},
							},
						},
						CustomType: SecureKeyType{
							ObjectType: types.ObjectType{
								AttrTypes: SecureKeyValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Configures access with tokenized URLs. This makes impossible to access content without a valid (unexpired) token.",
						MarkdownDescription: "Configures access with tokenized URLs. This makes impossible to access content without a valid (unexpired) token.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"slice": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If enabled, CDN servers request and cache files larger than 10 MB in parts. Origins must support HTTP Range requests.",
						MarkdownDescription: "If enabled, CDN servers request and cache files larger than 10 MB in parts. Origins must support HTTP Range requests.",
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.UseStateForUnknown(),
						},
					},
					"stale": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "The list of errors to which the option is applied.",
								MarkdownDescription: "The list of errors to which the option is applied.",
							},
						},
						CustomType: StaleType{
							ObjectType: types.ObjectType{
								AttrTypes: StaleValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "If enabled, CDN serves stale cached content in case of origin unavailability.",
						MarkdownDescription: "If enabled, CDN serves stale cached content in case of origin unavailability.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"static_headers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "A map of static headers in the format \"header_name\": \"header_value\".",
								MarkdownDescription: "A map of static headers in the format \"header_name\": \"header_value\".",
							},
						},
						CustomType: StaticHeadersType{
							ObjectType: types.ObjectType{
								AttrTypes: StaticHeadersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Custom HTTP Headers that a CDN server adds to a response.",
						MarkdownDescription: "Custom HTTP Headers that a CDN server adds to a response.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"static_request_headers": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "A map of static headers in the format \"header_name\": \"header_value\".",
								MarkdownDescription: "A map of static headers in the format \"header_name\": \"header_value\".",
							},
						},
						CustomType: StaticRequestHeadersType{
							ObjectType: types.ObjectType{
								AttrTypes: StaticRequestHeadersValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Custom HTTP Headers for a CDN server to add to a request.",
						MarkdownDescription: "Custom HTTP Headers for a CDN server to add to a request.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
					"tls_versions": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Controls the option state.",
								MarkdownDescription: "Controls the option state.",
							},
							"value": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of allowed SSL/TLS protocol versions. Allowed values: `SSLv3`, `TLSv1`, `TLSv1.1`, `TLSv1.2`, `TLSv1.3`.",
								MarkdownDescription: "List of allowed SSL/TLS protocol versions. Allowed values: `SSLv3`, `TLSv1`, `TLSv1.1`, `TLSv1.2`, `TLSv1.3`.",
								Validators: []validator.List{
									listvalidator.ValueStringsAre(stringvalidator.OneOf(resources.ResourceTlsVersionValues()...)),
								},
							},
						},
						CustomType: TlsVersionsType{
							ObjectType: types.ObjectType{
								AttrTypes: TlsVersionsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Manage the state of the TLS versions option. The option specifies a list of allowed SSL/TLS protocol versions.",
						MarkdownDescription: "Manage the state of the TLS versions option. The option specifies a list of allowed SSL/TLS protocol versions.",
						PlanModifiers: []planmodifier.Object{
							resource_planmodifiers.ResourceOption(),
						},
					},
				},
				CustomType: OptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: OptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Options that configure a CDN resource.",
				MarkdownDescription: "Options that configure a CDN resource.",
			},
			"origin_group": schema.Int64Attribute{
				Required:            true,
				Description:         "Origin group ID with which the CDN resource is associated.",
				MarkdownDescription: "Origin group ID with which the CDN resource is associated.",
			},
			"origin_protocol": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Protocol used by CDN servers to request content from an origin source. If protocol is not specified, HTTP is used to connect to an origin server.",
				MarkdownDescription: "Protocol used by CDN servers to request content from an origin source. If protocol is not specified, HTTP is used to connect to an origin server.",
			},
			"preset_applied": schema.BoolAttribute{
				Computed:            true,
				Description:         "Protocol used by CDN servers to request content from an origin source. ",
				MarkdownDescription: "Protocol used by CDN servers to request content from an origin source. ",
			},
			"region": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The region in which to obtain the CDN client. If omitted, the `region` argument of the provider is used. Changing this creates a new resource.",
				MarkdownDescription: "The region in which to obtain the CDN client. If omitted, the `region` argument of the provider is used. Changing this creates a new resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
			},
			"secondary_hostnames": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Additional delivery domains (CNAMEs) that will be used to deliver content via the CDN.",
				MarkdownDescription: "Additional delivery domains (CNAMEs) that will be used to deliver content via the CDN.",
				PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},
				Default: listdefault.StaticValue(fwtypes.ListEmpty(types.StringType)),
			},
			"shielding": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Defines whether origin shielding feature is enabled for the resource.",
						MarkdownDescription: "Defines whether origin shielding feature is enabled for the resource.",
					},
					"pop_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "ID of the origin shielding point of presence.",
						MarkdownDescription: "ID of the origin shielding point of presence.",
					},
				},
				CustomType: ShieldingType{
					ObjectType: types.ObjectType{
						AttrTypes: ShieldingValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Use this attribute to configure origin shielding.",
				MarkdownDescription: "Use this attribute to configure origin shielding.",
			},
			"ssl_certificate": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "ID of the SSL certificate linked to the CDN resource. Must be configured when `type` is \"own\".",
						MarkdownDescription: "ID of the SSL certificate linked to the CDN resource. Must be configured when `type` is \"own\".",
					},
					"status": schema.StringAttribute{
						Computed:            true,
						Description:         "Status of the SSL certificate.",
						MarkdownDescription: "Status of the SSL certificate.",
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Type of the SSL certificate. Must be one of following: \"not_used\", \"own\", \"lets_encrypt\".",
						MarkdownDescription: "Type of the SSL certificate. Must be one of following: \"not_used\", \"own\", \"lets_encrypt\".",
					},
				},
				CustomType: SslCertificateType{
					ObjectType: types.ObjectType{
						AttrTypes: SslCertificateValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "SSL certificate settings for content delivery over HTTPS protocol.",
				MarkdownDescription: "SSL certificate settings for content delivery over HTTPS protocol.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "CDN resource status.",
				MarkdownDescription: "CDN resource status.",
			},
			"timeouts": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"create": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							fwvalidators.TimeDuration(),
						},
					},
					"update": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							fwvalidators.TimeDuration(),
						},
					},
				},
				CustomType: timeouts.Type{ObjectType: types.ObjectType{AttrTypes: map[string]attr.Type{"create": types.StringType, "update": types.StringType}}},
				Optional:   true,
			},
			"vp_enabled": schema.BoolAttribute{
				Computed:            true,
				Description:         "Defines whether the CDN resource is integrated with the Streaming Platform.",
				MarkdownDescription: "Defines whether the CDN resource is integrated with the Streaming Platform.",
			},
		},
	}
}

type ResourceModel struct {
	Active             types.Bool          `tfsdk:"active"`
	Cname              types.String        `tfsdk:"cname"`
	Id                 types.Int64         `tfsdk:"id"`
	Options            OptionsValue        `tfsdk:"options"`
	OriginGroup        types.Int64         `tfsdk:"origin_group"`
	OriginProtocol     types.String        `tfsdk:"origin_protocol"`
	PresetApplied      types.Bool          `tfsdk:"preset_applied"`
	Region             types.String        `tfsdk:"region"`
	SecondaryHostnames types.List          `tfsdk:"secondary_hostnames"`
	Shielding          ShieldingValue      `tfsdk:"shielding"`
	SslCertificate     SslCertificateValue `tfsdk:"ssl_certificate"`
	Status             types.String        `tfsdk:"status"`
	Timeouts           timeouts.Value      `tfsdk:"timeouts"`
	VpEnabled          types.Bool          `tfsdk:"vp_enabled"`
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedHttpMethodsAttribute, ok := attributes["allowed_http_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_http_methods is missing from object`)

		return nil, diags
	}

	allowedHttpMethodsVal, ok := allowedHttpMethodsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_http_methods expected to be basetypes.ObjectValue, was: %T`, allowedHttpMethodsAttribute))
	}

	brotliCompressionAttribute, ok := attributes["brotli_compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brotli_compression is missing from object`)

		return nil, diags
	}

	brotliCompressionVal, ok := brotliCompressionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brotli_compression expected to be basetypes.ObjectValue, was: %T`, brotliCompressionAttribute))
	}

	browserCacheSettingsAttribute, ok := attributes["browser_cache_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`browser_cache_settings is missing from object`)

		return nil, diags
	}

	browserCacheSettingsVal, ok := browserCacheSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`browser_cache_settings expected to be basetypes.ObjectValue, was: %T`, browserCacheSettingsAttribute))
	}

	corsAttribute, ok := attributes["cors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cors is missing from object`)

		return nil, diags
	}

	corsVal, ok := corsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cors expected to be basetypes.ObjectValue, was: %T`, corsAttribute))
	}

	countryAclAttribute, ok := attributes["country_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_acl is missing from object`)

		return nil, diags
	}

	countryAclVal, ok := countryAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_acl expected to be basetypes.ObjectValue, was: %T`, countryAclAttribute))
	}

	edgeCacheSettingsAttribute, ok := attributes["edge_cache_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`edge_cache_settings is missing from object`)

		return nil, diags
	}

	edgeCacheSettingsVal, ok := edgeCacheSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`edge_cache_settings expected to be basetypes.ObjectValue, was: %T`, edgeCacheSettingsAttribute))
	}

	fetchCompressedAttribute, ok := attributes["fetch_compressed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fetch_compressed is missing from object`)

		return nil, diags
	}

	fetchCompressedVal, ok := fetchCompressedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fetch_compressed expected to be basetypes.BoolValue, was: %T`, fetchCompressedAttribute))
	}

	forceReturnAttribute, ok := attributes["force_return"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_return is missing from object`)

		return nil, diags
	}

	forceReturnVal, ok := forceReturnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_return expected to be basetypes.ObjectValue, was: %T`, forceReturnAttribute))
	}

	forwardHostHeaderAttribute, ok := attributes["forward_host_header"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_host_header is missing from object`)

		return nil, diags
	}

	forwardHostHeaderVal, ok := forwardHostHeaderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_host_header expected to be basetypes.BoolValue, was: %T`, forwardHostHeaderAttribute))
	}

	gzipCompressionAttribute, ok := attributes["gzip_compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gzip_compression is missing from object`)

		return nil, diags
	}

	gzipCompressionVal, ok := gzipCompressionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gzip_compression expected to be basetypes.ObjectValue, was: %T`, gzipCompressionAttribute))
	}

	gzipOnAttribute, ok := attributes["gzip_on"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gzip_on is missing from object`)

		return nil, diags
	}

	gzipOnVal, ok := gzipOnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gzip_on expected to be basetypes.BoolValue, was: %T`, gzipOnAttribute))
	}

	hostHeaderAttribute, ok := attributes["host_header"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_header is missing from object`)

		return nil, diags
	}

	hostHeaderVal, ok := hostHeaderAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_header expected to be basetypes.ObjectValue, was: %T`, hostHeaderAttribute))
	}

	ignoreCookieAttribute, ok := attributes["ignore_cookie"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_cookie is missing from object`)

		return nil, diags
	}

	ignoreCookieVal, ok := ignoreCookieAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_cookie expected to be basetypes.BoolValue, was: %T`, ignoreCookieAttribute))
	}

	ignoreQueryStringAttribute, ok := attributes["ignore_query_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_query_string is missing from object`)

		return nil, diags
	}

	ignoreQueryStringVal, ok := ignoreQueryStringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_query_string expected to be basetypes.BoolValue, was: %T`, ignoreQueryStringAttribute))
	}

	ipAddressAclAttribute, ok := attributes["ip_address_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address_acl is missing from object`)

		return nil, diags
	}

	ipAddressAclVal, ok := ipAddressAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address_acl expected to be basetypes.ObjectValue, was: %T`, ipAddressAclAttribute))
	}

	queryParamsBlacklistAttribute, ok := attributes["query_params_blacklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_params_blacklist is missing from object`)

		return nil, diags
	}

	queryParamsBlacklistVal, ok := queryParamsBlacklistAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_params_blacklist expected to be basetypes.ObjectValue, was: %T`, queryParamsBlacklistAttribute))
	}

	queryParamsWhitelistAttribute, ok := attributes["query_params_whitelist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_params_whitelist is missing from object`)

		return nil, diags
	}

	queryParamsWhitelistVal, ok := queryParamsWhitelistAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_params_whitelist expected to be basetypes.ObjectValue, was: %T`, queryParamsWhitelistAttribute))
	}

	referrerAclAttribute, ok := attributes["referrer_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referrer_acl is missing from object`)

		return nil, diags
	}

	referrerAclVal, ok := referrerAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referrer_acl expected to be basetypes.ObjectValue, was: %T`, referrerAclAttribute))
	}

	secureKeyAttribute, ok := attributes["secure_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_key is missing from object`)

		return nil, diags
	}

	secureKeyVal, ok := secureKeyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_key expected to be basetypes.ObjectValue, was: %T`, secureKeyAttribute))
	}

	sliceAttribute, ok := attributes["slice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slice is missing from object`)

		return nil, diags
	}

	sliceVal, ok := sliceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slice expected to be basetypes.BoolValue, was: %T`, sliceAttribute))
	}

	staleAttribute, ok := attributes["stale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stale is missing from object`)

		return nil, diags
	}

	staleVal, ok := staleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stale expected to be basetypes.ObjectValue, was: %T`, staleAttribute))
	}

	staticHeadersAttribute, ok := attributes["static_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_headers is missing from object`)

		return nil, diags
	}

	staticHeadersVal, ok := staticHeadersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_headers expected to be basetypes.ObjectValue, was: %T`, staticHeadersAttribute))
	}

	staticRequestHeadersAttribute, ok := attributes["static_request_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_request_headers is missing from object`)

		return nil, diags
	}

	staticRequestHeadersVal, ok := staticRequestHeadersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_request_headers expected to be basetypes.ObjectValue, was: %T`, staticRequestHeadersAttribute))
	}

	tlsVersionsAttribute, ok := attributes["tls_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls_versions is missing from object`)

		return nil, diags
	}

	tlsVersionsVal, ok := tlsVersionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls_versions expected to be basetypes.ObjectValue, was: %T`, tlsVersionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		AllowedHttpMethods:   allowedHttpMethodsVal,
		BrotliCompression:    brotliCompressionVal,
		BrowserCacheSettings: browserCacheSettingsVal,
		Cors:                 corsVal,
		CountryAcl:           countryAclVal,
		EdgeCacheSettings:    edgeCacheSettingsVal,
		FetchCompressed:      fetchCompressedVal,
		ForceReturn:          forceReturnVal,
		ForwardHostHeader:    forwardHostHeaderVal,
		GzipCompression:      gzipCompressionVal,
		GzipOn:               gzipOnVal,
		HostHeader:           hostHeaderVal,
		IgnoreCookie:         ignoreCookieVal,
		IgnoreQueryString:    ignoreQueryStringVal,
		IpAddressAcl:         ipAddressAclVal,
		QueryParamsBlacklist: queryParamsBlacklistVal,
		QueryParamsWhitelist: queryParamsWhitelistVal,
		ReferrerAcl:          referrerAclVal,
		SecureKey:            secureKeyVal,
		Slice:                sliceVal,
		Stale:                staleVal,
		StaticHeaders:        staticHeadersVal,
		StaticRequestHeaders: staticRequestHeadersVal,
		TlsVersions:          tlsVersionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	allowedHttpMethodsAttribute, ok := attributes["allowed_http_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_http_methods is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	allowedHttpMethodsVal, ok := allowedHttpMethodsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_http_methods expected to be basetypes.ObjectValue, was: %T`, allowedHttpMethodsAttribute))
	}

	brotliCompressionAttribute, ok := attributes["brotli_compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brotli_compression is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	brotliCompressionVal, ok := brotliCompressionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brotli_compression expected to be basetypes.ObjectValue, was: %T`, brotliCompressionAttribute))
	}

	browserCacheSettingsAttribute, ok := attributes["browser_cache_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`browser_cache_settings is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	browserCacheSettingsVal, ok := browserCacheSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`browser_cache_settings expected to be basetypes.ObjectValue, was: %T`, browserCacheSettingsAttribute))
	}

	corsAttribute, ok := attributes["cors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cors is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	corsVal, ok := corsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cors expected to be basetypes.ObjectValue, was: %T`, corsAttribute))
	}

	countryAclAttribute, ok := attributes["country_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_acl is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	countryAclVal, ok := countryAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_acl expected to be basetypes.ObjectValue, was: %T`, countryAclAttribute))
	}

	edgeCacheSettingsAttribute, ok := attributes["edge_cache_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`edge_cache_settings is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	edgeCacheSettingsVal, ok := edgeCacheSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`edge_cache_settings expected to be basetypes.ObjectValue, was: %T`, edgeCacheSettingsAttribute))
	}

	fetchCompressedAttribute, ok := attributes["fetch_compressed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fetch_compressed is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	fetchCompressedVal, ok := fetchCompressedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fetch_compressed expected to be basetypes.BoolValue, was: %T`, fetchCompressedAttribute))
	}

	forceReturnAttribute, ok := attributes["force_return"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_return is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	forceReturnVal, ok := forceReturnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_return expected to be basetypes.ObjectValue, was: %T`, forceReturnAttribute))
	}

	forwardHostHeaderAttribute, ok := attributes["forward_host_header"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_host_header is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	forwardHostHeaderVal, ok := forwardHostHeaderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_host_header expected to be basetypes.BoolValue, was: %T`, forwardHostHeaderAttribute))
	}

	gzipCompressionAttribute, ok := attributes["gzip_compression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gzip_compression is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	gzipCompressionVal, ok := gzipCompressionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gzip_compression expected to be basetypes.ObjectValue, was: %T`, gzipCompressionAttribute))
	}

	gzipOnAttribute, ok := attributes["gzip_on"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gzip_on is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	gzipOnVal, ok := gzipOnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gzip_on expected to be basetypes.BoolValue, was: %T`, gzipOnAttribute))
	}

	hostHeaderAttribute, ok := attributes["host_header"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_header is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	hostHeaderVal, ok := hostHeaderAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_header expected to be basetypes.ObjectValue, was: %T`, hostHeaderAttribute))
	}

	ignoreCookieAttribute, ok := attributes["ignore_cookie"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_cookie is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	ignoreCookieVal, ok := ignoreCookieAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_cookie expected to be basetypes.BoolValue, was: %T`, ignoreCookieAttribute))
	}

	ignoreQueryStringAttribute, ok := attributes["ignore_query_string"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_query_string is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	ignoreQueryStringVal, ok := ignoreQueryStringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_query_string expected to be basetypes.BoolValue, was: %T`, ignoreQueryStringAttribute))
	}

	ipAddressAclAttribute, ok := attributes["ip_address_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address_acl is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	ipAddressAclVal, ok := ipAddressAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address_acl expected to be basetypes.ObjectValue, was: %T`, ipAddressAclAttribute))
	}

	queryParamsBlacklistAttribute, ok := attributes["query_params_blacklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_params_blacklist is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	queryParamsBlacklistVal, ok := queryParamsBlacklistAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_params_blacklist expected to be basetypes.ObjectValue, was: %T`, queryParamsBlacklistAttribute))
	}

	queryParamsWhitelistAttribute, ok := attributes["query_params_whitelist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_params_whitelist is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	queryParamsWhitelistVal, ok := queryParamsWhitelistAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_params_whitelist expected to be basetypes.ObjectValue, was: %T`, queryParamsWhitelistAttribute))
	}

	referrerAclAttribute, ok := attributes["referrer_acl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`referrer_acl is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	referrerAclVal, ok := referrerAclAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`referrer_acl expected to be basetypes.ObjectValue, was: %T`, referrerAclAttribute))
	}

	secureKeyAttribute, ok := attributes["secure_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secure_key is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	secureKeyVal, ok := secureKeyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secure_key expected to be basetypes.ObjectValue, was: %T`, secureKeyAttribute))
	}

	sliceAttribute, ok := attributes["slice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slice is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	sliceVal, ok := sliceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slice expected to be basetypes.BoolValue, was: %T`, sliceAttribute))
	}

	staleAttribute, ok := attributes["stale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stale is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	staleVal, ok := staleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stale expected to be basetypes.ObjectValue, was: %T`, staleAttribute))
	}

	staticHeadersAttribute, ok := attributes["static_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_headers is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	staticHeadersVal, ok := staticHeadersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_headers expected to be basetypes.ObjectValue, was: %T`, staticHeadersAttribute))
	}

	staticRequestHeadersAttribute, ok := attributes["static_request_headers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_request_headers is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	staticRequestHeadersVal, ok := staticRequestHeadersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_request_headers expected to be basetypes.ObjectValue, was: %T`, staticRequestHeadersAttribute))
	}

	tlsVersionsAttribute, ok := attributes["tls_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tls_versions is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	tlsVersionsVal, ok := tlsVersionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tls_versions expected to be basetypes.ObjectValue, was: %T`, tlsVersionsAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		AllowedHttpMethods:   allowedHttpMethodsVal,
		BrotliCompression:    brotliCompressionVal,
		BrowserCacheSettings: browserCacheSettingsVal,
		Cors:                 corsVal,
		CountryAcl:           countryAclVal,
		EdgeCacheSettings:    edgeCacheSettingsVal,
		FetchCompressed:      fetchCompressedVal,
		ForceReturn:          forceReturnVal,
		ForwardHostHeader:    forwardHostHeaderVal,
		GzipCompression:      gzipCompressionVal,
		GzipOn:               gzipOnVal,
		HostHeader:           hostHeaderVal,
		IgnoreCookie:         ignoreCookieVal,
		IgnoreQueryString:    ignoreQueryStringVal,
		IpAddressAcl:         ipAddressAclVal,
		QueryParamsBlacklist: queryParamsBlacklistVal,
		QueryParamsWhitelist: queryParamsWhitelistVal,
		ReferrerAcl:          referrerAclVal,
		SecureKey:            secureKeyVal,
		Slice:                sliceVal,
		Stale:                staleVal,
		StaticHeaders:        staticHeadersVal,
		StaticRequestHeaders: staticRequestHeadersVal,
		TlsVersions:          tlsVersionsVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	AllowedHttpMethods   basetypes.ObjectValue `tfsdk:"allowed_http_methods"`
	BrotliCompression    basetypes.ObjectValue `tfsdk:"brotli_compression"`
	BrowserCacheSettings basetypes.ObjectValue `tfsdk:"browser_cache_settings"`
	Cors                 basetypes.ObjectValue `tfsdk:"cors"`
	CountryAcl           basetypes.ObjectValue `tfsdk:"country_acl"`
	EdgeCacheSettings    basetypes.ObjectValue `tfsdk:"edge_cache_settings"`
	FetchCompressed      basetypes.BoolValue   `tfsdk:"fetch_compressed"`
	ForceReturn          basetypes.ObjectValue `tfsdk:"force_return"`
	ForwardHostHeader    basetypes.BoolValue   `tfsdk:"forward_host_header"`
	GzipCompression      basetypes.ObjectValue `tfsdk:"gzip_compression"`
	GzipOn               basetypes.BoolValue   `tfsdk:"gzip_on"`
	HostHeader           basetypes.ObjectValue `tfsdk:"host_header"`
	IgnoreCookie         basetypes.BoolValue   `tfsdk:"ignore_cookie"`
	IgnoreQueryString    basetypes.BoolValue   `tfsdk:"ignore_query_string"`
	IpAddressAcl         basetypes.ObjectValue `tfsdk:"ip_address_acl"`
	QueryParamsBlacklist basetypes.ObjectValue `tfsdk:"query_params_blacklist"`
	QueryParamsWhitelist basetypes.ObjectValue `tfsdk:"query_params_whitelist"`
	ReferrerAcl          basetypes.ObjectValue `tfsdk:"referrer_acl"`
	SecureKey            basetypes.ObjectValue `tfsdk:"secure_key"`
	Slice                basetypes.BoolValue   `tfsdk:"slice"`
	Stale                basetypes.ObjectValue `tfsdk:"stale"`
	StaticHeaders        basetypes.ObjectValue `tfsdk:"static_headers"`
	StaticRequestHeaders basetypes.ObjectValue `tfsdk:"static_request_headers"`
	TlsVersions          basetypes.ObjectValue `tfsdk:"tls_versions"`
	state                attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 24)

	var val tftypes.Value
	var err error

	attrTypes["allowed_http_methods"] = basetypes.ObjectType{
		AttrTypes: AllowedHttpMethodsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["brotli_compression"] = basetypes.ObjectType{
		AttrTypes: BrotliCompressionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["browser_cache_settings"] = basetypes.ObjectType{
		AttrTypes: BrowserCacheSettingsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cors"] = basetypes.ObjectType{
		AttrTypes: CorsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["country_acl"] = basetypes.ObjectType{
		AttrTypes: CountryAclValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["edge_cache_settings"] = basetypes.ObjectType{
		AttrTypes: EdgeCacheSettingsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fetch_compressed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["force_return"] = basetypes.ObjectType{
		AttrTypes: ForceReturnValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["forward_host_header"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gzip_compression"] = basetypes.ObjectType{
		AttrTypes: GzipCompressionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["gzip_on"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host_header"] = basetypes.ObjectType{
		AttrTypes: HostHeaderValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ignore_cookie"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ignore_query_string"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_address_acl"] = basetypes.ObjectType{
		AttrTypes: IpAddressAclValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["query_params_blacklist"] = basetypes.ObjectType{
		AttrTypes: QueryParamsBlacklistValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["query_params_whitelist"] = basetypes.ObjectType{
		AttrTypes: QueryParamsWhitelistValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["referrer_acl"] = basetypes.ObjectType{
		AttrTypes: ReferrerAclValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["secure_key"] = basetypes.ObjectType{
		AttrTypes: SecureKeyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["slice"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["stale"] = basetypes.ObjectType{
		AttrTypes: StaleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static_headers"] = basetypes.ObjectType{
		AttrTypes: StaticHeadersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static_request_headers"] = basetypes.ObjectType{
		AttrTypes: StaticRequestHeadersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tls_versions"] = basetypes.ObjectType{
		AttrTypes: TlsVersionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 24)

		val, err = v.AllowedHttpMethods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_http_methods"] = val

		val, err = v.BrotliCompression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["brotli_compression"] = val

		val, err = v.BrowserCacheSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["browser_cache_settings"] = val

		val, err = v.Cors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cors"] = val

		val, err = v.CountryAcl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_acl"] = val

		val, err = v.EdgeCacheSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["edge_cache_settings"] = val

		val, err = v.FetchCompressed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fetch_compressed"] = val

		val, err = v.ForceReturn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["force_return"] = val

		val, err = v.ForwardHostHeader.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forward_host_header"] = val

		val, err = v.GzipCompression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gzip_compression"] = val

		val, err = v.GzipOn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gzip_on"] = val

		val, err = v.HostHeader.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_header"] = val

		val, err = v.IgnoreCookie.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_cookie"] = val

		val, err = v.IgnoreQueryString.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_query_string"] = val

		val, err = v.IpAddressAcl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address_acl"] = val

		val, err = v.QueryParamsBlacklist.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query_params_blacklist"] = val

		val, err = v.QueryParamsWhitelist.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query_params_whitelist"] = val

		val, err = v.ReferrerAcl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["referrer_acl"] = val

		val, err = v.SecureKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secure_key"] = val

		val, err = v.Slice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slice"] = val

		val, err = v.Stale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stale"] = val

		val, err = v.StaticHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_headers"] = val

		val, err = v.StaticRequestHeaders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_request_headers"] = val

		val, err = v.TlsVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tls_versions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var allowedHttpMethods basetypes.ObjectValue

	if v.AllowedHttpMethods.IsNull() {
		allowedHttpMethods = types.ObjectNull(
			AllowedHttpMethodsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AllowedHttpMethods.IsUnknown() {
		allowedHttpMethods = types.ObjectUnknown(
			AllowedHttpMethodsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AllowedHttpMethods.IsNull() && !v.AllowedHttpMethods.IsUnknown() {
		allowedHttpMethods = types.ObjectValueMust(
			AllowedHttpMethodsValue{}.AttributeTypes(ctx),
			v.AllowedHttpMethods.Attributes(),
		)
	}

	var brotliCompression basetypes.ObjectValue

	if v.BrotliCompression.IsNull() {
		brotliCompression = types.ObjectNull(
			BrotliCompressionValue{}.AttributeTypes(ctx),
		)
	}

	if v.BrotliCompression.IsUnknown() {
		brotliCompression = types.ObjectUnknown(
			BrotliCompressionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BrotliCompression.IsNull() && !v.BrotliCompression.IsUnknown() {
		brotliCompression = types.ObjectValueMust(
			BrotliCompressionValue{}.AttributeTypes(ctx),
			v.BrotliCompression.Attributes(),
		)
	}

	var browserCacheSettings basetypes.ObjectValue

	if v.BrowserCacheSettings.IsNull() {
		browserCacheSettings = types.ObjectNull(
			BrowserCacheSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if v.BrowserCacheSettings.IsUnknown() {
		browserCacheSettings = types.ObjectUnknown(
			BrowserCacheSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BrowserCacheSettings.IsNull() && !v.BrowserCacheSettings.IsUnknown() {
		browserCacheSettings = types.ObjectValueMust(
			BrowserCacheSettingsValue{}.AttributeTypes(ctx),
			v.BrowserCacheSettings.Attributes(),
		)
	}

	var cors basetypes.ObjectValue

	if v.Cors.IsNull() {
		cors = types.ObjectNull(
			CorsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Cors.IsUnknown() {
		cors = types.ObjectUnknown(
			CorsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Cors.IsNull() && !v.Cors.IsUnknown() {
		cors = types.ObjectValueMust(
			CorsValue{}.AttributeTypes(ctx),
			v.Cors.Attributes(),
		)
	}

	var countryAcl basetypes.ObjectValue

	if v.CountryAcl.IsNull() {
		countryAcl = types.ObjectNull(
			CountryAclValue{}.AttributeTypes(ctx),
		)
	}

	if v.CountryAcl.IsUnknown() {
		countryAcl = types.ObjectUnknown(
			CountryAclValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CountryAcl.IsNull() && !v.CountryAcl.IsUnknown() {
		countryAcl = types.ObjectValueMust(
			CountryAclValue{}.AttributeTypes(ctx),
			v.CountryAcl.Attributes(),
		)
	}

	var edgeCacheSettings basetypes.ObjectValue

	if v.EdgeCacheSettings.IsNull() {
		edgeCacheSettings = types.ObjectNull(
			EdgeCacheSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if v.EdgeCacheSettings.IsUnknown() {
		edgeCacheSettings = types.ObjectUnknown(
			EdgeCacheSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EdgeCacheSettings.IsNull() && !v.EdgeCacheSettings.IsUnknown() {
		edgeCacheSettings = types.ObjectValueMust(
			EdgeCacheSettingsValue{}.AttributeTypes(ctx),
			v.EdgeCacheSettings.Attributes(),
		)
	}

	var forceReturn basetypes.ObjectValue

	if v.ForceReturn.IsNull() {
		forceReturn = types.ObjectNull(
			ForceReturnValue{}.AttributeTypes(ctx),
		)
	}

	if v.ForceReturn.IsUnknown() {
		forceReturn = types.ObjectUnknown(
			ForceReturnValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ForceReturn.IsNull() && !v.ForceReturn.IsUnknown() {
		forceReturn = types.ObjectValueMust(
			ForceReturnValue{}.AttributeTypes(ctx),
			v.ForceReturn.Attributes(),
		)
	}

	var gzipCompression basetypes.ObjectValue

	if v.GzipCompression.IsNull() {
		gzipCompression = types.ObjectNull(
			GzipCompressionValue{}.AttributeTypes(ctx),
		)
	}

	if v.GzipCompression.IsUnknown() {
		gzipCompression = types.ObjectUnknown(
			GzipCompressionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.GzipCompression.IsNull() && !v.GzipCompression.IsUnknown() {
		gzipCompression = types.ObjectValueMust(
			GzipCompressionValue{}.AttributeTypes(ctx),
			v.GzipCompression.Attributes(),
		)
	}

	var hostHeader basetypes.ObjectValue

	if v.HostHeader.IsNull() {
		hostHeader = types.ObjectNull(
			HostHeaderValue{}.AttributeTypes(ctx),
		)
	}

	if v.HostHeader.IsUnknown() {
		hostHeader = types.ObjectUnknown(
			HostHeaderValue{}.AttributeTypes(ctx),
		)
	}

	if !v.HostHeader.IsNull() && !v.HostHeader.IsUnknown() {
		hostHeader = types.ObjectValueMust(
			HostHeaderValue{}.AttributeTypes(ctx),
			v.HostHeader.Attributes(),
		)
	}

	var ipAddressAcl basetypes.ObjectValue

	if v.IpAddressAcl.IsNull() {
		ipAddressAcl = types.ObjectNull(
			IpAddressAclValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpAddressAcl.IsUnknown() {
		ipAddressAcl = types.ObjectUnknown(
			IpAddressAclValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpAddressAcl.IsNull() && !v.IpAddressAcl.IsUnknown() {
		ipAddressAcl = types.ObjectValueMust(
			IpAddressAclValue{}.AttributeTypes(ctx),
			v.IpAddressAcl.Attributes(),
		)
	}

	var queryParamsBlacklist basetypes.ObjectValue

	if v.QueryParamsBlacklist.IsNull() {
		queryParamsBlacklist = types.ObjectNull(
			QueryParamsBlacklistValue{}.AttributeTypes(ctx),
		)
	}

	if v.QueryParamsBlacklist.IsUnknown() {
		queryParamsBlacklist = types.ObjectUnknown(
			QueryParamsBlacklistValue{}.AttributeTypes(ctx),
		)
	}

	if !v.QueryParamsBlacklist.IsNull() && !v.QueryParamsBlacklist.IsUnknown() {
		queryParamsBlacklist = types.ObjectValueMust(
			QueryParamsBlacklistValue{}.AttributeTypes(ctx),
			v.QueryParamsBlacklist.Attributes(),
		)
	}

	var queryParamsWhitelist basetypes.ObjectValue

	if v.QueryParamsWhitelist.IsNull() {
		queryParamsWhitelist = types.ObjectNull(
			QueryParamsWhitelistValue{}.AttributeTypes(ctx),
		)
	}

	if v.QueryParamsWhitelist.IsUnknown() {
		queryParamsWhitelist = types.ObjectUnknown(
			QueryParamsWhitelistValue{}.AttributeTypes(ctx),
		)
	}

	if !v.QueryParamsWhitelist.IsNull() && !v.QueryParamsWhitelist.IsUnknown() {
		queryParamsWhitelist = types.ObjectValueMust(
			QueryParamsWhitelistValue{}.AttributeTypes(ctx),
			v.QueryParamsWhitelist.Attributes(),
		)
	}

	var referrerAcl basetypes.ObjectValue

	if v.ReferrerAcl.IsNull() {
		referrerAcl = types.ObjectNull(
			ReferrerAclValue{}.AttributeTypes(ctx),
		)
	}

	if v.ReferrerAcl.IsUnknown() {
		referrerAcl = types.ObjectUnknown(
			ReferrerAclValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ReferrerAcl.IsNull() && !v.ReferrerAcl.IsUnknown() {
		referrerAcl = types.ObjectValueMust(
			ReferrerAclValue{}.AttributeTypes(ctx),
			v.ReferrerAcl.Attributes(),
		)
	}

	var secureKey basetypes.ObjectValue

	if v.SecureKey.IsNull() {
		secureKey = types.ObjectNull(
			SecureKeyValue{}.AttributeTypes(ctx),
		)
	}

	if v.SecureKey.IsUnknown() {
		secureKey = types.ObjectUnknown(
			SecureKeyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SecureKey.IsNull() && !v.SecureKey.IsUnknown() {
		secureKey = types.ObjectValueMust(
			SecureKeyValue{}.AttributeTypes(ctx),
			v.SecureKey.Attributes(),
		)
	}

	var stale basetypes.ObjectValue

	if v.Stale.IsNull() {
		stale = types.ObjectNull(
			StaleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Stale.IsUnknown() {
		stale = types.ObjectUnknown(
			StaleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Stale.IsNull() && !v.Stale.IsUnknown() {
		stale = types.ObjectValueMust(
			StaleValue{}.AttributeTypes(ctx),
			v.Stale.Attributes(),
		)
	}

	var staticHeaders basetypes.ObjectValue

	if v.StaticHeaders.IsNull() {
		staticHeaders = types.ObjectNull(
			StaticHeadersValue{}.AttributeTypes(ctx),
		)
	}

	if v.StaticHeaders.IsUnknown() {
		staticHeaders = types.ObjectUnknown(
			StaticHeadersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StaticHeaders.IsNull() && !v.StaticHeaders.IsUnknown() {
		staticHeaders = types.ObjectValueMust(
			StaticHeadersValue{}.AttributeTypes(ctx),
			v.StaticHeaders.Attributes(),
		)
	}

	var staticRequestHeaders basetypes.ObjectValue

	if v.StaticRequestHeaders.IsNull() {
		staticRequestHeaders = types.ObjectNull(
			StaticRequestHeadersValue{}.AttributeTypes(ctx),
		)
	}

	if v.StaticRequestHeaders.IsUnknown() {
		staticRequestHeaders = types.ObjectUnknown(
			StaticRequestHeadersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StaticRequestHeaders.IsNull() && !v.StaticRequestHeaders.IsUnknown() {
		staticRequestHeaders = types.ObjectValueMust(
			StaticRequestHeadersValue{}.AttributeTypes(ctx),
			v.StaticRequestHeaders.Attributes(),
		)
	}

	var tlsVersions basetypes.ObjectValue

	if v.TlsVersions.IsNull() {
		tlsVersions = types.ObjectNull(
			TlsVersionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.TlsVersions.IsUnknown() {
		tlsVersions = types.ObjectUnknown(
			TlsVersionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TlsVersions.IsNull() && !v.TlsVersions.IsUnknown() {
		tlsVersions = types.ObjectValueMust(
			TlsVersionsValue{}.AttributeTypes(ctx),
			v.TlsVersions.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_http_methods": basetypes.ObjectType{
			AttrTypes: AllowedHttpMethodsValue{}.AttributeTypes(ctx),
		},
		"brotli_compression": basetypes.ObjectType{
			AttrTypes: BrotliCompressionValue{}.AttributeTypes(ctx),
		},
		"browser_cache_settings": basetypes.ObjectType{
			AttrTypes: BrowserCacheSettingsValue{}.AttributeTypes(ctx),
		},
		"cors": basetypes.ObjectType{
			AttrTypes: CorsValue{}.AttributeTypes(ctx),
		},
		"country_acl": basetypes.ObjectType{
			AttrTypes: CountryAclValue{}.AttributeTypes(ctx),
		},
		"edge_cache_settings": basetypes.ObjectType{
			AttrTypes: EdgeCacheSettingsValue{}.AttributeTypes(ctx),
		},
		"fetch_compressed": basetypes.BoolType{},
		"force_return": basetypes.ObjectType{
			AttrTypes: ForceReturnValue{}.AttributeTypes(ctx),
		},
		"forward_host_header": basetypes.BoolType{},
		"gzip_compression": basetypes.ObjectType{
			AttrTypes: GzipCompressionValue{}.AttributeTypes(ctx),
		},
		"gzip_on": basetypes.BoolType{},
		"host_header": basetypes.ObjectType{
			AttrTypes: HostHeaderValue{}.AttributeTypes(ctx),
		},
		"ignore_cookie":       basetypes.BoolType{},
		"ignore_query_string": basetypes.BoolType{},
		"ip_address_acl": basetypes.ObjectType{
			AttrTypes: IpAddressAclValue{}.AttributeTypes(ctx),
		},
		"query_params_blacklist": basetypes.ObjectType{
			AttrTypes: QueryParamsBlacklistValue{}.AttributeTypes(ctx),
		},
		"query_params_whitelist": basetypes.ObjectType{
			AttrTypes: QueryParamsWhitelistValue{}.AttributeTypes(ctx),
		},
		"referrer_acl": basetypes.ObjectType{
			AttrTypes: ReferrerAclValue{}.AttributeTypes(ctx),
		},
		"secure_key": basetypes.ObjectType{
			AttrTypes: SecureKeyValue{}.AttributeTypes(ctx),
		},
		"slice": basetypes.BoolType{},
		"stale": basetypes.ObjectType{
			AttrTypes: StaleValue{}.AttributeTypes(ctx),
		},
		"static_headers": basetypes.ObjectType{
			AttrTypes: StaticHeadersValue{}.AttributeTypes(ctx),
		},
		"static_request_headers": basetypes.ObjectType{
			AttrTypes: StaticRequestHeadersValue{}.AttributeTypes(ctx),
		},
		"tls_versions": basetypes.ObjectType{
			AttrTypes: TlsVersionsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_http_methods":   allowedHttpMethods,
			"brotli_compression":     brotliCompression,
			"browser_cache_settings": browserCacheSettings,
			"cors":                   cors,
			"country_acl":            countryAcl,
			"edge_cache_settings":    edgeCacheSettings,
			"fetch_compressed":       v.FetchCompressed,
			"force_return":           forceReturn,
			"forward_host_header":    v.ForwardHostHeader,
			"gzip_compression":       gzipCompression,
			"gzip_on":                v.GzipOn,
			"host_header":            hostHeader,
			"ignore_cookie":          v.IgnoreCookie,
			"ignore_query_string":    v.IgnoreQueryString,
			"ip_address_acl":         ipAddressAcl,
			"query_params_blacklist": queryParamsBlacklist,
			"query_params_whitelist": queryParamsWhitelist,
			"referrer_acl":           referrerAcl,
			"secure_key":             secureKey,
			"slice":                  v.Slice,
			"stale":                  stale,
			"static_headers":         staticHeaders,
			"static_request_headers": staticRequestHeaders,
			"tls_versions":           tlsVersions,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedHttpMethods.Equal(other.AllowedHttpMethods) {
		return false
	}

	if !v.BrotliCompression.Equal(other.BrotliCompression) {
		return false
	}

	if !v.BrowserCacheSettings.Equal(other.BrowserCacheSettings) {
		return false
	}

	if !v.Cors.Equal(other.Cors) {
		return false
	}

	if !v.CountryAcl.Equal(other.CountryAcl) {
		return false
	}

	if !v.EdgeCacheSettings.Equal(other.EdgeCacheSettings) {
		return false
	}

	if !v.FetchCompressed.Equal(other.FetchCompressed) {
		return false
	}

	if !v.ForceReturn.Equal(other.ForceReturn) {
		return false
	}

	if !v.ForwardHostHeader.Equal(other.ForwardHostHeader) {
		return false
	}

	if !v.GzipCompression.Equal(other.GzipCompression) {
		return false
	}

	if !v.GzipOn.Equal(other.GzipOn) {
		return false
	}

	if !v.HostHeader.Equal(other.HostHeader) {
		return false
	}

	if !v.IgnoreCookie.Equal(other.IgnoreCookie) {
		return false
	}

	if !v.IgnoreQueryString.Equal(other.IgnoreQueryString) {
		return false
	}

	if !v.IpAddressAcl.Equal(other.IpAddressAcl) {
		return false
	}

	if !v.QueryParamsBlacklist.Equal(other.QueryParamsBlacklist) {
		return false
	}

	if !v.QueryParamsWhitelist.Equal(other.QueryParamsWhitelist) {
		return false
	}

	if !v.ReferrerAcl.Equal(other.ReferrerAcl) {
		return false
	}

	if !v.SecureKey.Equal(other.SecureKey) {
		return false
	}

	if !v.Slice.Equal(other.Slice) {
		return false
	}

	if !v.Stale.Equal(other.Stale) {
		return false
	}

	if !v.StaticHeaders.Equal(other.StaticHeaders) {
		return false
	}

	if !v.StaticRequestHeaders.Equal(other.StaticRequestHeaders) {
		return false
	}

	if !v.TlsVersions.Equal(other.TlsVersions) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_http_methods": basetypes.ObjectType{
			AttrTypes: AllowedHttpMethodsValue{}.AttributeTypes(ctx),
		},
		"brotli_compression": basetypes.ObjectType{
			AttrTypes: BrotliCompressionValue{}.AttributeTypes(ctx),
		},
		"browser_cache_settings": basetypes.ObjectType{
			AttrTypes: BrowserCacheSettingsValue{}.AttributeTypes(ctx),
		},
		"cors": basetypes.ObjectType{
			AttrTypes: CorsValue{}.AttributeTypes(ctx),
		},
		"country_acl": basetypes.ObjectType{
			AttrTypes: CountryAclValue{}.AttributeTypes(ctx),
		},
		"edge_cache_settings": basetypes.ObjectType{
			AttrTypes: EdgeCacheSettingsValue{}.AttributeTypes(ctx),
		},
		"fetch_compressed": basetypes.BoolType{},
		"force_return": basetypes.ObjectType{
			AttrTypes: ForceReturnValue{}.AttributeTypes(ctx),
		},
		"forward_host_header": basetypes.BoolType{},
		"gzip_compression": basetypes.ObjectType{
			AttrTypes: GzipCompressionValue{}.AttributeTypes(ctx),
		},
		"gzip_on": basetypes.BoolType{},
		"host_header": basetypes.ObjectType{
			AttrTypes: HostHeaderValue{}.AttributeTypes(ctx),
		},
		"ignore_cookie":       basetypes.BoolType{},
		"ignore_query_string": basetypes.BoolType{},
		"ip_address_acl": basetypes.ObjectType{
			AttrTypes: IpAddressAclValue{}.AttributeTypes(ctx),
		},
		"query_params_blacklist": basetypes.ObjectType{
			AttrTypes: QueryParamsBlacklistValue{}.AttributeTypes(ctx),
		},
		"query_params_whitelist": basetypes.ObjectType{
			AttrTypes: QueryParamsWhitelistValue{}.AttributeTypes(ctx),
		},
		"referrer_acl": basetypes.ObjectType{
			AttrTypes: ReferrerAclValue{}.AttributeTypes(ctx),
		},
		"secure_key": basetypes.ObjectType{
			AttrTypes: SecureKeyValue{}.AttributeTypes(ctx),
		},
		"slice": basetypes.BoolType{},
		"stale": basetypes.ObjectType{
			AttrTypes: StaleValue{}.AttributeTypes(ctx),
		},
		"static_headers": basetypes.ObjectType{
			AttrTypes: StaticHeadersValue{}.AttributeTypes(ctx),
		},
		"static_request_headers": basetypes.ObjectType{
			AttrTypes: StaticRequestHeadersValue{}.AttributeTypes(ctx),
		},
		"tls_versions": basetypes.ObjectType{
			AttrTypes: TlsVersionsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AllowedHttpMethodsType{}

type AllowedHttpMethodsType struct {
	basetypes.ObjectType
}

func (t AllowedHttpMethodsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedHttpMethodsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedHttpMethodsType) String() string {
	return "AllowedHttpMethodsType"
}

func (t AllowedHttpMethodsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedHttpMethodsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAllowedHttpMethodsValueNull() AllowedHttpMethodsValue {
	return AllowedHttpMethodsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedHttpMethodsValueUnknown() AllowedHttpMethodsValue {
	return AllowedHttpMethodsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedHttpMethodsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedHttpMethodsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedHttpMethodsValue Attribute Value",
				"While creating a AllowedHttpMethodsValue value, a missing attribute value was detected. "+
					"A AllowedHttpMethodsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedHttpMethodsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedHttpMethodsValue Attribute Type",
				"While creating a AllowedHttpMethodsValue value, an invalid attribute value was detected. "+
					"A AllowedHttpMethodsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedHttpMethodsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedHttpMethodsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedHttpMethodsValue Attribute Value",
				"While creating a AllowedHttpMethodsValue value, an extra attribute value was detected. "+
					"A AllowedHttpMethodsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedHttpMethodsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedHttpMethodsValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAllowedHttpMethodsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewAllowedHttpMethodsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewAllowedHttpMethodsValueUnknown(), diags
	}

	return AllowedHttpMethodsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAllowedHttpMethodsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedHttpMethodsValue {
	object, diags := NewAllowedHttpMethodsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedHttpMethodsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedHttpMethodsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedHttpMethodsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedHttpMethodsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedHttpMethodsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedHttpMethodsValueMust(AllowedHttpMethodsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedHttpMethodsType) ValueType(ctx context.Context) attr.Value {
	return AllowedHttpMethodsValue{}
}

var _ basetypes.ObjectValuable = AllowedHttpMethodsValue{}

type AllowedHttpMethodsValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v AllowedHttpMethodsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedHttpMethodsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedHttpMethodsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedHttpMethodsValue) String() string {
	return "AllowedHttpMethodsValue"
}

func (v AllowedHttpMethodsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v AllowedHttpMethodsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedHttpMethodsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v AllowedHttpMethodsValue) Type(ctx context.Context) attr.Type {
	return AllowedHttpMethodsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedHttpMethodsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = BrotliCompressionType{}

type BrotliCompressionType struct {
	basetypes.ObjectType
}

func (t BrotliCompressionType) Equal(o attr.Type) bool {
	other, ok := o.(BrotliCompressionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BrotliCompressionType) String() string {
	return "BrotliCompressionType"
}

func (t BrotliCompressionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.SetValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BrotliCompressionValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBrotliCompressionValueNull() BrotliCompressionValue {
	return BrotliCompressionValue{
		state: attr.ValueStateNull,
	}
}

func NewBrotliCompressionValueUnknown() BrotliCompressionValue {
	return BrotliCompressionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBrotliCompressionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BrotliCompressionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BrotliCompressionValue Attribute Value",
				"While creating a BrotliCompressionValue value, a missing attribute value was detected. "+
					"A BrotliCompressionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrotliCompressionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BrotliCompressionValue Attribute Type",
				"While creating a BrotliCompressionValue value, an invalid attribute value was detected. "+
					"A BrotliCompressionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrotliCompressionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BrotliCompressionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BrotliCompressionValue Attribute Value",
				"While creating a BrotliCompressionValue value, an extra attribute value was detected. "+
					"A BrotliCompressionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BrotliCompressionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBrotliCompressionValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBrotliCompressionValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewBrotliCompressionValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.SetValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewBrotliCompressionValueUnknown(), diags
	}

	return BrotliCompressionValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBrotliCompressionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BrotliCompressionValue {
	object, diags := NewBrotliCompressionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBrotliCompressionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BrotliCompressionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBrotliCompressionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBrotliCompressionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBrotliCompressionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBrotliCompressionValueMust(BrotliCompressionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BrotliCompressionType) ValueType(ctx context.Context) attr.Value {
	return BrotliCompressionValue{}
}

var _ basetypes.ObjectValuable = BrotliCompressionValue{}

type BrotliCompressionValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.SetValue  `tfsdk:"value"`
	state   attr.ValueState
}

func (v BrotliCompressionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BrotliCompressionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BrotliCompressionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BrotliCompressionValue) String() string {
	return "BrotliCompressionValue"
}

func (v BrotliCompressionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.SetValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.SetUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.SetValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v BrotliCompressionValue) Equal(o attr.Value) bool {
	other, ok := o.(BrotliCompressionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v BrotliCompressionValue) Type(ctx context.Context) attr.Type {
	return BrotliCompressionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BrotliCompressionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = BrowserCacheSettingsType{}

type BrowserCacheSettingsType struct {
	basetypes.ObjectType
}

func (t BrowserCacheSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(BrowserCacheSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BrowserCacheSettingsType) String() string {
	return "BrowserCacheSettingsType"
}

func (t BrowserCacheSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BrowserCacheSettingsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBrowserCacheSettingsValueNull() BrowserCacheSettingsValue {
	return BrowserCacheSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewBrowserCacheSettingsValueUnknown() BrowserCacheSettingsValue {
	return BrowserCacheSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBrowserCacheSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BrowserCacheSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BrowserCacheSettingsValue Attribute Value",
				"While creating a BrowserCacheSettingsValue value, a missing attribute value was detected. "+
					"A BrowserCacheSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrowserCacheSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BrowserCacheSettingsValue Attribute Type",
				"While creating a BrowserCacheSettingsValue value, an invalid attribute value was detected. "+
					"A BrowserCacheSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BrowserCacheSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BrowserCacheSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BrowserCacheSettingsValue Attribute Value",
				"While creating a BrowserCacheSettingsValue value, an extra attribute value was detected. "+
					"A BrowserCacheSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BrowserCacheSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBrowserCacheSettingsValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBrowserCacheSettingsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewBrowserCacheSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewBrowserCacheSettingsValueUnknown(), diags
	}

	return BrowserCacheSettingsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewBrowserCacheSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BrowserCacheSettingsValue {
	object, diags := NewBrowserCacheSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBrowserCacheSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BrowserCacheSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBrowserCacheSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBrowserCacheSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBrowserCacheSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBrowserCacheSettingsValueMust(BrowserCacheSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BrowserCacheSettingsType) ValueType(ctx context.Context) attr.Value {
	return BrowserCacheSettingsValue{}
}

var _ basetypes.ObjectValuable = BrowserCacheSettingsValue{}

type BrowserCacheSettingsValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Value   basetypes.StringValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v BrowserCacheSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BrowserCacheSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BrowserCacheSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BrowserCacheSettingsValue) String() string {
	return "BrowserCacheSettingsValue"
}

func (v BrowserCacheSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   v.Value,
		})

	return objVal, diags
}

func (v BrowserCacheSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(BrowserCacheSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v BrowserCacheSettingsValue) Type(ctx context.Context) attr.Type {
	return BrowserCacheSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BrowserCacheSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CorsType{}

type CorsType struct {
	basetypes.ObjectType
}

func (t CorsType) Equal(o attr.Type) bool {
	other, ok := o.(CorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CorsType) String() string {
	return "CorsType"
}

func (t CorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CorsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCorsValueNull() CorsValue {
	return CorsValue{
		state: attr.ValueStateNull,
	}
}

func NewCorsValueUnknown() CorsValue {
	return CorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CorsValue Attribute Value",
				"While creating a CorsValue value, a missing attribute value was detected. "+
					"A CorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CorsValue Attribute Type",
				"While creating a CorsValue value, an invalid attribute value was detected. "+
					"A CorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CorsValue Attribute Value",
				"While creating a CorsValue value, an extra attribute value was detected. "+
					"A CorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCorsValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCorsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewCorsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewCorsValueUnknown(), diags
	}

	return CorsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CorsValue {
	object, diags := NewCorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCorsValueMust(CorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CorsType) ValueType(ctx context.Context) attr.Value {
	return CorsValue{}
}

var _ basetypes.ObjectValuable = CorsValue{}

type CorsValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v CorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CorsValue) String() string {
	return "CorsValue"
}

func (v CorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v CorsValue) Equal(o attr.Value) bool {
	other, ok := o.(CorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v CorsValue) Type(ctx context.Context) attr.Type {
	return CorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = CountryAclType{}

type CountryAclType struct {
	basetypes.ObjectType
}

func (t CountryAclType) Equal(o attr.Type) bool {
	other, ok := o.(CountryAclType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CountryAclType) String() string {
	return "CountryAclType"
}

func (t CountryAclType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return nil, diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return nil, diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CountryAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCountryAclValueNull() CountryAclValue {
	return CountryAclValue{
		state: attr.ValueStateNull,
	}
}

func NewCountryAclValueUnknown() CountryAclValue {
	return CountryAclValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCountryAclValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CountryAclValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CountryAclValue Attribute Value",
				"While creating a CountryAclValue value, a missing attribute value was detected. "+
					"A CountryAclValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CountryAclValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CountryAclValue Attribute Type",
				"While creating a CountryAclValue value, an invalid attribute value was detected. "+
					"A CountryAclValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CountryAclValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CountryAclValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CountryAclValue Attribute Value",
				"While creating a CountryAclValue value, an extra attribute value was detected. "+
					"A CountryAclValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CountryAclValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCountryAclValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCountryAclValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return NewCountryAclValueUnknown(), diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return NewCountryAclValueUnknown(), diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return NewCountryAclValueUnknown(), diags
	}

	return CountryAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewCountryAclValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CountryAclValue {
	object, diags := NewCountryAclValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCountryAclValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CountryAclType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCountryAclValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCountryAclValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCountryAclValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCountryAclValueMust(CountryAclValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CountryAclType) ValueType(ctx context.Context) attr.Value {
	return CountryAclValue{}
}

var _ basetypes.ObjectValuable = CountryAclValue{}

type CountryAclValue struct {
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	ExceptedValues basetypes.ListValue   `tfsdk:"excepted_values"`
	PolicyType     basetypes.StringValue `tfsdk:"policy_type"`
	state          attr.ValueState
}

func (v CountryAclValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["excepted_values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExceptedValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["excepted_values"] = val

		val, err = v.PolicyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CountryAclValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CountryAclValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CountryAclValue) String() string {
	return "CountryAclValue"
}

func (v CountryAclValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var exceptedValuesVal basetypes.ListValue
	switch {
	case v.ExceptedValues.IsUnknown():
		exceptedValuesVal = types.ListUnknown(types.StringType)
	case v.ExceptedValues.IsNull():
		exceptedValuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exceptedValuesVal, d = types.ListValue(types.StringType, v.ExceptedValues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"excepted_values": basetypes.ListType{
				ElemType: types.StringType,
			},
			"policy_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":         v.Enabled,
			"excepted_values": exceptedValuesVal,
			"policy_type":     v.PolicyType,
		})

	return objVal, diags
}

func (v CountryAclValue) Equal(o attr.Value) bool {
	other, ok := o.(CountryAclValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExceptedValues.Equal(other.ExceptedValues) {
		return false
	}

	if !v.PolicyType.Equal(other.PolicyType) {
		return false
	}

	return true
}

func (v CountryAclValue) Type(ctx context.Context) attr.Type {
	return CountryAclType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CountryAclValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EdgeCacheSettingsType{}

type EdgeCacheSettingsType struct {
	basetypes.ObjectType
}

func (t EdgeCacheSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(EdgeCacheSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EdgeCacheSettingsType) String() string {
	return "EdgeCacheSettingsType"
}

func (t EdgeCacheSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customValuesAttribute, ok := attributes["custom_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_values is missing from object`)

		return nil, diags
	}

	customValuesVal, ok := customValuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_values expected to be basetypes.MapValue, was: %T`, customValuesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EdgeCacheSettingsValue{
		CustomValues: customValuesVal,
		Default:      defaultVal,
		Enabled:      enabledVal,
		Value:        valueVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEdgeCacheSettingsValueNull() EdgeCacheSettingsValue {
	return EdgeCacheSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewEdgeCacheSettingsValueUnknown() EdgeCacheSettingsValue {
	return EdgeCacheSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEdgeCacheSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EdgeCacheSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EdgeCacheSettingsValue Attribute Value",
				"While creating a EdgeCacheSettingsValue value, a missing attribute value was detected. "+
					"A EdgeCacheSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EdgeCacheSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EdgeCacheSettingsValue Attribute Type",
				"While creating a EdgeCacheSettingsValue value, an invalid attribute value was detected. "+
					"A EdgeCacheSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EdgeCacheSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EdgeCacheSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EdgeCacheSettingsValue Attribute Value",
				"While creating a EdgeCacheSettingsValue value, an extra attribute value was detected. "+
					"A EdgeCacheSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EdgeCacheSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	customValuesAttribute, ok := attributes["custom_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_values is missing from object`)

		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	customValuesVal, ok := customValuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_values expected to be basetypes.MapValue, was: %T`, customValuesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewEdgeCacheSettingsValueUnknown(), diags
	}

	return EdgeCacheSettingsValue{
		CustomValues: customValuesVal,
		Default:      defaultVal,
		Enabled:      enabledVal,
		Value:        valueVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEdgeCacheSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EdgeCacheSettingsValue {
	object, diags := NewEdgeCacheSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEdgeCacheSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EdgeCacheSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEdgeCacheSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEdgeCacheSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEdgeCacheSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEdgeCacheSettingsValueMust(EdgeCacheSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EdgeCacheSettingsType) ValueType(ctx context.Context) attr.Value {
	return EdgeCacheSettingsValue{}
}

var _ basetypes.ObjectValuable = EdgeCacheSettingsValue{}

type EdgeCacheSettingsValue struct {
	CustomValues basetypes.MapValue    `tfsdk:"custom_values"`
	Default      basetypes.StringValue `tfsdk:"default"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	Value        basetypes.StringValue `tfsdk:"value"`
	state        attr.ValueState
}

func (v EdgeCacheSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["custom_values"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CustomValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_values"] = val

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EdgeCacheSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EdgeCacheSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EdgeCacheSettingsValue) String() string {
	return "EdgeCacheSettingsValue"
}

func (v EdgeCacheSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customValuesVal basetypes.MapValue
	switch {
	case v.CustomValues.IsUnknown():
		customValuesVal = types.MapUnknown(types.StringType)
	case v.CustomValues.IsNull():
		customValuesVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		customValuesVal, d = types.MapValue(types.StringType, v.CustomValues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_values": basetypes.MapType{
				ElemType: types.StringType,
			},
			"default": basetypes.StringType{},
			"enabled": basetypes.BoolType{},
			"value":   basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_values": basetypes.MapType{
			ElemType: types.StringType,
		},
		"default": basetypes.StringType{},
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_values": customValuesVal,
			"default":       v.Default,
			"enabled":       v.Enabled,
			"value":         v.Value,
		})

	return objVal, diags
}

func (v EdgeCacheSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(EdgeCacheSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomValues.Equal(other.CustomValues) {
		return false
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v EdgeCacheSettingsValue) Type(ctx context.Context) attr.Type {
	return EdgeCacheSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EdgeCacheSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_values": basetypes.MapType{
			ElemType: types.StringType,
		},
		"default": basetypes.StringType{},
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ForceReturnType{}

type ForceReturnType struct {
	basetypes.ObjectType
}

func (t ForceReturnType) Equal(o attr.Type) bool {
	other, ok := o.(ForceReturnType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ForceReturnType) String() string {
	return "ForceReturnType"
}

func (t ForceReturnType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bodyAttribute, ok := attributes["body"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`body is missing from object`)

		return nil, diags
	}

	bodyVal, ok := bodyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`body expected to be basetypes.StringValue, was: %T`, bodyAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.Int64Value, was: %T`, codeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ForceReturnValue{
		Body:    bodyVal,
		Code:    codeVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewForceReturnValueNull() ForceReturnValue {
	return ForceReturnValue{
		state: attr.ValueStateNull,
	}
}

func NewForceReturnValueUnknown() ForceReturnValue {
	return ForceReturnValue{
		state: attr.ValueStateUnknown,
	}
}

func NewForceReturnValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ForceReturnValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ForceReturnValue Attribute Value",
				"While creating a ForceReturnValue value, a missing attribute value was detected. "+
					"A ForceReturnValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForceReturnValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ForceReturnValue Attribute Type",
				"While creating a ForceReturnValue value, an invalid attribute value was detected. "+
					"A ForceReturnValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForceReturnValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ForceReturnValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ForceReturnValue Attribute Value",
				"While creating a ForceReturnValue value, an extra attribute value was detected. "+
					"A ForceReturnValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ForceReturnValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewForceReturnValueUnknown(), diags
	}

	bodyAttribute, ok := attributes["body"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`body is missing from object`)

		return NewForceReturnValueUnknown(), diags
	}

	bodyVal, ok := bodyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`body expected to be basetypes.StringValue, was: %T`, bodyAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewForceReturnValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.Int64Value, was: %T`, codeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewForceReturnValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewForceReturnValueUnknown(), diags
	}

	return ForceReturnValue{
		Body:    bodyVal,
		Code:    codeVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewForceReturnValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ForceReturnValue {
	object, diags := NewForceReturnValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewForceReturnValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ForceReturnType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewForceReturnValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewForceReturnValueUnknown(), nil
	}

	if in.IsNull() {
		return NewForceReturnValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewForceReturnValueMust(ForceReturnValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ForceReturnType) ValueType(ctx context.Context) attr.Value {
	return ForceReturnValue{}
}

var _ basetypes.ObjectValuable = ForceReturnValue{}

type ForceReturnValue struct {
	Body    basetypes.StringValue `tfsdk:"body"`
	Code    basetypes.Int64Value  `tfsdk:"code"`
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v ForceReturnValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["body"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Body.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["body"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ForceReturnValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ForceReturnValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ForceReturnValue) String() string {
	return "ForceReturnValue"
}

func (v ForceReturnValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"body":    basetypes.StringType{},
		"code":    basetypes.Int64Type{},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"body":    v.Body,
			"code":    v.Code,
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v ForceReturnValue) Equal(o attr.Value) bool {
	other, ok := o.(ForceReturnValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Body.Equal(other.Body) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v ForceReturnValue) Type(ctx context.Context) attr.Type {
	return ForceReturnType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ForceReturnValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"body":    basetypes.StringType{},
		"code":    basetypes.Int64Type{},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = GzipCompressionType{}

type GzipCompressionType struct {
	basetypes.ObjectType
}

func (t GzipCompressionType) Equal(o attr.Type) bool {
	other, ok := o.(GzipCompressionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GzipCompressionType) String() string {
	return "GzipCompressionType"
}

func (t GzipCompressionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.SetValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GzipCompressionValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGzipCompressionValueNull() GzipCompressionValue {
	return GzipCompressionValue{
		state: attr.ValueStateNull,
	}
}

func NewGzipCompressionValueUnknown() GzipCompressionValue {
	return GzipCompressionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGzipCompressionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GzipCompressionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GzipCompressionValue Attribute Value",
				"While creating a GzipCompressionValue value, a missing attribute value was detected. "+
					"A GzipCompressionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GzipCompressionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GzipCompressionValue Attribute Type",
				"While creating a GzipCompressionValue value, an invalid attribute value was detected. "+
					"A GzipCompressionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GzipCompressionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GzipCompressionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GzipCompressionValue Attribute Value",
				"While creating a GzipCompressionValue value, an extra attribute value was detected. "+
					"A GzipCompressionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GzipCompressionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGzipCompressionValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewGzipCompressionValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewGzipCompressionValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.SetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.SetValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewGzipCompressionValueUnknown(), diags
	}

	return GzipCompressionValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewGzipCompressionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GzipCompressionValue {
	object, diags := NewGzipCompressionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGzipCompressionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GzipCompressionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGzipCompressionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGzipCompressionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGzipCompressionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGzipCompressionValueMust(GzipCompressionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GzipCompressionType) ValueType(ctx context.Context) attr.Value {
	return GzipCompressionValue{}
}

var _ basetypes.ObjectValuable = GzipCompressionValue{}

type GzipCompressionValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.SetValue  `tfsdk:"value"`
	state   attr.ValueState
}

func (v GzipCompressionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.SetType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GzipCompressionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GzipCompressionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GzipCompressionValue) String() string {
	return "GzipCompressionValue"
}

func (v GzipCompressionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.SetValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.SetUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.SetNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.SetValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.SetType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.SetType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v GzipCompressionValue) Equal(o attr.Value) bool {
	other, ok := o.(GzipCompressionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v GzipCompressionValue) Type(ctx context.Context) attr.Type {
	return GzipCompressionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GzipCompressionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.SetType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = HostHeaderType{}

type HostHeaderType struct {
	basetypes.ObjectType
}

func (t HostHeaderType) Equal(o attr.Type) bool {
	other, ok := o.(HostHeaderType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HostHeaderType) String() string {
	return "HostHeaderType"
}

func (t HostHeaderType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HostHeaderValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostHeaderValueNull() HostHeaderValue {
	return HostHeaderValue{
		state: attr.ValueStateNull,
	}
}

func NewHostHeaderValueUnknown() HostHeaderValue {
	return HostHeaderValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHostHeaderValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HostHeaderValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HostHeaderValue Attribute Value",
				"While creating a HostHeaderValue value, a missing attribute value was detected. "+
					"A HostHeaderValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostHeaderValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HostHeaderValue Attribute Type",
				"While creating a HostHeaderValue value, an invalid attribute value was detected. "+
					"A HostHeaderValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostHeaderValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HostHeaderValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HostHeaderValue Attribute Value",
				"While creating a HostHeaderValue value, an extra attribute value was detected. "+
					"A HostHeaderValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HostHeaderValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHostHeaderValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewHostHeaderValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewHostHeaderValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewHostHeaderValueUnknown(), diags
	}

	return HostHeaderValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostHeaderValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HostHeaderValue {
	object, diags := NewHostHeaderValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHostHeaderValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HostHeaderType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHostHeaderValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHostHeaderValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHostHeaderValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHostHeaderValueMust(HostHeaderValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HostHeaderType) ValueType(ctx context.Context) attr.Value {
	return HostHeaderValue{}
}

var _ basetypes.ObjectValuable = HostHeaderValue{}

type HostHeaderValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Value   basetypes.StringValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v HostHeaderValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HostHeaderValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HostHeaderValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HostHeaderValue) String() string {
	return "HostHeaderValue"
}

func (v HostHeaderValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   v.Value,
		})

	return objVal, diags
}

func (v HostHeaderValue) Equal(o attr.Value) bool {
	other, ok := o.(HostHeaderValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v HostHeaderValue) Type(ctx context.Context) attr.Type {
	return HostHeaderType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HostHeaderValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpAddressAclType{}

type IpAddressAclType struct {
	basetypes.ObjectType
}

func (t IpAddressAclType) Equal(o attr.Type) bool {
	other, ok := o.(IpAddressAclType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpAddressAclType) String() string {
	return "IpAddressAclType"
}

func (t IpAddressAclType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return nil, diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return nil, diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpAddressAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewIpAddressAclValueNull() IpAddressAclValue {
	return IpAddressAclValue{
		state: attr.ValueStateNull,
	}
}

func NewIpAddressAclValueUnknown() IpAddressAclValue {
	return IpAddressAclValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpAddressAclValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpAddressAclValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpAddressAclValue Attribute Value",
				"While creating a IpAddressAclValue value, a missing attribute value was detected. "+
					"A IpAddressAclValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressAclValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpAddressAclValue Attribute Type",
				"While creating a IpAddressAclValue value, an invalid attribute value was detected. "+
					"A IpAddressAclValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressAclValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpAddressAclValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpAddressAclValue Attribute Value",
				"While creating a IpAddressAclValue value, an extra attribute value was detected. "+
					"A IpAddressAclValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpAddressAclValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpAddressAclValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpAddressAclValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return NewIpAddressAclValueUnknown(), diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return NewIpAddressAclValueUnknown(), diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return NewIpAddressAclValueUnknown(), diags
	}

	return IpAddressAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewIpAddressAclValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpAddressAclValue {
	object, diags := NewIpAddressAclValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpAddressAclValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpAddressAclType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpAddressAclValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpAddressAclValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpAddressAclValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpAddressAclValueMust(IpAddressAclValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpAddressAclType) ValueType(ctx context.Context) attr.Value {
	return IpAddressAclValue{}
}

var _ basetypes.ObjectValuable = IpAddressAclValue{}

type IpAddressAclValue struct {
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	ExceptedValues basetypes.ListValue   `tfsdk:"excepted_values"`
	PolicyType     basetypes.StringValue `tfsdk:"policy_type"`
	state          attr.ValueState
}

func (v IpAddressAclValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["excepted_values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExceptedValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["excepted_values"] = val

		val, err = v.PolicyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpAddressAclValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpAddressAclValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpAddressAclValue) String() string {
	return "IpAddressAclValue"
}

func (v IpAddressAclValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var exceptedValuesVal basetypes.ListValue
	switch {
	case v.ExceptedValues.IsUnknown():
		exceptedValuesVal = types.ListUnknown(types.StringType)
	case v.ExceptedValues.IsNull():
		exceptedValuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exceptedValuesVal, d = types.ListValue(types.StringType, v.ExceptedValues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"excepted_values": basetypes.ListType{
				ElemType: types.StringType,
			},
			"policy_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":         v.Enabled,
			"excepted_values": exceptedValuesVal,
			"policy_type":     v.PolicyType,
		})

	return objVal, diags
}

func (v IpAddressAclValue) Equal(o attr.Value) bool {
	other, ok := o.(IpAddressAclValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExceptedValues.Equal(other.ExceptedValues) {
		return false
	}

	if !v.PolicyType.Equal(other.PolicyType) {
		return false
	}

	return true
}

func (v IpAddressAclValue) Type(ctx context.Context) attr.Type {
	return IpAddressAclType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpAddressAclValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QueryParamsBlacklistType{}

type QueryParamsBlacklistType struct {
	basetypes.ObjectType
}

func (t QueryParamsBlacklistType) Equal(o attr.Type) bool {
	other, ok := o.(QueryParamsBlacklistType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueryParamsBlacklistType) String() string {
	return "QueryParamsBlacklistType"
}

func (t QueryParamsBlacklistType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueryParamsBlacklistValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewQueryParamsBlacklistValueNull() QueryParamsBlacklistValue {
	return QueryParamsBlacklistValue{
		state: attr.ValueStateNull,
	}
}

func NewQueryParamsBlacklistValueUnknown() QueryParamsBlacklistValue {
	return QueryParamsBlacklistValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueryParamsBlacklistValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueryParamsBlacklistValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueryParamsBlacklistValue Attribute Value",
				"While creating a QueryParamsBlacklistValue value, a missing attribute value was detected. "+
					"A QueryParamsBlacklistValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueryParamsBlacklistValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueryParamsBlacklistValue Attribute Type",
				"While creating a QueryParamsBlacklistValue value, an invalid attribute value was detected. "+
					"A QueryParamsBlacklistValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueryParamsBlacklistValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueryParamsBlacklistValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueryParamsBlacklistValue Attribute Value",
				"While creating a QueryParamsBlacklistValue value, an extra attribute value was detected. "+
					"A QueryParamsBlacklistValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueryParamsBlacklistValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueryParamsBlacklistValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewQueryParamsBlacklistValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewQueryParamsBlacklistValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewQueryParamsBlacklistValueUnknown(), diags
	}

	return QueryParamsBlacklistValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewQueryParamsBlacklistValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueryParamsBlacklistValue {
	object, diags := NewQueryParamsBlacklistValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueryParamsBlacklistValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueryParamsBlacklistType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueryParamsBlacklistValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueryParamsBlacklistValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueryParamsBlacklistValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueryParamsBlacklistValueMust(QueryParamsBlacklistValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueryParamsBlacklistType) ValueType(ctx context.Context) attr.Value {
	return QueryParamsBlacklistValue{}
}

var _ basetypes.ObjectValuable = QueryParamsBlacklistValue{}

type QueryParamsBlacklistValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v QueryParamsBlacklistValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueryParamsBlacklistValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueryParamsBlacklistValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueryParamsBlacklistValue) String() string {
	return "QueryParamsBlacklistValue"
}

func (v QueryParamsBlacklistValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v QueryParamsBlacklistValue) Equal(o attr.Value) bool {
	other, ok := o.(QueryParamsBlacklistValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v QueryParamsBlacklistValue) Type(ctx context.Context) attr.Type {
	return QueryParamsBlacklistType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueryParamsBlacklistValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = QueryParamsWhitelistType{}

type QueryParamsWhitelistType struct {
	basetypes.ObjectType
}

func (t QueryParamsWhitelistType) Equal(o attr.Type) bool {
	other, ok := o.(QueryParamsWhitelistType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueryParamsWhitelistType) String() string {
	return "QueryParamsWhitelistType"
}

func (t QueryParamsWhitelistType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueryParamsWhitelistValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewQueryParamsWhitelistValueNull() QueryParamsWhitelistValue {
	return QueryParamsWhitelistValue{
		state: attr.ValueStateNull,
	}
}

func NewQueryParamsWhitelistValueUnknown() QueryParamsWhitelistValue {
	return QueryParamsWhitelistValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueryParamsWhitelistValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueryParamsWhitelistValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueryParamsWhitelistValue Attribute Value",
				"While creating a QueryParamsWhitelistValue value, a missing attribute value was detected. "+
					"A QueryParamsWhitelistValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueryParamsWhitelistValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueryParamsWhitelistValue Attribute Type",
				"While creating a QueryParamsWhitelistValue value, an invalid attribute value was detected. "+
					"A QueryParamsWhitelistValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueryParamsWhitelistValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueryParamsWhitelistValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueryParamsWhitelistValue Attribute Value",
				"While creating a QueryParamsWhitelistValue value, an extra attribute value was detected. "+
					"A QueryParamsWhitelistValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueryParamsWhitelistValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueryParamsWhitelistValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewQueryParamsWhitelistValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewQueryParamsWhitelistValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewQueryParamsWhitelistValueUnknown(), diags
	}

	return QueryParamsWhitelistValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewQueryParamsWhitelistValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueryParamsWhitelistValue {
	object, diags := NewQueryParamsWhitelistValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueryParamsWhitelistValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueryParamsWhitelistType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueryParamsWhitelistValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueryParamsWhitelistValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueryParamsWhitelistValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueryParamsWhitelistValueMust(QueryParamsWhitelistValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueryParamsWhitelistType) ValueType(ctx context.Context) attr.Value {
	return QueryParamsWhitelistValue{}
}

var _ basetypes.ObjectValuable = QueryParamsWhitelistValue{}

type QueryParamsWhitelistValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v QueryParamsWhitelistValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueryParamsWhitelistValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueryParamsWhitelistValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueryParamsWhitelistValue) String() string {
	return "QueryParamsWhitelistValue"
}

func (v QueryParamsWhitelistValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v QueryParamsWhitelistValue) Equal(o attr.Value) bool {
	other, ok := o.(QueryParamsWhitelistValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v QueryParamsWhitelistValue) Type(ctx context.Context) attr.Type {
	return QueryParamsWhitelistType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueryParamsWhitelistValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ReferrerAclType{}

type ReferrerAclType struct {
	basetypes.ObjectType
}

func (t ReferrerAclType) Equal(o attr.Type) bool {
	other, ok := o.(ReferrerAclType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ReferrerAclType) String() string {
	return "ReferrerAclType"
}

func (t ReferrerAclType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return nil, diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return nil, diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ReferrerAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewReferrerAclValueNull() ReferrerAclValue {
	return ReferrerAclValue{
		state: attr.ValueStateNull,
	}
}

func NewReferrerAclValueUnknown() ReferrerAclValue {
	return ReferrerAclValue{
		state: attr.ValueStateUnknown,
	}
}

func NewReferrerAclValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ReferrerAclValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ReferrerAclValue Attribute Value",
				"While creating a ReferrerAclValue value, a missing attribute value was detected. "+
					"A ReferrerAclValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReferrerAclValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ReferrerAclValue Attribute Type",
				"While creating a ReferrerAclValue value, an invalid attribute value was detected. "+
					"A ReferrerAclValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ReferrerAclValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ReferrerAclValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ReferrerAclValue Attribute Value",
				"While creating a ReferrerAclValue value, an extra attribute value was detected. "+
					"A ReferrerAclValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ReferrerAclValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewReferrerAclValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewReferrerAclValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exceptedValuesAttribute, ok := attributes["excepted_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excepted_values is missing from object`)

		return NewReferrerAclValueUnknown(), diags
	}

	exceptedValuesVal, ok := exceptedValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excepted_values expected to be basetypes.ListValue, was: %T`, exceptedValuesAttribute))
	}

	policyTypeAttribute, ok := attributes["policy_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_type is missing from object`)

		return NewReferrerAclValueUnknown(), diags
	}

	policyTypeVal, ok := policyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_type expected to be basetypes.StringValue, was: %T`, policyTypeAttribute))
	}

	if diags.HasError() {
		return NewReferrerAclValueUnknown(), diags
	}

	return ReferrerAclValue{
		Enabled:        enabledVal,
		ExceptedValues: exceptedValuesVal,
		PolicyType:     policyTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewReferrerAclValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ReferrerAclValue {
	object, diags := NewReferrerAclValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewReferrerAclValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ReferrerAclType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewReferrerAclValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewReferrerAclValueUnknown(), nil
	}

	if in.IsNull() {
		return NewReferrerAclValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewReferrerAclValueMust(ReferrerAclValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ReferrerAclType) ValueType(ctx context.Context) attr.Value {
	return ReferrerAclValue{}
}

var _ basetypes.ObjectValuable = ReferrerAclValue{}

type ReferrerAclValue struct {
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	ExceptedValues basetypes.ListValue   `tfsdk:"excepted_values"`
	PolicyType     basetypes.StringValue `tfsdk:"policy_type"`
	state          attr.ValueState
}

func (v ReferrerAclValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["excepted_values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["policy_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExceptedValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["excepted_values"] = val

		val, err = v.PolicyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ReferrerAclValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ReferrerAclValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ReferrerAclValue) String() string {
	return "ReferrerAclValue"
}

func (v ReferrerAclValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var exceptedValuesVal basetypes.ListValue
	switch {
	case v.ExceptedValues.IsUnknown():
		exceptedValuesVal = types.ListUnknown(types.StringType)
	case v.ExceptedValues.IsNull():
		exceptedValuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exceptedValuesVal, d = types.ListValue(types.StringType, v.ExceptedValues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"excepted_values": basetypes.ListType{
				ElemType: types.StringType,
			},
			"policy_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":         v.Enabled,
			"excepted_values": exceptedValuesVal,
			"policy_type":     v.PolicyType,
		})

	return objVal, diags
}

func (v ReferrerAclValue) Equal(o attr.Value) bool {
	other, ok := o.(ReferrerAclValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExceptedValues.Equal(other.ExceptedValues) {
		return false
	}

	if !v.PolicyType.Equal(other.PolicyType) {
		return false
	}

	return true
}

func (v ReferrerAclValue) Type(ctx context.Context) attr.Type {
	return ReferrerAclType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ReferrerAclValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"excepted_values": basetypes.ListType{
			ElemType: types.StringType,
		},
		"policy_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecureKeyType{}

type SecureKeyType struct {
	basetypes.ObjectType
}

func (t SecureKeyType) Equal(o attr.Type) bool {
	other, ok := o.(SecureKeyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecureKeyType) String() string {
	return "SecureKeyType"
}

func (t SecureKeyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.Int64Value, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecureKeyValue{
		Enabled:       enabledVal,
		Key:           keyVal,
		SecureKeyType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSecureKeyValueNull() SecureKeyValue {
	return SecureKeyValue{
		state: attr.ValueStateNull,
	}
}

func NewSecureKeyValueUnknown() SecureKeyValue {
	return SecureKeyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecureKeyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecureKeyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecureKeyValue Attribute Value",
				"While creating a SecureKeyValue value, a missing attribute value was detected. "+
					"A SecureKeyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecureKeyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecureKeyValue Attribute Type",
				"While creating a SecureKeyValue value, an invalid attribute value was detected. "+
					"A SecureKeyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecureKeyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecureKeyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecureKeyValue Attribute Value",
				"While creating a SecureKeyValue value, an extra attribute value was detected. "+
					"A SecureKeyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecureKeyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecureKeyValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSecureKeyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewSecureKeyValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSecureKeyValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.Int64Value, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSecureKeyValueUnknown(), diags
	}

	return SecureKeyValue{
		Enabled:       enabledVal,
		Key:           keyVal,
		SecureKeyType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSecureKeyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecureKeyValue {
	object, diags := NewSecureKeyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecureKeyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecureKeyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecureKeyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecureKeyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecureKeyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecureKeyValueMust(SecureKeyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecureKeyType) ValueType(ctx context.Context) attr.Value {
	return SecureKeyValue{}
}

var _ basetypes.ObjectValuable = SecureKeyValue{}

type SecureKeyValue struct {
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	Key           basetypes.StringValue `tfsdk:"key"`
	SecureKeyType basetypes.Int64Value  `tfsdk:"type"`
	state         attr.ValueState
}

func (v SecureKeyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.SecureKeyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecureKeyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecureKeyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecureKeyValue) String() string {
	return "SecureKeyValue"
}

func (v SecureKeyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"key":     basetypes.StringType{},
		"type":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"key":     v.Key,
			"type":    v.SecureKeyType,
		})

	return objVal, diags
}

func (v SecureKeyValue) Equal(o attr.Value) bool {
	other, ok := o.(SecureKeyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.SecureKeyType.Equal(other.SecureKeyType) {
		return false
	}

	return true
}

func (v SecureKeyValue) Type(ctx context.Context) attr.Type {
	return SecureKeyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecureKeyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"key":     basetypes.StringType{},
		"type":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StaleType{}

type StaleType struct {
	basetypes.ObjectType
}

func (t StaleType) Equal(o attr.Type) bool {
	other, ok := o.(StaleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaleType) String() string {
	return "StaleType"
}

func (t StaleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaleValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaleValueNull() StaleValue {
	return StaleValue{
		state: attr.ValueStateNull,
	}
}

func NewStaleValueUnknown() StaleValue {
	return StaleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaleValue Attribute Value",
				"While creating a StaleValue value, a missing attribute value was detected. "+
					"A StaleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaleValue Attribute Type",
				"While creating a StaleValue value, an invalid attribute value was detected. "+
					"A StaleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaleValue Attribute Value",
				"While creating a StaleValue value, an extra attribute value was detected. "+
					"A StaleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaleValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStaleValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStaleValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStaleValueUnknown(), diags
	}

	return StaleValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaleValue {
	object, diags := NewStaleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaleValueMust(StaleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaleType) ValueType(ctx context.Context) attr.Value {
	return StaleValue{}
}

var _ basetypes.ObjectValuable = StaleValue{}

type StaleValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v StaleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaleValue) String() string {
	return "StaleValue"
}

func (v StaleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v StaleValue) Equal(o attr.Value) bool {
	other, ok := o.(StaleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StaleValue) Type(ctx context.Context) attr.Type {
	return StaleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StaticHeadersType{}

type StaticHeadersType struct {
	basetypes.ObjectType
}

func (t StaticHeadersType) Equal(o attr.Type) bool {
	other, ok := o.(StaticHeadersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticHeadersType) String() string {
	return "StaticHeadersType"
}

func (t StaticHeadersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.MapValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticHeadersValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaticHeadersValueNull() StaticHeadersValue {
	return StaticHeadersValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticHeadersValueUnknown() StaticHeadersValue {
	return StaticHeadersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticHeadersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticHeadersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticHeadersValue Attribute Value",
				"While creating a StaticHeadersValue value, a missing attribute value was detected. "+
					"A StaticHeadersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticHeadersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticHeadersValue Attribute Type",
				"While creating a StaticHeadersValue value, an invalid attribute value was detected. "+
					"A StaticHeadersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticHeadersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticHeadersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticHeadersValue Attribute Value",
				"While creating a StaticHeadersValue value, an extra attribute value was detected. "+
					"A StaticHeadersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticHeadersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticHeadersValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStaticHeadersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStaticHeadersValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.MapValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStaticHeadersValueUnknown(), diags
	}

	return StaticHeadersValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaticHeadersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticHeadersValue {
	object, diags := NewStaticHeadersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticHeadersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticHeadersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticHeadersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticHeadersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticHeadersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticHeadersValueMust(StaticHeadersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticHeadersType) ValueType(ctx context.Context) attr.Value {
	return StaticHeadersValue{}
}

var _ basetypes.ObjectValuable = StaticHeadersValue{}

type StaticHeadersValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.MapValue  `tfsdk:"value"`
	state   attr.ValueState
}

func (v StaticHeadersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticHeadersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticHeadersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticHeadersValue) String() string {
	return "StaticHeadersValue"
}

func (v StaticHeadersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.MapValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.MapUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.MapValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v StaticHeadersValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticHeadersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StaticHeadersValue) Type(ctx context.Context) attr.Type {
	return StaticHeadersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticHeadersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StaticRequestHeadersType{}

type StaticRequestHeadersType struct {
	basetypes.ObjectType
}

func (t StaticRequestHeadersType) Equal(o attr.Type) bool {
	other, ok := o.(StaticRequestHeadersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticRequestHeadersType) String() string {
	return "StaticRequestHeadersType"
}

func (t StaticRequestHeadersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.MapValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticRequestHeadersValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaticRequestHeadersValueNull() StaticRequestHeadersValue {
	return StaticRequestHeadersValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticRequestHeadersValueUnknown() StaticRequestHeadersValue {
	return StaticRequestHeadersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticRequestHeadersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticRequestHeadersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticRequestHeadersValue Attribute Value",
				"While creating a StaticRequestHeadersValue value, a missing attribute value was detected. "+
					"A StaticRequestHeadersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticRequestHeadersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticRequestHeadersValue Attribute Type",
				"While creating a StaticRequestHeadersValue value, an invalid attribute value was detected. "+
					"A StaticRequestHeadersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticRequestHeadersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticRequestHeadersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticRequestHeadersValue Attribute Value",
				"While creating a StaticRequestHeadersValue value, an extra attribute value was detected. "+
					"A StaticRequestHeadersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticRequestHeadersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticRequestHeadersValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewStaticRequestHeadersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewStaticRequestHeadersValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.MapValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewStaticRequestHeadersValueUnknown(), diags
	}

	return StaticRequestHeadersValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStaticRequestHeadersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticRequestHeadersValue {
	object, diags := NewStaticRequestHeadersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticRequestHeadersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticRequestHeadersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticRequestHeadersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticRequestHeadersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticRequestHeadersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticRequestHeadersValueMust(StaticRequestHeadersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticRequestHeadersType) ValueType(ctx context.Context) attr.Value {
	return StaticRequestHeadersValue{}
}

var _ basetypes.ObjectValuable = StaticRequestHeadersValue{}

type StaticRequestHeadersValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.MapValue  `tfsdk:"value"`
	state   attr.ValueState
}

func (v StaticRequestHeadersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticRequestHeadersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticRequestHeadersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticRequestHeadersValue) String() string {
	return "StaticRequestHeadersValue"
}

func (v StaticRequestHeadersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.MapValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.MapUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.MapValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v StaticRequestHeadersValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticRequestHeadersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v StaticRequestHeadersValue) Type(ctx context.Context) attr.Type {
	return StaticRequestHeadersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticRequestHeadersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TlsVersionsType{}

type TlsVersionsType struct {
	basetypes.ObjectType
}

func (t TlsVersionsType) Equal(o attr.Type) bool {
	other, ok := o.(TlsVersionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TlsVersionsType) String() string {
	return "TlsVersionsType"
}

func (t TlsVersionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TlsVersionsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTlsVersionsValueNull() TlsVersionsValue {
	return TlsVersionsValue{
		state: attr.ValueStateNull,
	}
}

func NewTlsVersionsValueUnknown() TlsVersionsValue {
	return TlsVersionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTlsVersionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TlsVersionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TlsVersionsValue Attribute Value",
				"While creating a TlsVersionsValue value, a missing attribute value was detected. "+
					"A TlsVersionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsVersionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TlsVersionsValue Attribute Type",
				"While creating a TlsVersionsValue value, an invalid attribute value was detected. "+
					"A TlsVersionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TlsVersionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TlsVersionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TlsVersionsValue Attribute Value",
				"While creating a TlsVersionsValue value, an extra attribute value was detected. "+
					"A TlsVersionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TlsVersionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTlsVersionsValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTlsVersionsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTlsVersionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.ListValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTlsVersionsValueUnknown(), diags
	}

	return TlsVersionsValue{
		Enabled: enabledVal,
		Value:   valueVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTlsVersionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TlsVersionsValue {
	object, diags := NewTlsVersionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTlsVersionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TlsVersionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTlsVersionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTlsVersionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTlsVersionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTlsVersionsValueMust(TlsVersionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TlsVersionsType) ValueType(ctx context.Context) attr.Value {
	return TlsVersionsValue{}
}

var _ basetypes.ObjectValuable = TlsVersionsValue{}

type TlsVersionsValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Value   basetypes.ListValue `tfsdk:"value"`
	state   attr.ValueState
}

func (v TlsVersionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TlsVersionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TlsVersionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TlsVersionsValue) String() string {
	return "TlsVersionsValue"
}

func (v TlsVersionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valueVal basetypes.ListValue
	switch {
	case v.Value.IsUnknown():
		valueVal = types.ListUnknown(types.StringType)
	case v.Value.IsNull():
		valueVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valueVal, d = types.ListValue(types.StringType, v.Value.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"value": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"value":   valueVal,
		})

	return objVal, diags
}

func (v TlsVersionsValue) Equal(o attr.Value) bool {
	other, ok := o.(TlsVersionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TlsVersionsValue) Type(ctx context.Context) attr.Type {
	return TlsVersionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TlsVersionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"value": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ShieldingType{}

type ShieldingType struct {
	basetypes.ObjectType
}

func (t ShieldingType) Equal(o attr.Type) bool {
	other, ok := o.(ShieldingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ShieldingType) String() string {
	return "ShieldingType"
}

func (t ShieldingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	popIdAttribute, ok := attributes["pop_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pop_id is missing from object`)

		return nil, diags
	}

	popIdVal, ok := popIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pop_id expected to be basetypes.Int64Value, was: %T`, popIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ShieldingValue{
		Enabled: enabledVal,
		PopId:   popIdVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewShieldingValueNull() ShieldingValue {
	return ShieldingValue{
		state: attr.ValueStateNull,
	}
}

func NewShieldingValueUnknown() ShieldingValue {
	return ShieldingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewShieldingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ShieldingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ShieldingValue Attribute Value",
				"While creating a ShieldingValue value, a missing attribute value was detected. "+
					"A ShieldingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShieldingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ShieldingValue Attribute Type",
				"While creating a ShieldingValue value, an invalid attribute value was detected. "+
					"A ShieldingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShieldingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ShieldingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ShieldingValue Attribute Value",
				"While creating a ShieldingValue value, an extra attribute value was detected. "+
					"A ShieldingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ShieldingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewShieldingValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewShieldingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	popIdAttribute, ok := attributes["pop_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pop_id is missing from object`)

		return NewShieldingValueUnknown(), diags
	}

	popIdVal, ok := popIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pop_id expected to be basetypes.Int64Value, was: %T`, popIdAttribute))
	}

	if diags.HasError() {
		return NewShieldingValueUnknown(), diags
	}

	return ShieldingValue{
		Enabled: enabledVal,
		PopId:   popIdVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewShieldingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ShieldingValue {
	object, diags := NewShieldingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewShieldingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ShieldingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewShieldingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewShieldingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewShieldingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewShieldingValueMust(ShieldingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ShieldingType) ValueType(ctx context.Context) attr.Value {
	return ShieldingValue{}
}

var _ basetypes.ObjectValuable = ShieldingValue{}

type ShieldingValue struct {
	Enabled basetypes.BoolValue  `tfsdk:"enabled"`
	PopId   basetypes.Int64Value `tfsdk:"pop_id"`
	state   attr.ValueState
}

func (v ShieldingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["pop_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PopId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pop_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ShieldingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ShieldingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ShieldingValue) String() string {
	return "ShieldingValue"
}

func (v ShieldingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"pop_id":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"pop_id":  v.PopId,
		})

	return objVal, diags
}

func (v ShieldingValue) Equal(o attr.Value) bool {
	other, ok := o.(ShieldingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PopId.Equal(other.PopId) {
		return false
	}

	return true
}

func (v ShieldingValue) Type(ctx context.Context) attr.Type {
	return ShieldingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ShieldingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"pop_id":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SslCertificateType{}

type SslCertificateType struct {
	basetypes.ObjectType
}

func (t SslCertificateType) Equal(o attr.Type) bool {
	other, ok := o.(SslCertificateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SslCertificateType) String() string {
	return "SslCertificateType"
}

func (t SslCertificateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SslCertificateValue{
		Id:                 idVal,
		Status:             statusVal,
		SslCertificateType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSslCertificateValueNull() SslCertificateValue {
	return SslCertificateValue{
		state: attr.ValueStateNull,
	}
}

func NewSslCertificateValueUnknown() SslCertificateValue {
	return SslCertificateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSslCertificateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SslCertificateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SslCertificateValue Attribute Value",
				"While creating a SslCertificateValue value, a missing attribute value was detected. "+
					"A SslCertificateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SslCertificateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SslCertificateValue Attribute Type",
				"While creating a SslCertificateValue value, an invalid attribute value was detected. "+
					"A SslCertificateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SslCertificateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SslCertificateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SslCertificateValue Attribute Value",
				"While creating a SslCertificateValue value, an extra attribute value was detected. "+
					"A SslCertificateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SslCertificateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSslCertificateValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSslCertificateValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewSslCertificateValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSslCertificateValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSslCertificateValueUnknown(), diags
	}

	return SslCertificateValue{
		Id:                 idVal,
		Status:             statusVal,
		SslCertificateType: typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSslCertificateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SslCertificateValue {
	object, diags := NewSslCertificateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSslCertificateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SslCertificateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSslCertificateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSslCertificateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSslCertificateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSslCertificateValueMust(SslCertificateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SslCertificateType) ValueType(ctx context.Context) attr.Value {
	return SslCertificateValue{}
}

var _ basetypes.ObjectValuable = SslCertificateValue{}

type SslCertificateValue struct {
	Id                 basetypes.Int64Value  `tfsdk:"id"`
	Status             basetypes.StringValue `tfsdk:"status"`
	SslCertificateType basetypes.StringValue `tfsdk:"type"`
	state              attr.ValueState
}

func (v SslCertificateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.SslCertificateType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SslCertificateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SslCertificateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SslCertificateValue) String() string {
	return "SslCertificateValue"
}

func (v SslCertificateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":     basetypes.Int64Type{},
		"status": basetypes.StringType{},
		"type":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":     v.Id,
			"status": v.Status,
			"type":   v.SslCertificateType,
		})

	return objVal, diags
}

func (v SslCertificateValue) Equal(o attr.Value) bool {
	other, ok := o.(SslCertificateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.SslCertificateType.Equal(other.SslCertificateType) {
		return false
	}

	return true
}

func (v SslCertificateValue) Type(ctx context.Context) attr.Type {
	return SslCertificateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SslCertificateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":     basetypes.Int64Type{},
		"status": basetypes.StringType{},
		"type":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimeoutsType{}

type TimeoutsType struct {
	basetypes.ObjectType
}

func (t TimeoutsType) Equal(o attr.Type) bool {
	other, ok := o.(TimeoutsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimeoutsType) String() string {
	return "TimeoutsType"
}

func (t TimeoutsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return nil, diags
	}

	createVal, ok := createAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.StringValue, was: %T`, createAttribute))
	}

	updateAttribute, ok := attributes["update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update is missing from object`)

		return nil, diags
	}

	updateVal, ok := updateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update expected to be basetypes.StringValue, was: %T`, updateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimeoutsValue{
		Create: createVal,
		Update: updateVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueNull() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateNull,
	}
}

func NewTimeoutsValueUnknown() TimeoutsValue {
	return TimeoutsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimeoutsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimeoutsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, a missing attribute value was detected. "+
					"A TimeoutsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimeoutsValue Attribute Type",
				"While creating a TimeoutsValue value, an invalid attribute value was detected. "+
					"A TimeoutsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimeoutsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimeoutsValue Attribute Value",
				"While creating a TimeoutsValue value, an extra attribute value was detected. "+
					"A TimeoutsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimeoutsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	createAttribute, ok := attributes["create"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	createVal, ok := createAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create expected to be basetypes.StringValue, was: %T`, createAttribute))
	}

	updateAttribute, ok := attributes["update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`update is missing from object`)

		return NewTimeoutsValueUnknown(), diags
	}

	updateVal, ok := updateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`update expected to be basetypes.StringValue, was: %T`, updateAttribute))
	}

	if diags.HasError() {
		return NewTimeoutsValueUnknown(), diags
	}

	return TimeoutsValue{
		Create: createVal,
		Update: updateVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTimeoutsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimeoutsValue {
	object, diags := NewTimeoutsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimeoutsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimeoutsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimeoutsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimeoutsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimeoutsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimeoutsValueMust(TimeoutsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimeoutsType) ValueType(ctx context.Context) attr.Value {
	return TimeoutsValue{}
}

var _ basetypes.ObjectValuable = TimeoutsValue{}

type TimeoutsValue struct {
	Create basetypes.StringValue `tfsdk:"create"`
	Update basetypes.StringValue `tfsdk:"update"`
	state  attr.ValueState
}

func (v TimeoutsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["create"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["update"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Create.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create"] = val

		val, err = v.Update.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["update"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimeoutsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimeoutsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimeoutsValue) String() string {
	return "TimeoutsValue"
}

func (v TimeoutsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"create": basetypes.StringType{},
		"update": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create": v.Create,
			"update": v.Update,
		})

	return objVal, diags
}

func (v TimeoutsValue) Equal(o attr.Value) bool {
	other, ok := o.(TimeoutsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Create.Equal(other.Create) {
		return false
	}

	if !v.Update.Equal(other.Update) {
		return false
	}

	return true
}

func (v TimeoutsValue) Type(ctx context.Context) attr.Type {
	return TimeoutsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimeoutsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create": basetypes.StringType{},
		"update": basetypes.StringType{},
	}
}
