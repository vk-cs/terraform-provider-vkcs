// Code generated by helpers/tfsdk2fw. Manual editing is required.

package {{ .PackageName }}

import (
	"context"
	{{if .HasTimeouts }}"time"{{- end}}

	{{if .HasTimeouts }}"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"{{- end}}
	{{- range .FrameworkValidatorsPackages }}
	"github.com/hashicorp/terraform-plugin-framework-validators/{{ . }}"
	{{- end}}
	{{if .ImportFrameworkAttr }}"github.com/hashicorp/terraform-plugin-framework/attr"{{- end}}
	{{if .EmitResourceImportState }}"github.com/hashicorp/terraform-plugin-framework/path"{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	{{if or (gt (len .FrameworkPlanModifierPackages) 0) (gt (len .ProviderPlanModifierPackages) 0) }}"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"{{- end}}
	{{- range .FrameworkPlanModifierPackages }}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/{{ . }}"
	{{- end}}
	{{if gt (len .FrameworkValidatorsPackages) 0 }}"github.com/hashicorp/terraform-plugin-framework/schema/validator"{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/vk-cs/terraform-provider-vkcs/vkcs/internal/clients"
)

{{if .HasTimeouts }}
const (
{{- if gt .DefaultCreateTimeout 0 }}
	{{ .Name | lower_first }}CreateTimeout = {{ .DefaultCreateTimeout }} * time.Nanosecond // TODO Convert to more human-friendly duration.
{{- end}}
{{- if gt .DefaultReadTimeout 0 }}
	{{ .Name | lower_first }}ReadTimeout   = {{ .DefaultReadTimeout }} * time.Nanosecond // TODO Convert to more human-friendly duration.
{{- end}}
{{- if gt .DefaultUpdateTimeout 0 }}
	{{ .Name | lower_first }}UpdateTimeout = {{ .DefaultUpdateTimeout }} * time.Nanosecond // TODO Convert to more human-friendly duration.
{{- end}}
{{- if gt .DefaultDeleteTimeout 0 }}
	{{ .Name | lower_first }}DeleteTimeout = {{ .DefaultDeleteTimeout }} * time.Nanosecond // TODO Convert to more human-friendly duration.
{{- end}}
)
{{- end}}

var (
    _ resource.Resource = &{{ .Name }}Resource{}
    _ resource.ResourceWithConfigure = &{{ .Name }}Resource{}
{{- if .EmitResourceImportState }}
	_ resource.ResourceWithImportState = &{{ .Name }}Resource{}
{{- end}}
)

func New{{ .Name }}Resource() resource.Resource {
	return &{{ .Name }}Resource{}
}

type {{ .Name }}Resource struct {
    config clients.Config
}

// The structure to read resource plan into and to set state from.
// Consider replacing anonymous structs with named ones
// if any of those are present.
type {{ .Name }}ResourceModel struct {
	{{ .Model }}
	{{if .HasTimeouts }}Timeouts timeouts.Value `tfsdk:"timeouts"`{{- end}}
}

{{- range .NestedModels}}

type {{ $.Name }}Resource{{ .Name }}Model struct {
	{{ .Model }}
}

func (m {{ $.Name }}Resource{{ .Name }}Model) AttrTypes() map[string]attr.Type {
	{{ .AttributeTypesFunc -}}
}
{{- end}}

func (r *{{ .Name }}Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "{{ .TFTypeName }}"
}

func (r *{{ .Name }}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	s := {{ .Schema }}
{{if .HasTimeouts }}
	if s.Blocks == nil {
		s.Blocks = make(map[string]schema.Block)
	}
	s.Blocks["timeouts"] = timeouts.Block(ctx, timeouts.Opts{
	{{- if gt .DefaultCreateTimeout 0 }}
		Create: true,
	{{- end}}
	{{- if gt .DefaultReadTimeout 0 }}
		Read: true,
	{{- end}}
	{{- if gt .DefaultUpdateTimeout 0 }}
		Update: true,
	{{- end}}
	{{- if gt .DefaultDeleteTimeout 0 }}
		Delete: true,
	{{- end}}
	})
{{- end}}

    resp.Schema = s
}

func (r *{{ .Name }}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.config = req.ProviderData.(clients.Config)
}

func (r *{{ .Name }}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{ .Name }}ResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{ if gt .DefaultCreateTimeout 0 }}
	timeout, diags := data.Timeouts.Create(ctx, {{ .Name | lower_first }}CreateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
{{- end}}

	// Consider adding "region" attribute if it is not present.
	region := data.Region.ValueString()
	if region == "" {
		region = r.config.GetRegion()
	}

	client, err := r.config.SomethingClient(region)
	if err != nil {
		resp.Diagnostics.AddError("Error creating VKCS {{ .ServiceName }} API client", err.Error())
		return
	}

	tflog.Debug(ctx, "Calling {{ .ServiceName }} API to create something")

	smth, err := smth.CreateSomething(client).Extract()
	if err != nil {
		resp.Diagnostics.AddError("Error calling VKCS {{ .ServiceName }} API", err.Error())
		return
	}

	tflog.Debug(ctx, "Called {{ .ServiceName }} API to create something")

	id := "TODO"
	resp.State.SetAttribute(ctx, path.Root("id"), id)

	// Wait here for resource creation if needed

	// Set data values to update state with. Use flattenThing() methods
	// to process API responses of complex types.
	data.ID = types.StringValue(id)

    resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{ .Name }}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{ .Name }}ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{ if gt .DefaultReadTimeout 0 }}
	timeout, diags := data.Timeouts.Read(ctx, {{ .Name | lower_first }}ReadTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
{{- end}}

	// Consider adding "region" attribute if it is not present.
	region := data.Region.ValueString()
	if region == "" {
		region = r.config.GetRegion()
	}

	client, err := r.config.SomethingClient(region)
	if err != nil {
		resp.Diagnostics.AddError("Error creating VKCS {{ .ServiceName }} API client", err.Error())
		return
	}

	tflog.Debug(ctx, "Calling {{ .ServiceName }} API to read something")

	smth, err := smth.ReadSomething(client).Extract()
	if err != nil {
		resp.Diagnostics.AddError("Error calling VKCS {{ .ServiceName }} API", err.Error())
		return
	}

	tflog.Debug(ctx, "Called {{ .ServiceName }} API to read something")

    resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *{{ .Name }}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
{{if .EmitResourceUpdateSkeleton }}var state, plan {{ .Name }}ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{ if gt .DefaultUpdateTimeout 0 }}
	timeout, diags := data.Timeouts.Update(ctx, {{ .Name | lower_first }}UpdateTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
{{- end}}

	// Consider adding "region" attribute if it is not present.
	region := data.Region.ValueString()
	if region == "" {
		region = r.config.GetRegion()
	}

	client, err := r.config.SomethingClient(region)
	if err != nil {
		resp.Diagnostics.AddError("Error creating VKCS {{ .ServiceName }} API client", err.Error())
		return
	}

	tflog.Debug(ctx, "Calling {{ .ServiceName }} API to update something")

	smth, err := smth.UpdateSomething(client).Extract()
	if err != nil {
		resp.Diagnostics.AddError("Error calling VKCS {{ .ServiceName }} API", err.Error())
		return
	}

	tflog.Debug(ctx, "Called {{ .ServiceName }} API to update something")

	id := "TODO"
	resp.State.SetAttribute(ctx, path.Root("id"), id)

	// Wait here for resource update if needed

    resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
{{- else}}
	var data {{ .Name }}ResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.AddError("Unable to update the resource",
		"Not implemented. Please report this issue to the provider developers.")
{{- end}}
}

func (r *{{ .Name }}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{ .Name }}ResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{ if gt .DefaultDeleteTimeout 0 }}
	timeout, diags := data.Timeouts.Delete(ctx, {{ .Name | lower_first }}DeleteTimeout)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
{{- end}}

	// Consider adding "region" attribute if it is not present.
	region := data.Region.ValueString()
	if region == "" {
		region = r.config.GetRegion()
	}

	client, err := r.config.SomethingClient(region)
	if err != nil {
		resp.Diagnostics.AddError("Error creating VKCS {{ .ServiceName }} API client", err.Error())
		return
	}

	tflog.Debug(ctx, "Calling {{ .ServiceName }} API to delete something")

	err := smth.DeleteSomething(client).Extract()
	if err != nil {
		resp.Diagnostics.AddError("Error calling VKCS {{ .ServiceName }} API", err.Error())
		return
	}

	// Wait here for resource deletion if needed

	tflog.Debug(ctx, "Called {{ .ServiceName }} API to delete something")
}

{{if .EmitResourceImportState }}
// ImportState is called when the provider must import the state of a resource instance.
// This method must return enough state so the Read method can properly refresh the full resource.
func (r *{{ .Name }}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
{{- end}}
